// This file has been auto-generated by ASNR
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(dead_code)]
#![allow(unused_mut)]
#![allow(unused_variables)]

use asnr_grammar::*;
use nom::IResult;
use asnr_transcoder::{error::{DecodingError, DecodingErrorType}, Decode, Decoder};


/* 










 Specification of CDD Data Elements: 











* 
 * This DE indicates a change of acceleration.
 *
 * The value shall be set to:
 * - 0 - `accelerate` - if the magnitude of the horizontal velocity vector increases.
 * - 1 - `decelerate` - if the magnitude of the horizontal velocity vector decreases.
 *
 * @category: Kinematic information
 * @revision: Created in V2.1.1
*/
#[derive(Debug, Clone, PartialEq, Default)]
pub enum AccelerationChange {
  #[default]
  accelerate = 0,
	decelerate = 1,
}

impl TryFrom<i128> for AccelerationChange {
    type Error = DecodingError;

    fn try_from(v: i128) -> Result<Self, Self::Error> {
        match v {
            x if x == Self::accelerate as i128 => Ok(Self::accelerate),
		  x if x == Self::decelerate as i128 => Ok(Self::decelerate),
            _ => Err(
              DecodingError::new(
                &format!("Invalid enumerated index decoding AccelerationChange. Received index {}",v), DecodingErrorType::InvalidEnumeratedIndex
              )
            ),
        }
    }
}

impl Decode for AccelerationChange {
    fn decode<'a, D>(decoder: &D, input: &'a [u8]) -> IResult<&'a [u8], Self>
    where
        D: Decoder,
        Self: Sized,
    {
        decoder.decode_enumerated(AsnEnumerated { members: vec![Enumeral { name: "accelerate".into(), description: None, index: 0 },Enumeral { name: "decelerate".into(), description: None, index: 1 }], extensible: None })( 
          input
        )
    }
}


/* *
 * This DE indicates the acceleration confidence value which represents the estimated absolute accuracy of an acceleration value with a default confidence level of 95 %. 
 * If required, the confidence level can be defined by the corresponding standards applying this DE.
 *
 * The value shall be set to:
 * - `n` (`n > 0` and `n < 101`) if the confidence value is equal to or less than n x 0,1 m/s^2, and greater than (n-1) x 0,1 m/s^2,
 * - `101` if the confidence value is out of range i.e. greater than 10 m/s^2,
 * - `102` if the confidence value is unavailable.
 *
 * The value 0 shall not be used.
 *
 * @note: The fact that an acceleration value is received with confidence value set to `unavailable(102)` can be caused by several reasons, such as:
 * - the sensor cannot deliver the accuracy at the defined confidence level because it is a low-end sensor,
 * - the sensor cannot calculate the accuracy due to lack of variables, or
 * - there has been a vehicle bus (e.g. CAN bus) error.
 * In all 3 cases above, the acceleration value may be valid and used by the application.
 * 
 * @note: If an acceleration value is received and its confidence value is set to `outOfRange(101)`, it means that the value is not valid and therefore cannot be trusted. Such value is not useful for the application.
 *
 * @unit 0,1 m/s^2
 * @category: Kinematic information
 * @revision: Description revised in V2.1.1
 */
#[derive(Debug, Clone, PartialEq, Default)]
pub struct AccelerationConfidence(pub u8);

impl AccelerationConfidence {
  pub fn is_outOfRange(&self) -> bool { self.0 as i128 == 101 }
  pub fn is_unavailable(&self) -> bool { self.0 as i128 == 102 }
}

impl Decode for AccelerationConfidence {
    fn decode<'a, D>(decoder: &D, input: &'a [u8]) -> IResult<&'a [u8], Self>
    where
        D: Decoder,
        Self: Sized,
    {
        decoder
            .decode_integer(AsnInteger { constraint: Some(Constraint { min_value: Some(0), max_value: Some(102), extensible: false }), distinguished_values: Some(vec![DistinguishedValue { name: "outOfRange".into(), value: 101 },DistinguishedValue { name: "unavailable".into(), value: 102 }]) })(input)
            .map(|(remaining, res)| (remaining, Self(res)))
    }
}


/* *
 * This DE indicates the current controlling mechanism for longitudinal movement of the vehicle.
 * The data may be provided via the in-vehicle network. It indicates whether a specific in-vehicle
 * acceleration control system is engaged or not. Currently, this DE includes the information of the
 * vehicle brake pedal, gas pedal, emergency brake system, collision warning system, adaptive cruise
 * control system, cruise control system and speed limiter system.
 *
 * The corresponding bit shall be set to 1 under the following conditions:
 * - 0 - `brakePedalEngaged`      - Driver is stepping on the brake pedal,
 * - 1 - `gasPedalEngaged`        - Driver is stepping on the gas pedal,
 * - 2 - `emergencyBrakeEngaged`  - emergency brake system is engaged,
 * - 3 - `collisionWarningEngaged`- collision warning system is engaged,
 * - 4 - `accEngaged`             - ACC is engaged,
 * - 5 - `cruiseControlEngaged`   - cruise control is engaged,
 * - 6 - `speedLimiterEngaged`    - speed limiter is engaged.
 *
 * Otherwise (for example when the corresponding system is not available due to non equipped system
 * or information is unavailable), the corresponding bit shall be set to 0.
 *
 * @note: The system engagement condition is OEM specific and therefore out of scope of the present document.
 * @category: Vehicle information
 * @revision: V1.3.1
 */
#[derive(Debug, Clone, PartialEq, Default)]
pub struct AccelerationControl(pub Vec<bool>);

impl AccelerationControl {
  pub fn is_brakePedalEngaged(&self) -> bool { *self.0.get(0).unwrap_or(&false) }
  pub fn is_gasPedalEngaged(&self) -> bool { *self.0.get(1).unwrap_or(&false) }
  pub fn is_emergencyBrakeEngaged(&self) -> bool { *self.0.get(2).unwrap_or(&false) }
  pub fn is_collisionWarningEngaged(&self) -> bool { *self.0.get(3).unwrap_or(&false) }
  pub fn is_accEngaged(&self) -> bool { *self.0.get(4).unwrap_or(&false) }
  pub fn is_cruiseControlEngaged(&self) -> bool { *self.0.get(5).unwrap_or(&false) }
  pub fn is_speedLimiterEngaged(&self) -> bool { *self.0.get(6).unwrap_or(&false) }
}

impl Decode for AccelerationControl {
  fn decode<'a, D>(decoder: &D, input: &'a [u8]) -> IResult<&'a [u8], Self>
  where
      D: Decoder,
      Self: Sized,
  {
      decoder
          .decode_bit_string(AsnBitString { constraint: Some(Constraint { min_value: Some(7), max_value: Some(7), extensible: false }), distinguished_values: Some(vec![DistinguishedValue { name: "brakePedalEngaged".into(), value: 0 },DistinguishedValue { name: "gasPedalEngaged".into(), value: 1 },DistinguishedValue { name: "emergencyBrakeEngaged".into(), value: 2 },DistinguishedValue { name: "collisionWarningEngaged".into(), value: 3 },DistinguishedValue { name: "accEngaged".into(), value: 4 },DistinguishedValue { name: "cruiseControlEngaged".into(), value: 5 },DistinguishedValue { name: "speedLimiterEngaged".into(), value: 6 }]) })(input)
          .map(|(remaining, res)| (remaining, Self(res)))
  }
}


/* * 
 * This DE represents the magnitude of the acceleration vector in a defined coordinate system.
 *
 * The value shall be set to:
 * - `0` to indicate no acceleration,
 * - `n` (`n > 0` and `n < 160`) to indicate acceleration equal to or less than n x 0,1 m/s^2, and greater than (n-1) x 0,1 m/s^2,
 * - `160` for acceleration values greater than 15,9 m/s^2,
 * - `161` when the data is unavailable.
 *
 * @unit 0,1 m/s^2
 * @category: Kinematic information
 * @revision: Created in V2.1.1
*/
#[derive(Debug, Clone, PartialEq, Default)]
pub struct AccelerationMagnitudeValue(pub u8);

impl AccelerationMagnitudeValue {
  pub fn is_positiveOutOfRange(&self) -> bool { self.0 as i128 == 160 }
  pub fn is_unavailable(&self) -> bool { self.0 as i128 == 161 }
}

impl Decode for AccelerationMagnitudeValue {
    fn decode<'a, D>(decoder: &D, input: &'a [u8]) -> IResult<&'a [u8], Self>
    where
        D: Decoder,
        Self: Sized,
    {
        decoder
            .decode_integer(AsnInteger { constraint: Some(Constraint { min_value: Some(0), max_value: Some(161), extensible: false }), distinguished_values: Some(vec![DistinguishedValue { name: "positiveOutOfRange".into(), value: 160 },DistinguishedValue { name: "unavailable".into(), value: 161 }]) })(input)
            .map(|(remaining, res)| (remaining, Self(res)))
    }
}


/* * 
 * This DE represents the value of an acceleration component in a defined coordinate system.
 *
 * The value shall be set to:
 * - `-160` for acceleration values equal to or less than -16 m/s^2,
 * - `n` (`n > -160` and `n <= 0`) to indicate negative acceleration equal to or less than n x 0,1 m/s^2, and greater than (n-1) x 0,1 m/s^2,
 * - `n` (`n > 0` and `n < 160`) to indicate positive acceleration equal to or less than n x 0,1 m/s^2, and greater than (n-1) x 0,1 m/s^2,
 * - `160` for acceleration values greater than 15,9 m/s^2,
 * - `161` when the data is unavailable.
 *
 * @note: the formula for values > -160 and <160 results in rounding up to the next value. Zero acceleration is indicated using n=0.
 * @unit 0,1 m/s^2
 * @category: Kinematic information
 * @revision: Created in V2.1.1
*/
#[derive(Debug, Clone, PartialEq, Default)]
pub struct AccelerationValue(pub i16);

impl AccelerationValue {
  pub fn is_negativeOutOfRange(&self) -> bool { self.0 as i128 == -160 }
  pub fn is_positiveOutOfRange(&self) -> bool { self.0 as i128 == 160 }
  pub fn is_unavailable(&self) -> bool { self.0 as i128 == 161 }
}

impl Decode for AccelerationValue {
    fn decode<'a, D>(decoder: &D, input: &'a [u8]) -> IResult<&'a [u8], Self>
    where
        D: Decoder,
        Self: Sized,
    {
        decoder
            .decode_integer(AsnInteger { constraint: Some(Constraint { min_value: Some(-160), max_value: Some(161), extensible: false }), distinguished_values: Some(vec![DistinguishedValue { name: "negativeOutOfRange".into(), value: -160 },DistinguishedValue { name: "positiveOutOfRange".into(), value: 160 },DistinguishedValue { name: "unavailable".into(), value: 161 }]) })(input)
            .map(|(remaining, res)| (remaining, Self(res)))
    }
}


/* *
 * This DE indicates an access technology.
 *
 * The value shall be set to:
 * - `0`: in case of any access technology class,
 * - `1`: in case of ITS-G5 access technology class,
 * - `2`: in case of LTE-V2X access technology class,
 * - `3`: in case of NR-V2X access technology class.
 * 
 * @category: Communication information
 * @revision: Created in V2.1.1
 */
#[derive(Debug, Clone, PartialEq, Default)]
pub enum AccessTechnologyClass {
  #[default]
  any = 0,
	itsg5Class = 1,
	ltev2xClass = 2,
	nrv2xClass = 3,
}

impl TryFrom<i128> for AccessTechnologyClass {
    type Error = DecodingError;

    fn try_from(v: i128) -> Result<Self, Self::Error> {
        match v {
            x if x == Self::any as i128 => Ok(Self::any),
		  x if x == Self::itsg5Class as i128 => Ok(Self::itsg5Class),
		  x if x == Self::ltev2xClass as i128 => Ok(Self::ltev2xClass),
		  x if x == Self::nrv2xClass as i128 => Ok(Self::nrv2xClass),
            _ => Err(
              DecodingError::new(
                &format!("Invalid enumerated index decoding AccessTechnologyClass. Received index {}",v), DecodingErrorType::InvalidEnumeratedIndex
              )
            ),
        }
    }
}

impl Decode for AccessTechnologyClass {
    fn decode<'a, D>(decoder: &D, input: &'a [u8]) -> IResult<&'a [u8], Self>
    where
        D: Decoder,
        Self: Sized,
    {
        decoder.decode_enumerated(AsnEnumerated { members: vec![Enumeral { name: "any".into(), description: None, index: 0 },Enumeral { name: "itsg5Class".into(), description: None, index: 1 },Enumeral { name: "ltev2xClass".into(), description: None, index: 2 },Enumeral { name: "nrv2xClass".into(), description: None, index: 3 }], extensible: Some(4) })( 
          input
        )
    }
}


/* *
 * This DE represents the value of the sub cause code of the @ref CauseCode `accident`.
 *
 * The value shall be set to:
 * - 0 - `unavailable`                        - in case the information on the sub cause of the accident is unavailable,
 * - 1 - `multiVehicleAccident`               - in case more than two vehicles are involved in accident,
 * - 2 - `heavyAccident`                      - in case the airbag of the vehicle involved in the accident is triggered, 
 *                                              the accident requires important rescue and/or recovery work,
 * - 3 - `accidentInvolvingLorry`             - in case the accident involves a lorry,
 * - 4 - `accidentInvolvingBus`               - in case the accident involves a bus,
 * - 5 - `accidentInvolvingHazardousMaterials`- in case the accident involves hazardous material,
 * - 6 - `accidentOnOppositeLane`             - in case the accident happens on opposite lanes,
 * - 7 - `unsecuredAccident`                  - in case the accident is not secured,
 * - 8 - `assistanceRequested`                - in case rescue and assistance are requested,
 * - 9-255                                    - reserved for future usage. 
 *
 * @category: Traffic information
 * @revision: V1.3.1
 */
#[derive(Debug, Clone, PartialEq, Default)]
pub struct AccidentSubCauseCode(pub u8);

impl AccidentSubCauseCode {
  pub fn is_unavailable(&self) -> bool { self.0 as i128 == 0 }
  pub fn is_multiVehicleAccident(&self) -> bool { self.0 as i128 == 1 }
  pub fn is_heavyAccident(&self) -> bool { self.0 as i128 == 2 }
  pub fn is_accidentInvolvingLorry(&self) -> bool { self.0 as i128 == 3 }
  pub fn is_accidentInvolvingBus(&self) -> bool { self.0 as i128 == 4 }
  pub fn is_accidentInvolvingHazardousMaterials(&self) -> bool { self.0 as i128 == 5 }
  pub fn is_accidentOnOppositeLane(&self) -> bool { self.0 as i128 == 6 }
  pub fn is_unsecuredAccident(&self) -> bool { self.0 as i128 == 7 }
  pub fn is_assistanceRequested(&self) -> bool { self.0 as i128 == 8 }
}

impl Decode for AccidentSubCauseCode {
    fn decode<'a, D>(decoder: &D, input: &'a [u8]) -> IResult<&'a [u8], Self>
    where
        D: Decoder,
        Self: Sized,
    {
        decoder
            .decode_integer(AsnInteger { constraint: Some(Constraint { min_value: Some(0), max_value: Some(255), extensible: false }), distinguished_values: Some(vec![DistinguishedValue { name: "unavailable".into(), value: 0 },DistinguishedValue { name: "multiVehicleAccident".into(), value: 1 },DistinguishedValue { name: "heavyAccident".into(), value: 2 },DistinguishedValue { name: "accidentInvolvingLorry".into(), value: 3 },DistinguishedValue { name: "accidentInvolvingBus".into(), value: 4 },DistinguishedValue { name: "accidentInvolvingHazardousMaterials".into(), value: 5 },DistinguishedValue { name: "accidentOnOppositeLane".into(), value: 6 },DistinguishedValue { name: "unsecuredAccident".into(), value: 7 },DistinguishedValue { name: "assistanceRequested".into(), value: 8 }]) })(input)
            .map(|(remaining, res)| (remaining, Self(res)))
    }
}


/* *
 * This DE represents the value of the sub cause code of the @ref CauseCode `adverseWeatherCondition-Adhesion`. 
 * 
 * The value shall be set to:
 * - 0 - `unavailable`     - in case information on the cause of the low road adhesion is unavailable,
 * - 1 - `heavyFrostOnRoad`- in case the low road adhesion is due to heavy frost on the road,
 * - 2 - `fuelOnRoad`      - in case the low road adhesion is due to fuel on the road,
 * - 3 - `mudOnRoad`       - in case the low road adhesion is due to mud on the road,
 * - 4 - `snowOnRoad`      - in case the low road adhesion is due to snow on the road,
 * - 5 - `iceOnRoad`       - in case the low road adhesion is due to ice on the road,
 * - 6 - `blackIceOnRoad`  - in case the low road adhesion is due to black ice on the road,
 * - 7 - `oilOnRoad`       - in case the low road adhesion is due to oil on the road,
 * - 8 - `looseChippings`  - in case the low road adhesion is due to loose gravel or stone fragments detached from a road surface or from a hazard,
 * - 9 - `instantBlackIce` - in case the low road adhesion is due to instant black ice on the road surface,
 * - 10 - `roadsSalted`    - when the low road adhesion is due to salted road,
 * - 11-255                - are reserved for future usage.
 *
 * @category: Traffic information
 * @revision: V1.3.1
 */
#[derive(Debug, Clone, PartialEq, Default)]
pub struct AdverseWeatherCondition_AdhesionSubCauseCode(pub u8);

impl AdverseWeatherCondition_AdhesionSubCauseCode {
  pub fn is_unavailable(&self) -> bool { self.0 as i128 == 0 }
  pub fn is_heavyFrostOnRoad(&self) -> bool { self.0 as i128 == 1 }
  pub fn is_fuelOnRoad(&self) -> bool { self.0 as i128 == 2 }
  pub fn is_mudOnRoad(&self) -> bool { self.0 as i128 == 3 }
  pub fn is_snowOnRoad(&self) -> bool { self.0 as i128 == 4 }
  pub fn is_iceOnRoad(&self) -> bool { self.0 as i128 == 5 }
  pub fn is_blackIceOnRoad(&self) -> bool { self.0 as i128 == 6 }
  pub fn is_oilOnRoad(&self) -> bool { self.0 as i128 == 7 }
  pub fn is_looseChippings(&self) -> bool { self.0 as i128 == 8 }
  pub fn is_instantBlackIce(&self) -> bool { self.0 as i128 == 9 }
  pub fn is_roadsSalted(&self) -> bool { self.0 as i128 == 10 }
}

impl Decode for AdverseWeatherCondition_AdhesionSubCauseCode {
    fn decode<'a, D>(decoder: &D, input: &'a [u8]) -> IResult<&'a [u8], Self>
    where
        D: Decoder,
        Self: Sized,
    {
        decoder
            .decode_integer(AsnInteger { constraint: Some(Constraint { min_value: Some(0), max_value: Some(255), extensible: false }), distinguished_values: Some(vec![DistinguishedValue { name: "unavailable".into(), value: 0 },DistinguishedValue { name: "heavyFrostOnRoad".into(), value: 1 },DistinguishedValue { name: "fuelOnRoad".into(), value: 2 },DistinguishedValue { name: "mudOnRoad".into(), value: 3 },DistinguishedValue { name: "snowOnRoad".into(), value: 4 },DistinguishedValue { name: "iceOnRoad".into(), value: 5 },DistinguishedValue { name: "blackIceOnRoad".into(), value: 6 },DistinguishedValue { name: "oilOnRoad".into(), value: 7 },DistinguishedValue { name: "looseChippings".into(), value: 8 },DistinguishedValue { name: "instantBlackIce".into(), value: 9 },DistinguishedValue { name: "roadsSalted".into(), value: 10 }]) })(input)
            .map(|(remaining, res)| (remaining, Self(res)))
    }
}


/* *
 * This DE represents the value of the sub cause codes of the @ref CauseCode `adverseWeatherCondition-ExtremeWeatherCondition`.
 *
 * The value shall be set to:
 * - 0 - `unavailable` - in case information on the type of extreme weather condition is unavailable,
 * - 1 - `strongWinds` - in case the type of extreme weather condition is strong wind,
 * - 2 - `damagingHail`- in case the type of extreme weather condition is damaging hail,
 * - 3 - `hurricane`   - in case the type of extreme weather condition is hurricane,
 * - 4 - `thunderstorm`- in case the type of extreme weather condition is thunderstorm,
 * - 5 - `tornado`     - in case the type of extreme weather condition is tornado,
 * - 6 - `blizzard`    - in case the type of extreme weather condition is blizzard.
 * - 7-255             - are reserved for future usage.
 *
 * @category: Traffic information
 * @revision: V1.3.1
 */
#[derive(Debug, Clone, PartialEq, Default)]
pub struct AdverseWeatherCondition_ExtremeWeatherConditionSubCauseCode(pub u8);

impl AdverseWeatherCondition_ExtremeWeatherConditionSubCauseCode {
  pub fn is_unavailable(&self) -> bool { self.0 as i128 == 0 }
  pub fn is_strongWinds(&self) -> bool { self.0 as i128 == 1 }
  pub fn is_damagingHail(&self) -> bool { self.0 as i128 == 2 }
  pub fn is_hurricane(&self) -> bool { self.0 as i128 == 3 }
  pub fn is_thunderstorm(&self) -> bool { self.0 as i128 == 4 }
  pub fn is_tornado(&self) -> bool { self.0 as i128 == 5 }
  pub fn is_blizzard(&self) -> bool { self.0 as i128 == 6 }
}

impl Decode for AdverseWeatherCondition_ExtremeWeatherConditionSubCauseCode {
    fn decode<'a, D>(decoder: &D, input: &'a [u8]) -> IResult<&'a [u8], Self>
    where
        D: Decoder,
        Self: Sized,
    {
        decoder
            .decode_integer(AsnInteger { constraint: Some(Constraint { min_value: Some(0), max_value: Some(255), extensible: false }), distinguished_values: Some(vec![DistinguishedValue { name: "unavailable".into(), value: 0 },DistinguishedValue { name: "strongWinds".into(), value: 1 },DistinguishedValue { name: "damagingHail".into(), value: 2 },DistinguishedValue { name: "hurricane".into(), value: 3 },DistinguishedValue { name: "thunderstorm".into(), value: 4 },DistinguishedValue { name: "tornado".into(), value: 5 },DistinguishedValue { name: "blizzard".into(), value: 6 }]) })(input)
            .map(|(remaining, res)| (remaining, Self(res)))
    }
}


/* *
 * This DE represents the value of the sub cause codes of the @ref CauseCode `adverseWeatherCondition-Precipitation`. 
 *
 * The value shall be set to:
 * - 0 - `unavailable`   - in case information on the type of precipitation is unavailable,
 * - 1 - `heavyRain`     - in case the type of precipitation is heavy rain,
 * - 2 - `heavySnowfall` - in case the type of precipitation is heavy snow fall,
 * - 3 - `softHail`      - in case the type of precipitation is soft hail.
 * - 4-255               - are reserved for future usage
 *
 * @category: Traffic information
 * @revision: V1.3.1
 */
#[derive(Debug, Clone, PartialEq, Default)]
pub struct AdverseWeatherCondition_PrecipitationSubCauseCode(pub u8);

impl AdverseWeatherCondition_PrecipitationSubCauseCode {
  pub fn is_unavailable(&self) -> bool { self.0 as i128 == 0 }
  pub fn is_heavyRain(&self) -> bool { self.0 as i128 == 1 }
  pub fn is_heavySnowfall(&self) -> bool { self.0 as i128 == 2 }
  pub fn is_softHail(&self) -> bool { self.0 as i128 == 3 }
}

impl Decode for AdverseWeatherCondition_PrecipitationSubCauseCode {
    fn decode<'a, D>(decoder: &D, input: &'a [u8]) -> IResult<&'a [u8], Self>
    where
        D: Decoder,
        Self: Sized,
    {
        decoder
            .decode_integer(AsnInteger { constraint: Some(Constraint { min_value: Some(0), max_value: Some(255), extensible: false }), distinguished_values: Some(vec![DistinguishedValue { name: "unavailable".into(), value: 0 },DistinguishedValue { name: "heavyRain".into(), value: 1 },DistinguishedValue { name: "heavySnowfall".into(), value: 2 },DistinguishedValue { name: "softHail".into(), value: 3 }]) })(input)
            .map(|(remaining, res)| (remaining, Self(res)))
    }
}


/* *
 * This DE represents the value of the sub cause codes of the @ref CauseCode `adverseWeatherCondition-Visibility`.
 *
 * The value shall be set to:
 * - 0 - `unavailable`    - in case information on the cause of low visibility is unavailable,
 * - 1 - `fog`            - in case the cause of low visibility is fog,
 * - 2 - `smoke`          - in case the cause of low visibility is smoke,
 * - 3 - `heavySnowfall`  - in case the cause of low visibility is heavy snow fall,
 * - 4 - `heavyRain`      - in case the cause of low visibility is heavy rain,
 * - 5 - `heavyHail`      - in case the cause of low visibility is heavy hail,
 * - 6 - `lowSunGlare`    - in case the cause of low visibility is sun glare,
 * - 7 - `sandstorms`     - in case the cause of low visibility is sand storm,
 * - 8 - `swarmsOfInsects`- in case the cause of low visibility is swarm of insects.
 * - 9-255                - are reserved for future usage
 *
 * @category: Traffic information
 * @revision: V1.3.1
 */
#[derive(Debug, Clone, PartialEq, Default)]
pub struct AdverseWeatherCondition_VisibilitySubCauseCode(pub u8);

impl AdverseWeatherCondition_VisibilitySubCauseCode {
  pub fn is_unavailable(&self) -> bool { self.0 as i128 == 0 }
  pub fn is_fog(&self) -> bool { self.0 as i128 == 1 }
  pub fn is_smoke(&self) -> bool { self.0 as i128 == 2 }
  pub fn is_heavySnowfall(&self) -> bool { self.0 as i128 == 3 }
  pub fn is_heavyRain(&self) -> bool { self.0 as i128 == 4 }
  pub fn is_heavyHail(&self) -> bool { self.0 as i128 == 5 }
  pub fn is_lowSunGlare(&self) -> bool { self.0 as i128 == 6 }
  pub fn is_sandstorms(&self) -> bool { self.0 as i128 == 7 }
  pub fn is_swarmsOfInsects(&self) -> bool { self.0 as i128 == 8 }
}

impl Decode for AdverseWeatherCondition_VisibilitySubCauseCode {
    fn decode<'a, D>(decoder: &D, input: &'a [u8]) -> IResult<&'a [u8], Self>
    where
        D: Decoder,
        Self: Sized,
    {
        decoder
            .decode_integer(AsnInteger { constraint: Some(Constraint { min_value: Some(0), max_value: Some(255), extensible: false }), distinguished_values: Some(vec![DistinguishedValue { name: "unavailable".into(), value: 0 },DistinguishedValue { name: "fog".into(), value: 1 },DistinguishedValue { name: "smoke".into(), value: 2 },DistinguishedValue { name: "heavySnowfall".into(), value: 3 },DistinguishedValue { name: "heavyRain".into(), value: 4 },DistinguishedValue { name: "heavyHail".into(), value: 5 },DistinguishedValue { name: "lowSunGlare".into(), value: 6 },DistinguishedValue { name: "sandstorms".into(), value: 7 },DistinguishedValue { name: "swarmsOfInsects".into(), value: 8 }]) })(input)
            .map(|(remaining, res)| (remaining, Self(res)))
    }
}


/* *
 * This DE represents the air humidity in tenths of percent.
 *
 * The value shall be set to:
 * - `n` (`n > 0` and `n < 1001`) indicates that the applicable value is equal to or less than n x 0,1 percent and greater than (n-1) x 0,1 percent.
 * - `1001` indicates that the air humidity is unavailable.
 *
 * @category: Basic information
 * @unit: 0,1 % 
 * @revision: created in V2.1.1
 */
#[derive(Debug, Clone, PartialEq, Default)]
pub struct AirHumidity(pub u16);

impl AirHumidity {
  pub fn is_oneHundredPercent(&self) -> bool { self.0 as i128 == 1000 }
  pub fn is_unavailable(&self) -> bool { self.0 as i128 == 1001 }
}

impl Decode for AirHumidity {
    fn decode<'a, D>(decoder: &D, input: &'a [u8]) -> IResult<&'a [u8], Self>
    where
        D: Decoder,
        Self: Sized,
    {
        decoder
            .decode_integer(AsnInteger { constraint: Some(Constraint { min_value: Some(1), max_value: Some(1001), extensible: false }), distinguished_values: Some(vec![DistinguishedValue { name: "oneHundredPercent".into(), value: 1000 },DistinguishedValue { name: "unavailable".into(), value: 1001 }]) })(input)
            .map(|(remaining, res)| (remaining, Self(res)))
    }
}


/* *
 * This DE indicates the altitude confidence value which represents the estimated absolute accuracy of an altitude value of a geographical point with a default confidence level of 95 %.
 * If required, the confidence level can be defined by the corresponding standards applying this DE.
 *
 * The value shall be set to: 
 *   - 0  - `alt-000-01`   - if the confidence value is equal to or less than 0,01 metre,
 *   - 1  - `alt-000-02`   - if the confidence value is equal to or less than 0,02 metre and greater than 0,01 metre,
 *   - 2  - `alt-000-05`   - if the confidence value is equal to or less than 0,05 metre and greater than 0,02 metre,            
 *   - 3  - `alt-000-10`   - if the confidence value is equal to or less than 0,1 metre and greater than 0,05 metre,            
 *   - 4  - `alt-000-20`   - if the confidence value is equal to or less than 0,2 metre and greater than 0,1 metre,            
 *   - 5  - `alt-000-50`   - if the confidence value is equal to or less than 0,5 metre and greater than 0,2 metre,             
 *   - 6  - `alt-001-00`   - if the confidence value is equal to or less than 1 metre and greater than 0,5 metre,             
 *   - 7  - `alt-002-00`   - if the confidence value is equal to or less than 2 metres and greater than 1 metre,             
 *   - 8  - `alt-005-00`   - if the confidence value is equal to or less than 5 metres and greater than 2 metres,              
 *   - 9  - `alt-010-00`   - if the confidence value is equal to or less than 10 metres and greater than 5 metres,             
 *   - 10 - `alt-020-00`   - if the confidence value is equal to or less than 20 metres and greater than 10 metres,            
 *   - 11 - `alt-050-00`   - if the confidence value is equal to or less than 50 metres and greater than 20 metres,            
 *   - 12 - `alt-100-00`   - if the confidence value is equal to or less than 100 metres and greater than 50 metres,           
 *   - 13 - `alt-200-00`   - if the confidence value is equal to or less than 200 metres and greater than 100 metres,           
 *   - 14 - `outOfRange`   - if the confidence value is out of range, i.e. greater than 200 metres,
 *   - 15 - `unavailable`  - if the confidence value is unavailable.       
 *
 * @note: The fact that an altitude value is received with confidence value set to `unavailable(15)` can be caused
 * by several reasons, such as:
 * - the sensor cannot deliver the accuracy at the defined confidence level because it is a low-end sensor,
 * - the sensor cannot calculate the accuracy due to lack of variables, or
 * - there has been a vehicle bus (e.g. CAN bus) error.
 * In all 3 cases above, the altitude value may be valid and used by the application.
 * 
 * @note: If an altitude value is received and its confidence value is set to `outOfRange(14)`, it means that the  
 * altitude value is not valid and therefore cannot be trusted. Such value is not useful for the application.             
 *
 * @category: GeoReference information
 * @revision: Description revised in V2.1.1
 */
#[derive(Debug, Clone, PartialEq, Default)]
pub enum AltitudeConfidence {
  #[default]
  alt_000_01 = 0,
	alt_000_02 = 1,
	alt_000_05 = 2,
	alt_000_10 = 3,
	alt_000_20 = 4,
	alt_000_50 = 5,
	alt_001_00 = 6,
	alt_002_00 = 7,
	alt_005_00 = 8,
	alt_010_00 = 9,
	alt_020_00 = 10,
	alt_050_00 = 11,
	alt_100_00 = 12,
	alt_200_00 = 13,
	outOfRange = 14,
	unavailable = 15,
}

impl TryFrom<i128> for AltitudeConfidence {
    type Error = DecodingError;

    fn try_from(v: i128) -> Result<Self, Self::Error> {
        match v {
            x if x == Self::alt_000_01 as i128 => Ok(Self::alt_000_01),
		  x if x == Self::alt_000_02 as i128 => Ok(Self::alt_000_02),
		  x if x == Self::alt_000_05 as i128 => Ok(Self::alt_000_05),
		  x if x == Self::alt_000_10 as i128 => Ok(Self::alt_000_10),
		  x if x == Self::alt_000_20 as i128 => Ok(Self::alt_000_20),
		  x if x == Self::alt_000_50 as i128 => Ok(Self::alt_000_50),
		  x if x == Self::alt_001_00 as i128 => Ok(Self::alt_001_00),
		  x if x == Self::alt_002_00 as i128 => Ok(Self::alt_002_00),
		  x if x == Self::alt_005_00 as i128 => Ok(Self::alt_005_00),
		  x if x == Self::alt_010_00 as i128 => Ok(Self::alt_010_00),
		  x if x == Self::alt_020_00 as i128 => Ok(Self::alt_020_00),
		  x if x == Self::alt_050_00 as i128 => Ok(Self::alt_050_00),
		  x if x == Self::alt_100_00 as i128 => Ok(Self::alt_100_00),
		  x if x == Self::alt_200_00 as i128 => Ok(Self::alt_200_00),
		  x if x == Self::outOfRange as i128 => Ok(Self::outOfRange),
		  x if x == Self::unavailable as i128 => Ok(Self::unavailable),
            _ => Err(
              DecodingError::new(
                &format!("Invalid enumerated index decoding AltitudeConfidence. Received index {}",v), DecodingErrorType::InvalidEnumeratedIndex
              )
            ),
        }
    }
}

impl Decode for AltitudeConfidence {
    fn decode<'a, D>(decoder: &D, input: &'a [u8]) -> IResult<&'a [u8], Self>
    where
        D: Decoder,
        Self: Sized,
    {
        decoder.decode_enumerated(AsnEnumerated { members: vec![Enumeral { name: "alt-000-01".into(), description: None, index: 0 },Enumeral { name: "alt-000-02".into(), description: None, index: 1 },Enumeral { name: "alt-000-05".into(), description: None, index: 2 },Enumeral { name: "alt-000-10".into(), description: None, index: 3 },Enumeral { name: "alt-000-20".into(), description: None, index: 4 },Enumeral { name: "alt-000-50".into(), description: None, index: 5 },Enumeral { name: "alt-001-00".into(), description: None, index: 6 },Enumeral { name: "alt-002-00".into(), description: None, index: 7 },Enumeral { name: "alt-005-00".into(), description: None, index: 8 },Enumeral { name: "alt-010-00".into(), description: None, index: 9 },Enumeral { name: "alt-020-00".into(), description: None, index: 10 },Enumeral { name: "alt-050-00".into(), description: None, index: 11 },Enumeral { name: "alt-100-00".into(), description: None, index: 12 },Enumeral { name: "alt-200-00".into(), description: None, index: 13 },Enumeral { name: "outOfRange".into(), description: None, index: 14 },Enumeral { name: "unavailable".into(), description: None, index: 15 }], extensible: None })( 
          input
        )
    }
}


/* *
 * This DE represents the altitude value in a WGS84 coordinate system.
 * The specific WGS84 coordinate system is specified by the corresponding standards applying this DE.
 *
 * The value shall be set to: 
 * - `-100 000` if the altitude is equal to or less than -1 000 m,
 * - `n` (`n > -100 000` and `n < 800 000`) if the altitude is equal to or less than n  x 0,01 metre and greater than (n-1) x 0,01 metre,
 * - `800 000` if the altitude  greater than 7 999,99 m,
 * - `800 001` if the information is not available.
 *
 * @note: the range of this DE does not use the full binary encoding range, but all reasonable values are covered. In order to cover all possible altitude ranges a larger encoding would be necessary.
 * @unit: 0,01 metre
 * @category: GeoReference information
 * @revision: Description revised in V2.1.1 (definition of 800 000 has slightly changed) 
 */
#[derive(Debug, Clone, PartialEq, Default)]
pub struct AltitudeValue(pub i32);

impl AltitudeValue {
  pub fn is_negativeOutOfRange(&self) -> bool { self.0 as i128 == -100000 }
  pub fn is_postiveOutOfRange(&self) -> bool { self.0 as i128 == 800000 }
  pub fn is_unavailable(&self) -> bool { self.0 as i128 == 800001 }
}

impl Decode for AltitudeValue {
    fn decode<'a, D>(decoder: &D, input: &'a [u8]) -> IResult<&'a [u8], Self>
    where
        D: Decoder,
        Self: Sized,
    {
        decoder
            .decode_integer(AsnInteger { constraint: Some(Constraint { min_value: Some(-100000), max_value: Some(800001), extensible: false }), distinguished_values: Some(vec![DistinguishedValue { name: "negativeOutOfRange".into(), value: -100000 },DistinguishedValue { name: "postiveOutOfRange".into(), value: 800000 },DistinguishedValue { name: "unavailable".into(), value: 800001 }]) })(input)
            .map(|(remaining, res)| (remaining, Self(res)))
    }
}


/* * 
 * This DE indicates the angle confidence value which represents the estimated absolute accuracy of an angle value with a default confidence level of 95 %.
 * If required, the confidence level can be defined by the corresponding standards applying this DE.
 *
 * The value shall be set to: 
 * - `n` (`n > 0` and `n < 126`)  if the accuracy is equal to or less than n * 0,1 degrees and greater than (n-1) x * 0,1 degrees,
 * - `126` if the  accuracy is out of range, i.e. greater than 12,5 degrees,
 * - `127` if the accuracy information is not available.
 *
 * @unit: 0,1 degrees
 * @category: Basic information
 * @revision: Created in V2.1.1
*/
#[derive(Debug, Clone, PartialEq, Default)]
pub struct AngleConfidence(pub u8);

impl AngleConfidence {
  pub fn is_outOfRange(&self) -> bool { self.0 as i128 == 126 }
  pub fn is_unavailable(&self) -> bool { self.0 as i128 == 127 }
}

impl Decode for AngleConfidence {
    fn decode<'a, D>(decoder: &D, input: &'a [u8]) -> IResult<&'a [u8], Self>
    where
        D: Decoder,
        Self: Sized,
    {
        decoder
            .decode_integer(AsnInteger { constraint: Some(Constraint { min_value: Some(1), max_value: Some(127), extensible: false }), distinguished_values: Some(vec![DistinguishedValue { name: "outOfRange".into(), value: 126 },DistinguishedValue { name: "unavailable".into(), value: 127 }]) })(input)
            .map(|(remaining, res)| (remaining, Self(res)))
    }
}


/* * 
 * This DE indicates the angular speed confidence value which represents the estimated absolute accuracy of an angular speed value with a default confidence level of 95 %.
 * If required, the confidence level can be defined by the corresponding standards applying this DE.
 * For correlation computation, maximum interval levels can be assumed.
 *
 * The value shall be set to:
 * - 0 - `degSec-01`   - if the accuracy is equal to or less than 1 degree/second,
 * - 1 - `degSec-02`   - if the accuracy is equal to or less than 2 degrees/second and greater than 1 degree/second,
 * - 2 - `degSec-05`   - if the accuracy is equal to or less than 5 degrees/second and greater than 2 degrees/second,
 * - 3 - `degSec-10`   - if the accuracy is equal to or less than 10 degrees/second and greater than 5 degrees/second,
 * - 4 - `degSec-20`   - if the accuracy is equal to or less than 20 degrees/second and greater than 10 degrees/second,
 * - 5 - `degSec-50`   - if the accuracy is equal to or less than 50 degrees/second and greater than 20 degrees/second,
 * - 6 - `outOfRange`  - if the accuracy is out of range, i.e. greater than 50 degrees/second,
 * - 7 - `unavailable` - if the accuracy information is unavailable.
 * 
 * @category: Kinematic information
 * @revision: Created in V2.1.1
*/
#[derive(Debug, Clone, PartialEq, Default)]
pub enum AngularSpeedConfidence {
  #[default]
  degSec_01 = 0,
	degSec_02 = 1,
	degSec_05 = 2,
	degSec_10 = 3,
	degSec_20 = 4,
	degSec_50 = 5,
	outOfRange = 6,
	unavailable = 7,
}

impl TryFrom<i128> for AngularSpeedConfidence {
    type Error = DecodingError;

    fn try_from(v: i128) -> Result<Self, Self::Error> {
        match v {
            x if x == Self::degSec_01 as i128 => Ok(Self::degSec_01),
		  x if x == Self::degSec_02 as i128 => Ok(Self::degSec_02),
		  x if x == Self::degSec_05 as i128 => Ok(Self::degSec_05),
		  x if x == Self::degSec_10 as i128 => Ok(Self::degSec_10),
		  x if x == Self::degSec_20 as i128 => Ok(Self::degSec_20),
		  x if x == Self::degSec_50 as i128 => Ok(Self::degSec_50),
		  x if x == Self::outOfRange as i128 => Ok(Self::outOfRange),
		  x if x == Self::unavailable as i128 => Ok(Self::unavailable),
            _ => Err(
              DecodingError::new(
                &format!("Invalid enumerated index decoding AngularSpeedConfidence. Received index {}",v), DecodingErrorType::InvalidEnumeratedIndex
              )
            ),
        }
    }
}

impl Decode for AngularSpeedConfidence {
    fn decode<'a, D>(decoder: &D, input: &'a [u8]) -> IResult<&'a [u8], Self>
    where
        D: Decoder,
        Self: Sized,
    {
        decoder.decode_enumerated(AsnEnumerated { members: vec![Enumeral { name: "degSec-01".into(), description: None, index: 0 },Enumeral { name: "degSec-02".into(), description: None, index: 1 },Enumeral { name: "degSec-05".into(), description: None, index: 2 },Enumeral { name: "degSec-10".into(), description: None, index: 3 },Enumeral { name: "degSec-20".into(), description: None, index: 4 },Enumeral { name: "degSec-50".into(), description: None, index: 5 },Enumeral { name: "outOfRange".into(), description: None, index: 6 },Enumeral { name: "unavailable".into(), description: None, index: 7 }], extensible: None })( 
          input
        )
    }
}


/* * 
 * This DE indicates the angular acceleration confidence value which represents the estimated accuracy of an angular acceleration value with a default confidence level of 95 %.
 * If required, the confidence level can be defined by the corresponding standards applying this DE.
 * For correlation computation, maximum interval levels shall be assumed.
 *
 * The value shall be set to:
 * - 0 - `degSecSquared-01` - if the accuracy is equal to or less than 1 degree/second^2,
 * - 1 - `degSecSquared-02` - if the accuracy is equal to or less than 2 degrees/second^2 and greater than 1 degree/second^2,
 * - 2 - `degSecSquared-05` - if the accuracy is equal to or less than 5 degrees/second^2 and greater than 1 degree/second^2,
 * - 3 - `degSecSquared-10` - if the accuracy is equal to or less than 10 degrees/second^2 and greater than 5 degrees/second^2,
 * - 4 - `degSecSquared-20` - if the accuracy is equal to or less than 20 degrees/second^2 and greater than 10 degrees/second^2,
 * - 5 - `degSecSquared-50` - if the accuracy is equal to or less than 50 degrees/second^2 and greater than 20 degrees/second^2,
 * - 6 - `outOfRange`       - if the accuracy is out of range, i.e. greater than 50 degrees/second^2,
 * - 7 - `unavailable`      - if the accuracy information is unavailable.
 *
 * @category: Kinematic information
 * @revision: Created in V2.1.1
*/
#[derive(Debug, Clone, PartialEq, Default)]
pub enum AngularAccelerationConfidence {
  #[default]
  degSecSquared_01 = 0,
	degSecSquared_02 = 1,
	degSecSquared_05 = 2,
	degSecSquared_10 = 3,
	degSecSquared_20 = 4,
	degSecSquared_50 = 5,
	outOfRange = 6,
	unavailable = 7,
}

impl TryFrom<i128> for AngularAccelerationConfidence {
    type Error = DecodingError;

    fn try_from(v: i128) -> Result<Self, Self::Error> {
        match v {
            x if x == Self::degSecSquared_01 as i128 => Ok(Self::degSecSquared_01),
		  x if x == Self::degSecSquared_02 as i128 => Ok(Self::degSecSquared_02),
		  x if x == Self::degSecSquared_05 as i128 => Ok(Self::degSecSquared_05),
		  x if x == Self::degSecSquared_10 as i128 => Ok(Self::degSecSquared_10),
		  x if x == Self::degSecSquared_20 as i128 => Ok(Self::degSecSquared_20),
		  x if x == Self::degSecSquared_50 as i128 => Ok(Self::degSecSquared_50),
		  x if x == Self::outOfRange as i128 => Ok(Self::outOfRange),
		  x if x == Self::unavailable as i128 => Ok(Self::unavailable),
            _ => Err(
              DecodingError::new(
                &format!("Invalid enumerated index decoding AngularAccelerationConfidence. Received index {}",v), DecodingErrorType::InvalidEnumeratedIndex
              )
            ),
        }
    }
}

impl Decode for AngularAccelerationConfidence {
    fn decode<'a, D>(decoder: &D, input: &'a [u8]) -> IResult<&'a [u8], Self>
    where
        D: Decoder,
        Self: Sized,
    {
        decoder.decode_enumerated(AsnEnumerated { members: vec![Enumeral { name: "degSecSquared-01".into(), description: None, index: 0 },Enumeral { name: "degSecSquared-02".into(), description: None, index: 1 },Enumeral { name: "degSecSquared-05".into(), description: None, index: 2 },Enumeral { name: "degSecSquared-10".into(), description: None, index: 3 },Enumeral { name: "degSecSquared-20".into(), description: None, index: 4 },Enumeral { name: "degSecSquared-50".into(), description: None, index: 5 },Enumeral { name: "outOfRange".into(), description: None, index: 6 },Enumeral { name: "unavailable".into(), description: None, index: 7 }], extensible: None })( 
          input
        )
    }
}


/* *
 * This DE indicates the number of axles of a passing train.
 *
 * The value shall be set to:
 * - `n` (`n > 2` and `n < 1001`) indicates that the train has n x axles,
 * - `1001`indicates that the number of axles is out of range,
 * - `1002` the information is unavailable.
 *
 * 
 * @unit: Number of axles
 * @category: Vehicle information
 * @revision: Created in V2.1.1
*/
#[derive(Debug, Clone, PartialEq, Default)]
pub struct AxlesCount(pub u16);

impl AxlesCount {
  pub fn is_outOfRange(&self) -> bool { self.0 as i128 == 1001 }
  pub fn is_unavailable(&self) -> bool { self.0 as i128 == 1002 }
}

impl Decode for AxlesCount {
    fn decode<'a, D>(decoder: &D, input: &'a [u8]) -> IResult<&'a [u8], Self>
    where
        D: Decoder,
        Self: Sized,
    {
        decoder
            .decode_integer(AsnInteger { constraint: Some(Constraint { min_value: Some(2), max_value: Some(1002), extensible: false }), distinguished_values: Some(vec![DistinguishedValue { name: "outOfRange".into(), value: 1001 },DistinguishedValue { name: "unavailable".into(), value: 1002 }]) })(input)
            .map(|(remaining, res)| (remaining, Self(res)))
    }
}


/* *
 * This DE represents the measured uncompensated atmospheric pressure.
 * 
 * The value shall be set to:
 * - `2999` indicates that the applicable value is less than 29990 Pa,
 * - `n` (`n > 2999` and `n <= 12000`) indicates that the applicable value is equal to or less than n x 10 Pa and greater than (n-1) x 10 Pa, 
 * - `12001` indicates that the values is greater than 120000 Pa,
 * - `12002` indicates that the information is not available.
 *
 * @category: Basic information
 * @unit: 10 Pascal
 * @revision: Created in V2.1.1
*/
#[derive(Debug, Clone, PartialEq, Default)]
pub struct BarometricPressure(pub u16);

impl BarometricPressure {
  pub fn is_outOfRangelower(&self) -> bool { self.0 as i128 == 2999 }
  pub fn is_outOfRangeUpper(&self) -> bool { self.0 as i128 == 12001 }
  pub fn is_unavailable(&self) -> bool { self.0 as i128 == 12002 }
}

impl Decode for BarometricPressure {
    fn decode<'a, D>(decoder: &D, input: &'a [u8]) -> IResult<&'a [u8], Self>
    where
        D: Decoder,
        Self: Sized,
    {
        decoder
            .decode_integer(AsnInteger { constraint: Some(Constraint { min_value: Some(2999), max_value: Some(12002), extensible: false }), distinguished_values: Some(vec![DistinguishedValue { name: "outOfRangelower".into(), value: 2999 },DistinguishedValue { name: "outOfRangeUpper".into(), value: 12001 },DistinguishedValue { name: "unavailable".into(), value: 12002 }]) })(input)
            .map(|(remaining, res)| (remaining, Self(res)))
    }
}


/* *
 * This DE indicates the cardinal number of bogies of a train.
 *
 * The value shall be set to: 
 * - `n` (`n > 1` and `n < 100`) indicates that the train has n x bogies,
 * - `100`indicates that the number of bogies is out of range, 
 * - `101` the information is unavailable.
 *
 * @unit: Number of bogies
 * @category: Vehicle information
 * @revision: Created in V2.1.1
*/
#[derive(Debug, Clone, PartialEq, Default)]
pub struct BogiesCount(pub u8);

impl BogiesCount {
  pub fn is_outOfRange(&self) -> bool { self.0 as i128 == 100 }
  pub fn is_unavailable(&self) -> bool { self.0 as i128 == 101 }
}

impl Decode for BogiesCount {
    fn decode<'a, D>(decoder: &D, input: &'a [u8]) -> IResult<&'a [u8], Self>
    where
        D: Decoder,
        Self: Sized,
    {
        decoder
            .decode_integer(AsnInteger { constraint: Some(Constraint { min_value: Some(2), max_value: Some(101), extensible: false }), distinguished_values: Some(vec![DistinguishedValue { name: "outOfRange".into(), value: 100 },DistinguishedValue { name: "unavailable".into(), value: 101 }]) })(input)
            .map(|(remaining, res)| (remaining, Self(res)))
    }
}


/* *
 * The DE represents a cardinal number that counts the size of a set. 
 * 
 * @category: Basic information
 * @revision: Created in V2.1.1
*/
#[derive(Debug, Clone, PartialEq, Default)]
pub struct CardinalNumber1B(pub u8);

impl Decode for CardinalNumber1B {
    fn decode<'a, D>(decoder: &D, input: &'a [u8]) -> IResult<&'a [u8], Self>
    where
        D: Decoder,
        Self: Sized,
    {
        decoder
            .decode_integer(AsnInteger { constraint: Some(Constraint { min_value: Some(0), max_value: Some(255), extensible: false }), distinguished_values: None })(input)
            .map(|(remaining, res)| (remaining, Self(res)))
    }
}


/* *
 * The DE represents a cardinal number that counts the size of a set. 
 * 
 * @category: Basic information
 * @revision: Created in V2.1.1
*/
#[derive(Debug, Clone, PartialEq, Default)]
pub struct CardinalNumber3b(pub u8);

impl Decode for CardinalNumber3b {
    fn decode<'a, D>(decoder: &D, input: &'a [u8]) -> IResult<&'a [u8], Self>
    where
        D: Decoder,
        Self: Sized,
    {
        decoder
            .decode_integer(AsnInteger { constraint: Some(Constraint { min_value: Some(1), max_value: Some(8), extensible: false }), distinguished_values: None })(input)
            .map(|(remaining, res)| (remaining, Self(res)))
    }
}


/* * 
 * This DE represents an angle value described in a local Cartesian coordinate system, per default counted positive in
 * a right-hand local coordinate system from the abscissa.
 *
 * The value shall be set to: 
 * - `n` (`n >= 0` and `n < 3600`) if the angle is equal to or less than n x 0,1 degrees, and greater than (n-1) x 0,1 degrees,
 * - `36001` if the accuracy information is not available.
 *
 * The value 3600 shall not be used. 
 * 
 * @unit 0,1 degrees
 * @category: Basic information
 * @revision: Created in V2.1.1
*/
#[derive(Debug, Clone, PartialEq, Default)]
pub struct CartesianAngleValue(pub u16);

impl CartesianAngleValue {
  pub fn is_valueNotUsed(&self) -> bool { self.0 as i128 == 3600 }
  pub fn is_unavailable(&self) -> bool { self.0 as i128 == 3601 }
}

impl Decode for CartesianAngleValue {
    fn decode<'a, D>(decoder: &D, input: &'a [u8]) -> IResult<&'a [u8], Self>
    where
        D: Decoder,
        Self: Sized,
    {
        decoder
            .decode_integer(AsnInteger { constraint: Some(Constraint { min_value: Some(0), max_value: Some(3601), extensible: false }), distinguished_values: Some(vec![DistinguishedValue { name: "valueNotUsed".into(), value: 3600 },DistinguishedValue { name: "unavailable".into(), value: 3601 }]) })(input)
            .map(|(remaining, res)| (remaining, Self(res)))
    }
}


/* *
 * This DE represents an angular acceleration value described in a local Cartesian coordinate system, per default counted positive in
 * a right-hand local coordinate system from the abscissa.
 *
  * The value shall be set to: 
 * - `-255` if the acceleration is equal to or less than -255 degrees/s^2,
 * - `n` (`n > -255` and `n < 255`) if the acceleration is equal to or less than n x 1 degree/s^2,
      and greater than `(n-1)` x 0,01 degree/s^2,
 * - `255` if the acceleration is greater than 254 degrees/s^2,
 * - `256` if the information is unavailable.
 *
 * @unit:  degree/s^2 (degrees per second squared)
 * @category: Kinematic information
 * @revision: Created in V2.1.1
*/
#[derive(Debug, Clone, PartialEq, Default)]
pub struct CartesianAngularAccelerationComponentValue(pub i16);

impl CartesianAngularAccelerationComponentValue {
  pub fn is_negativeOutOfRange(&self) -> bool { self.0 as i128 == -255 }
  pub fn is_positiveOutOfRange(&self) -> bool { self.0 as i128 == 255 }
  pub fn is_unavailable(&self) -> bool { self.0 as i128 == 256 }
}

impl Decode for CartesianAngularAccelerationComponentValue {
    fn decode<'a, D>(decoder: &D, input: &'a [u8]) -> IResult<&'a [u8], Self>
    where
        D: Decoder,
        Self: Sized,
    {
        decoder
            .decode_integer(AsnInteger { constraint: Some(Constraint { min_value: Some(-255), max_value: Some(256), extensible: false }), distinguished_values: Some(vec![DistinguishedValue { name: "negativeOutOfRange".into(), value: -255 },DistinguishedValue { name: "positiveOutOfRange".into(), value: 255 },DistinguishedValue { name: "unavailable".into(), value: 256 }]) })(input)
            .map(|(remaining, res)| (remaining, Self(res)))
    }
}


/* *
 * This DE represents an angular velocity component described in a local Cartesian coordinate system, per default counted positive in
 * a right-hand local coordinate system from the abscissa.
 *
 * The value shall be set to: 
 * - `-255` if the velocity is equal to or less than -255 degrees/s,
 * - `n` (`n > -255` and `n < 255`) if the velocity is equal to or less than n x 1 degree/s, and greater than (n-1) x 1 degree/s,
 * - `255` if the velocity is greater than 254 degrees/s,
 * - `256` if the information is unavailable.
 *
 * @unit: degree/s
 * @category: Kinematic information
 * @revision: Created in V2.1.1
*/
#[derive(Debug, Clone, PartialEq, Default)]
pub struct CartesianAngularVelocityComponentValue(pub i16);

impl CartesianAngularVelocityComponentValue {
  pub fn is_negativeOutofRange(&self) -> bool { self.0 as i128 == -255 }
  pub fn is_positiveOutOfRange(&self) -> bool { self.0 as i128 == 255 }
  pub fn is_unavailable(&self) -> bool { self.0 as i128 == 256 }
}

impl Decode for CartesianAngularVelocityComponentValue {
    fn decode<'a, D>(decoder: &D, input: &'a [u8]) -> IResult<&'a [u8], Self>
    where
        D: Decoder,
        Self: Sized,
    {
        decoder
            .decode_integer(AsnInteger { constraint: Some(Constraint { min_value: Some(-255), max_value: Some(256), extensible: false }), distinguished_values: Some(vec![DistinguishedValue { name: "negativeOutofRange".into(), value: -255 },DistinguishedValue { name: "positiveOutOfRange".into(), value: 255 },DistinguishedValue { name: "unavailable".into(), value: 256 }]) })(input)
            .map(|(remaining, res)| (remaining, Self(res)))
    }
}


/* *
 *The DE represents the value of the cause code of an event. 
 * 
 * The value shall be set to:
 * - 0                                                     - reserved for future use,
 * - 1  - `trafficCondition`                               - in case the type of event is an abnormal traffic condition,
 * - 2  - `accident`                                       - in case the type of event is a road accident,
 * - 3  - `roadworks`                                      - in case the type of event is roadwork,
 * - 4                                                     - reserved for future usage,
 * - 5  - `impassability`                                  - in case the  type of event is unmanaged road blocking, referring to any
 *                                                           blocking of a road, partial or total, which has not been adequately
 *                                                           secured and signposted,
 * - 6  - `adverseWeatherCondition-Adhesion`               - in case the  type of event is low adhesion,
 * - 7  - `aquaplaning`                                    - danger of aquaplaning on the road,
 * - 8                                                     - reserved for future usage,
 * - 9  - `hazardousLocation-SurfaceCondition`             - in case the type of event is abnormal road surface condition,
 * - 10 - `hazardousLocation-ObstacleOnTheRoad`            - in case the type of event is obstacle on the road,
 * - 11 - `hazardousLocation-AnimalOnTheRoad`              - in case the type of event is animal on the road,
 * - 12 - `humanPresenceOnTheRoad`                         - in case the type of event is human presence on the road,
 * - 13                                                    - reserved for future usage,
 * - 14 - `wrongWayDriving`                                - in case the type of the event is vehicle driving in wrong way,
 * - 15 - `rescueAndRecoveryWorkInProgress`                - in case the type of event is rescue and recovery work for accident or for a road hazard in progress,
 * - 16                                                    - reserved for future usage,
 * - 17 - `adverseWeatherCondition-ExtremeWeatherCondition`- in case the type of event is extreme weather condition,
 * - 18 - `adverseWeatherCondition-Visibility`             - in case the type of event is low visibility,
 * - 19 - `adverseWeatherCondition-Precipitation`          - in case the type of event is precipitation,
 * - 20 - `violence`                                       - in case the the type of event is human violence on or near the road,
 * - 21-25                                                 - reserved for future usage,
 * - 26 - `slowVehicle`                                    - in case the type of event is slow vehicle driving on the road,
 * - 27 - `dangerousEndOfQueue`                            - in case the type of event is dangerous end of vehicle queue,
 * - 28-90                                                 - are reserved for future usage,
 * - 91 - `vehicleBreakdown`                               - in case the type of event is break down vehicle on the road,
 * - 92 - `postCrash`                                      - in case the type of event is a detected crash,
 * - 93 - `humanProblem`                                   - in case the type of event is human health problem in vehicles involved in traffic,
 * - 94 - `stationaryVehicle`                              - in case the type of event is stationary vehicle,
 * - 95 - `emergencyVehicleApproaching`                    - in case the type of event is approaching vehicle operating emergency mission,
 * - 96 - `hazardousLocation-DangerousCurve`               - in case the type of event is dangerous curve,
 * - 97 - `collisionRisk`                                  - in case the type of event is a collision risk,
 * - 98 - `signalViolation`                                - in case the type of event is signal violation,
 * - 99 - `dangerousSituation`                             - in case the type of event is dangerous situation in which autonomous safety system in vehicle 
 *                                                             is activated,
 * - 100 - `railwayLevelCrossing`                          - in case the type of event is a railway level crossing. 
 * - 101-255                                               - are reserved for future usage.
 *
 * @category: Traffic information
 * @revision: V1.3.1
 */
#[derive(Debug, Clone, PartialEq, Default)]
pub struct CauseCodeType(pub u8);

impl CauseCodeType {
  pub fn is_trafficCondition(&self) -> bool { self.0 as i128 == 1 }
  pub fn is_accident(&self) -> bool { self.0 as i128 == 2 }
  pub fn is_roadworks(&self) -> bool { self.0 as i128 == 3 }
  pub fn is_impassability(&self) -> bool { self.0 as i128 == 5 }
  pub fn is_adverseWeatherCondition_Adhesion(&self) -> bool { self.0 as i128 == 6 }
  pub fn is_aquaplaning(&self) -> bool { self.0 as i128 == 7 }
  pub fn is_hazardousLocation_SurfaceCondition(&self) -> bool { self.0 as i128 == 9 }
  pub fn is_hazardousLocation_ObstacleOnTheRoad(&self) -> bool { self.0 as i128 == 10 }
  pub fn is_hazardousLocation_AnimalOnTheRoad(&self) -> bool { self.0 as i128 == 11 }
  pub fn is_humanPresenceOnTheRoad(&self) -> bool { self.0 as i128 == 12 }
  pub fn is_wrongWayDriving(&self) -> bool { self.0 as i128 == 14 }
  pub fn is_rescueAndRecoveryWorkInProgress(&self) -> bool { self.0 as i128 == 15 }
  pub fn is_adverseWeatherCondition_ExtremeWeatherCondition(&self) -> bool { self.0 as i128 == 17 }
  pub fn is_adverseWeatherCondition_Visibility(&self) -> bool { self.0 as i128 == 18 }
  pub fn is_adverseWeatherCondition_Precipitation(&self) -> bool { self.0 as i128 == 19 }
  pub fn is_violence(&self) -> bool { self.0 as i128 == 20 }
  pub fn is_slowVehicle(&self) -> bool { self.0 as i128 == 26 }
  pub fn is_dangerousEndOfQueue(&self) -> bool { self.0 as i128 == 27 }
  pub fn is_vehicleBreakdown(&self) -> bool { self.0 as i128 == 91 }
  pub fn is_postCrash(&self) -> bool { self.0 as i128 == 92 }
  pub fn is_humanProblem(&self) -> bool { self.0 as i128 == 93 }
  pub fn is_stationaryVehicle(&self) -> bool { self.0 as i128 == 94 }
  pub fn is_emergencyVehicleApproaching(&self) -> bool { self.0 as i128 == 95 }
  pub fn is_hazardousLocation_DangerousCurve(&self) -> bool { self.0 as i128 == 96 }
  pub fn is_collisionRisk(&self) -> bool { self.0 as i128 == 97 }
  pub fn is_signalViolation(&self) -> bool { self.0 as i128 == 98 }
  pub fn is_dangerousSituation(&self) -> bool { self.0 as i128 == 99 }
  pub fn is_railwayLevelCrossing(&self) -> bool { self.0 as i128 == 100 }
}

impl Decode for CauseCodeType {
    fn decode<'a, D>(decoder: &D, input: &'a [u8]) -> IResult<&'a [u8], Self>
    where
        D: Decoder,
        Self: Sized,
    {
        decoder
            .decode_integer(AsnInteger { constraint: Some(Constraint { min_value: Some(0), max_value: Some(255), extensible: false }), distinguished_values: Some(vec![DistinguishedValue { name: "trafficCondition".into(), value: 1 },DistinguishedValue { name: "accident".into(), value: 2 },DistinguishedValue { name: "roadworks".into(), value: 3 },DistinguishedValue { name: "impassability".into(), value: 5 },DistinguishedValue { name: "adverseWeatherCondition-Adhesion".into(), value: 6 },DistinguishedValue { name: "aquaplaning".into(), value: 7 },DistinguishedValue { name: "hazardousLocation-SurfaceCondition".into(), value: 9 },DistinguishedValue { name: "hazardousLocation-ObstacleOnTheRoad".into(), value: 10 },DistinguishedValue { name: "hazardousLocation-AnimalOnTheRoad".into(), value: 11 },DistinguishedValue { name: "humanPresenceOnTheRoad".into(), value: 12 },DistinguishedValue { name: "wrongWayDriving".into(), value: 14 },DistinguishedValue { name: "rescueAndRecoveryWorkInProgress".into(), value: 15 },DistinguishedValue { name: "adverseWeatherCondition-ExtremeWeatherCondition".into(), value: 17 },DistinguishedValue { name: "adverseWeatherCondition-Visibility".into(), value: 18 },DistinguishedValue { name: "adverseWeatherCondition-Precipitation".into(), value: 19 },DistinguishedValue { name: "violence".into(), value: 20 },DistinguishedValue { name: "slowVehicle".into(), value: 26 },DistinguishedValue { name: "dangerousEndOfQueue".into(), value: 27 },DistinguishedValue { name: "vehicleBreakdown".into(), value: 91 },DistinguishedValue { name: "postCrash".into(), value: 92 },DistinguishedValue { name: "humanProblem".into(), value: 93 },DistinguishedValue { name: "stationaryVehicle".into(), value: 94 },DistinguishedValue { name: "emergencyVehicleApproaching".into(), value: 95 },DistinguishedValue { name: "hazardousLocation-DangerousCurve".into(), value: 96 },DistinguishedValue { name: "collisionRisk".into(), value: 97 },DistinguishedValue { name: "signalViolation".into(), value: 98 },DistinguishedValue { name: "dangerousSituation".into(), value: 99 },DistinguishedValue { name: "railwayLevelCrossing".into(), value: 100 }]) })(input)
            .map(|(remaining, res)| (remaining, Self(res)))
    }
}


/* *
 * This DF represents the value of a cartesian coordinate with a range of -30,94 metres to +10,00 metres.
 *
 * The value shall be set to:
 * - `3094` if the longitudinal offset is out of range, i.e. less than or equal to -30,94 metres,
 * - `n` (`n > -3 094` and `n < 1 001`) if the longitudinal offset information is equal to or less than n x 0,01 metre and more than (n-1) x 0,01 metre,
 * - `1001` if the longitudinal offset is out of range, i.e. greater than 10 metres.
 *
 * @unit 0,01 m
 * @category: Basic information
 * @revision: Created in V2.1.1
*/
#[derive(Debug, Clone, PartialEq, Default)]
pub struct CartesianCoordinateSmall(pub i16);

impl CartesianCoordinateSmall {
  pub fn is_negativeOutOfRange(&self) -> bool { self.0 as i128 == -3094 }
  pub fn is_positiveOutOfRange(&self) -> bool { self.0 as i128 == 1001 }
}

impl Decode for CartesianCoordinateSmall {
    fn decode<'a, D>(decoder: &D, input: &'a [u8]) -> IResult<&'a [u8], Self>
    where
        D: Decoder,
        Self: Sized,
    {
        decoder
            .decode_integer(AsnInteger { constraint: Some(Constraint { min_value: Some(-3094), max_value: Some(1001), extensible: false }), distinguished_values: Some(vec![DistinguishedValue { name: "negativeOutOfRange".into(), value: -3094 },DistinguishedValue { name: "positiveOutOfRange".into(), value: 1001 }]) })(input)
            .map(|(remaining, res)| (remaining, Self(res)))
    }
}


/* *
 * This DF represents the value of a cartesian coordinate with a range of -327,68 metres to +327,66 metres.
 *
 * The value shall be set to:
 * - `-32 768` if the longitudinal offset is out of range, i.e. less than or equal to -327,68 metres,
 * - `n` (`n > -32 768` and `n < 32 767`) if the longitudinal offset information is equal to or less than n x 0,01 metre and more than (n-1) x 0,01 metre,
 * - `32 767` if the longitudinal offset is out of range, i.e. greater than + 327,66 metres.
 *
 * @unit 0,01 m
 * @category: Basic information
 * @revision: Created in V2.1.1
*/
#[derive(Debug, Clone, PartialEq, Default)]
pub struct CartesianCoordinate(pub i16);

impl CartesianCoordinate {
  pub fn is_negativeOutOfRange(&self) -> bool { self.0 as i128 == -32768 }
  pub fn is_positiveOutOfRange(&self) -> bool { self.0 as i128 == 32767 }
}

impl Decode for CartesianCoordinate {
    fn decode<'a, D>(decoder: &D, input: &'a [u8]) -> IResult<&'a [u8], Self>
    where
        D: Decoder,
        Self: Sized,
    {
        decoder
            .decode_integer(AsnInteger { constraint: Some(Constraint { min_value: Some(-32768), max_value: Some(32767), extensible: false }), distinguished_values: Some(vec![DistinguishedValue { name: "negativeOutOfRange".into(), value: -32768 },DistinguishedValue { name: "positiveOutOfRange".into(), value: 32767 }]) })(input)
            .map(|(remaining, res)| (remaining, Self(res)))
    }
}


/* *
 * This DF represents the value of a cartesian coordinate with a range of -1 310,72 metres to +1 310,70 metres.
 *
 * The value shall be set to:
 * - `-131072` if the longitudinal offset is out of range, i.e. less than or equal to -1 310,72 metres,
 * - `n` (`n > 131 072` and `n < 131 071`) if the longitudinal offset information is equal to or less than n x 0,01 metre and more than (n-1) x 0,01 metre,
 * - `131 071` if the longitudinal offset is out of range, i.e. greater than + 1 310,70 metres.
 *  
 * @unit 0,01 m
 * @category: Basic information
 * @revision: Created in V2.1.1
*/
#[derive(Debug, Clone, PartialEq, Default)]
pub struct CartesianCoordinateLarge(pub i32);

impl CartesianCoordinateLarge {
  pub fn is_negativeOutOfRange(&self) -> bool { self.0 as i128 == -131072 }
  pub fn is_positiveOutOfRange(&self) -> bool { self.0 as i128 == 131071 }
}

impl Decode for CartesianCoordinateLarge {
    fn decode<'a, D>(decoder: &D, input: &'a [u8]) -> IResult<&'a [u8], Self>
    where
        D: Decoder,
        Self: Sized,
    {
        decoder
            .decode_integer(AsnInteger { constraint: Some(Constraint { min_value: Some(-131072), max_value: Some(131071), extensible: false }), distinguished_values: Some(vec![DistinguishedValue { name: "negativeOutOfRange".into(), value: -131072 },DistinguishedValue { name: "positiveOutOfRange".into(), value: 131071 }]) })(input)
            .map(|(remaining, res)| (remaining, Self(res)))
    }
}



/* *
 * This DE indicates the reason why a cluster leader intends to break up the cluster.
 * 
 * The value shall be set to:
 * - 0 - `notProvided`                          - if the information is not provided,
 * - 1 - `clusteringPurposeCompleted`           - if the cluster purpose has been completed,
 * - 2 - `leaderMovedOutOfClusterBoundingBox`   - if the leader moved out of the cluster's bounding box,
 * - 3 - `joiningAnotherCluster`                - if the cluster leader is about to join another cluster,
 * - 4 - `enteringLowRiskAreaBasedOnMaps`       - if the cluster is entering an area idenrified as low risk based on the use of maps,
 * - 5 - `receptionOfCpmContainingCluster`      - if the leader received a Collective Perception Message containing information about the same cluster. 
 * - 6 to 15                                    - are reserved for future use.                                    
 *
 * @category: Cluster information
 * @revision: Created in V2.1.1
*/
#[derive(Debug, Clone, PartialEq, Default)]
pub enum ClusterBreakupReason {
  #[default]
  notProvided = 0,
	clusteringPurposeCompleted = 1,
	leaderMovedOutOfClusterBoundingBox = 2,
	joiningAnotherCluster = 3,
	enteringLowRiskAreaBasedOnMaps = 4,
	receptionOfCpmContainingCluster = 5,
	max = 15,
}

impl TryFrom<i128> for ClusterBreakupReason {
    type Error = DecodingError;

    fn try_from(v: i128) -> Result<Self, Self::Error> {
        match v {
            x if x == Self::notProvided as i128 => Ok(Self::notProvided),
		  x if x == Self::clusteringPurposeCompleted as i128 => Ok(Self::clusteringPurposeCompleted),
		  x if x == Self::leaderMovedOutOfClusterBoundingBox as i128 => Ok(Self::leaderMovedOutOfClusterBoundingBox),
		  x if x == Self::joiningAnotherCluster as i128 => Ok(Self::joiningAnotherCluster),
		  x if x == Self::enteringLowRiskAreaBasedOnMaps as i128 => Ok(Self::enteringLowRiskAreaBasedOnMaps),
		  x if x == Self::receptionOfCpmContainingCluster as i128 => Ok(Self::receptionOfCpmContainingCluster),
		  x if x == Self::max as i128 => Ok(Self::max),
            _ => Err(
              DecodingError::new(
                &format!("Invalid enumerated index decoding ClusterBreakupReason. Received index {}",v), DecodingErrorType::InvalidEnumeratedIndex
              )
            ),
        }
    }
}

impl Decode for ClusterBreakupReason {
    fn decode<'a, D>(decoder: &D, input: &'a [u8]) -> IResult<&'a [u8], Self>
    where
        D: Decoder,
        Self: Sized,
    {
        decoder.decode_enumerated(AsnEnumerated { members: vec![Enumeral { name: "notProvided".into(), description: None, index: 0 },Enumeral { name: "clusteringPurposeCompleted".into(), description: None, index: 1 },Enumeral { name: "leaderMovedOutOfClusterBoundingBox".into(), description: None, index: 2 },Enumeral { name: "joiningAnotherCluster".into(), description: None, index: 3 },Enumeral { name: "enteringLowRiskAreaBasedOnMaps".into(), description: None, index: 4 },Enumeral { name: "receptionOfCpmContainingCluster".into(), description: None, index: 5 },Enumeral { name: "max".into(), description: None, index: 15 }], extensible: None })( 
          input
        )
    }
}


/* *
 * This DE indicates the reason why a cluster participant is leaving the cluster.
 * 
 * The value shall be set to:
 * - 0 - `notProvided `                 - if the information is not provided,
 * - 1 - `clusterLeaderLost`            - if the cluster leader cannot be found anymore,   
 * - 2 - `clusterDisbandedByLeader`     - if the cluster has been disbanded by the leader,
 * - 3 - `outOfClusterBoundingBox`      - if the participants moved out of the cluster's bounding box,
 * - 4 - `outOfClusterSpeedRange`       - if the cluster speed moved out of a defined range, 
 * - 5 - `joiningAnotherCluster`        - if the participant is joining another cluster,
 * - 6 - `cancelledJoin`                - if the participant is cancelling a joining procedure,
 * - 7 - `failedJoin`                   - if the participant failed to join the cluster,
 * - 8 - `safetyCondition`              - if a safety condition applies.
 * - 9 to 15                            - are reserved for future use                             
 *
 * @category: Cluster information
 * @revision: Created in V2.1.1
 */
#[derive(Debug, Clone, PartialEq, Default)]
pub enum ClusterLeaveReason {
  #[default]
  notProvided = 0,
	clusterLeaderLost = 1,
	clusterDisbandedByLeader = 2,
	outOfClusterBoundingBox = 3,
	outOfClusterSpeedRange = 4,
	joiningAnotherCluster = 5,
	cancelledJoin = 6,
	failedJoin = 7,
	safetyCondition = 8,
	max = 15,
}

impl TryFrom<i128> for ClusterLeaveReason {
    type Error = DecodingError;

    fn try_from(v: i128) -> Result<Self, Self::Error> {
        match v {
            x if x == Self::notProvided as i128 => Ok(Self::notProvided),
		  x if x == Self::clusterLeaderLost as i128 => Ok(Self::clusterLeaderLost),
		  x if x == Self::clusterDisbandedByLeader as i128 => Ok(Self::clusterDisbandedByLeader),
		  x if x == Self::outOfClusterBoundingBox as i128 => Ok(Self::outOfClusterBoundingBox),
		  x if x == Self::outOfClusterSpeedRange as i128 => Ok(Self::outOfClusterSpeedRange),
		  x if x == Self::joiningAnotherCluster as i128 => Ok(Self::joiningAnotherCluster),
		  x if x == Self::cancelledJoin as i128 => Ok(Self::cancelledJoin),
		  x if x == Self::failedJoin as i128 => Ok(Self::failedJoin),
		  x if x == Self::safetyCondition as i128 => Ok(Self::safetyCondition),
		  x if x == Self::max as i128 => Ok(Self::max),
            _ => Err(
              DecodingError::new(
                &format!("Invalid enumerated index decoding ClusterLeaveReason. Received index {}",v), DecodingErrorType::InvalidEnumeratedIndex
              )
            ),
        }
    }
}

impl Decode for ClusterLeaveReason {
    fn decode<'a, D>(decoder: &D, input: &'a [u8]) -> IResult<&'a [u8], Self>
    where
        D: Decoder,
        Self: Sized,
    {
        decoder.decode_enumerated(AsnEnumerated { members: vec![Enumeral { name: "notProvided".into(), description: None, index: 0 },Enumeral { name: "clusterLeaderLost".into(), description: None, index: 1 },Enumeral { name: "clusterDisbandedByLeader".into(), description: None, index: 2 },Enumeral { name: "outOfClusterBoundingBox".into(), description: None, index: 3 },Enumeral { name: "outOfClusterSpeedRange".into(), description: None, index: 4 },Enumeral { name: "joiningAnotherCluster".into(), description: None, index: 5 },Enumeral { name: "cancelledJoin".into(), description: None, index: 6 },Enumeral { name: "failedJoin".into(), description: None, index: 7 },Enumeral { name: "safetyCondition".into(), description: None, index: 8 },Enumeral { name: "max".into(), description: None, index: 15 }], extensible: None })( 
          input
        )
    }
}


/* *
 * This DE represents the sub cause codes of the @ref CauseCode `collisionRisk`.
 * 
 * The value shall be set to:
 * - 0 - `unavailable`              - in case information on the type of collision risk is unavailable,
 * - 1 - `longitudinalCollisionRisk`- in case the type of detected collision risk is longitudinal collision risk, 
 *                                       e.g. forward collision or face to face collision,
 * - 2 - `crossingCollisionRisk`    - in case the type of detected collision risk is crossing collision risk,
 * - 3 - `lateralCollisionRisk`     - in case the type of detected collision risk is lateral collision risk,
 * - 4 - `vulnerableRoadUser`       - in case the type of detected collision risk involves vulnerable road users
 *                                       e.g. pedestrians or bicycles.
 * - 5-255                          - are reserved for future usage.
 *
 * @category: Traffic information
 * @revision: V1.3.1
 */
#[derive(Debug, Clone, PartialEq, Default)]
pub struct CollisionRiskSubCauseCode(pub u8);

impl CollisionRiskSubCauseCode {
  pub fn is_unavailable(&self) -> bool { self.0 as i128 == 0 }
  pub fn is_longitudinalCollisionRisk(&self) -> bool { self.0 as i128 == 1 }
  pub fn is_crossingCollisionRisk(&self) -> bool { self.0 as i128 == 2 }
  pub fn is_lateralCollisionRisk(&self) -> bool { self.0 as i128 == 3 }
  pub fn is_vulnerableRoadUser(&self) -> bool { self.0 as i128 == 4 }
}

impl Decode for CollisionRiskSubCauseCode {
    fn decode<'a, D>(decoder: &D, input: &'a [u8]) -> IResult<&'a [u8], Self>
    where
        D: Decoder,
        Self: Sized,
    {
        decoder
            .decode_integer(AsnInteger { constraint: Some(Constraint { min_value: Some(0), max_value: Some(255), extensible: false }), distinguished_values: Some(vec![DistinguishedValue { name: "unavailable".into(), value: 0 },DistinguishedValue { name: "longitudinalCollisionRisk".into(), value: 1 },DistinguishedValue { name: "crossingCollisionRisk".into(), value: 2 },DistinguishedValue { name: "lateralCollisionRisk".into(), value: 3 },DistinguishedValue { name: "vulnerableRoadUser".into(), value: 4 }]) })(input)
            .map(|(remaining, res)| (remaining, Self(res)))
    }
}


/* * 
 * This DE represents a confidence level in percentage.
 * 
 * The value shall be set to:
 * - `n` (`n > 0` and `n < 101`) : for the confidence level in %,
 * - `101`                   : in case the confidence level is not available.
 *
 * @unit Percent 
 * @category: Basic information 
 * @revision: Created in V2.1.1 
*/
#[derive(Debug, Clone, PartialEq, Default)]
pub struct ConfidenceLevel(pub u8);

impl ConfidenceLevel {
  pub fn is_unavailable(&self) -> bool { self.0 as i128 == 101 }
}

impl Decode for ConfidenceLevel {
    fn decode<'a, D>(decoder: &D, input: &'a [u8]) -> IResult<&'a [u8], Self>
    where
        D: Decoder,
        Self: Sized,
    {
        decoder
            .decode_integer(AsnInteger { constraint: Some(Constraint { min_value: Some(1), max_value: Some(101), extensible: false }), distinguished_values: Some(vec![DistinguishedValue { name: "unavailable".into(), value: 101 }]) })(input)
            .map(|(remaining, res)| (remaining, Self(res)))
    }
}


/* * 
 * This DE indicates the coordinate confidence value which represents the estimated absolute accuracy of a position coordinate with a default confidence level of 95 %.
 * If required, the confidence level can be defined by the corresponding standards applying this DE.
 *
 * The value shall be set to: 
 * - `n` (`n > 0` and `n < 4095`) if the confidence value is is equal to or less than n x 0,01 metre, and greater than (n-1) x 0,01 metre,
 * - `4095` if the confidence value is greater than 40,94 metres,
 * - `4096` if the confidence value is not available.
 *
 * @unit 0,01 m
 * @category: Basic information
 * @revision: Created in V2.1.1
*/
#[derive(Debug, Clone, PartialEq, Default)]
pub struct CoordinateConfidence(pub u16);

impl CoordinateConfidence {
  pub fn is_outOfRange(&self) -> bool { self.0 as i128 == 4095 }
  pub fn is_unavailable(&self) -> bool { self.0 as i128 == 4096 }
}

impl Decode for CoordinateConfidence {
    fn decode<'a, D>(decoder: &D, input: &'a [u8]) -> IResult<&'a [u8], Self>
    where
        D: Decoder,
        Self: Sized,
    {
        decoder
            .decode_integer(AsnInteger { constraint: Some(Constraint { min_value: Some(1), max_value: Some(4096), extensible: false }), distinguished_values: Some(vec![DistinguishedValue { name: "outOfRange".into(), value: 4095 },DistinguishedValue { name: "unavailable".into(), value: 4096 }]) })(input)
            .map(|(remaining, res)| (remaining, Self(res)))
    }
}


/* * 
 * This DE represents the Bravais-Pearson correlation value for each cell of a lower triangular correlation matrix.
 *
 * The value shall be set to: 
 * - `-100` in case of full negative correlation,
 * - `n` (`n > -100` and `n < 0`) if the correlation is negative and equal to n x 100,
 * - `0` in case of no correlation,
 * - `n` (`n > 0` and `n < 100`) if the correlation is positive and equal to n x 100,
 * - `100` in case of full positive correlation,
 * - `101` in case the correlation information is unavailable. 
 *
 * @unit: the value is scaled by 100
 * @category: Basic information
 * @revision: Created in V2.1.1
*/
#[derive(Debug, Clone, PartialEq, Default)]
pub struct CorrelationCellValue(pub i8);

impl CorrelationCellValue {
  pub fn is_full_negative_correlation(&self) -> bool { self.0 as i128 == -100 }
  pub fn is_no_correlation(&self) -> bool { self.0 as i128 == 0 }
  pub fn is_full_positive_correlation(&self) -> bool { self.0 as i128 == 100 }
  pub fn is_unavailable(&self) -> bool { self.0 as i128 == 101 }
}

impl Decode for CorrelationCellValue {
    fn decode<'a, D>(decoder: &D, input: &'a [u8]) -> IResult<&'a [u8], Self>
    where
        D: Decoder,
        Self: Sized,
    {
        decoder
            .decode_integer(AsnInteger { constraint: Some(Constraint { min_value: Some(-100), max_value: Some(101), extensible: false }), distinguished_values: Some(vec![DistinguishedValue { name: "full-negative-correlation".into(), value: -100 },DistinguishedValue { name: "no-correlation".into(), value: 0 },DistinguishedValue { name: "full-positive-correlation".into(), value: 100 },DistinguishedValue { name: "unavailable".into(), value: 101 }]) })(input)
            .map(|(remaining, res)| (remaining, Self(res)))
    }
}


/* *
 * The DE describes whether the yaw rate is used to calculate the curvature for a curvature value.
 * 
 * The value shall be set to:
 * - 0 - `yawRateUsed`    - if the yaw rate is used,
 * - 1 - `yawRateNotUsed` - if the yaw rate is not used,
 * - 2 - `unavailable`    - if the information of curvature calculation mode is unknown.
 *
 * @category: Vehicle information
 * @revision: V1.3.1
 */
#[derive(Debug, Clone, PartialEq, Default)]
pub enum CurvatureCalculationMode {
  #[default]
  yawRateUsed = 0,
	yawRateNotUsed = 1,
	unavailable = 2,
}

impl TryFrom<i128> for CurvatureCalculationMode {
    type Error = DecodingError;

    fn try_from(v: i128) -> Result<Self, Self::Error> {
        match v {
            x if x == Self::yawRateUsed as i128 => Ok(Self::yawRateUsed),
		  x if x == Self::yawRateNotUsed as i128 => Ok(Self::yawRateNotUsed),
		  x if x == Self::unavailable as i128 => Ok(Self::unavailable),
            _ => Err(
              DecodingError::new(
                &format!("Invalid enumerated index decoding CurvatureCalculationMode. Received index {}",v), DecodingErrorType::InvalidEnumeratedIndex
              )
            ),
        }
    }
}

impl Decode for CurvatureCalculationMode {
    fn decode<'a, D>(decoder: &D, input: &'a [u8]) -> IResult<&'a [u8], Self>
    where
        D: Decoder,
        Self: Sized,
    {
        decoder.decode_enumerated(AsnEnumerated { members: vec![Enumeral { name: "yawRateUsed".into(), description: None, index: 0 },Enumeral { name: "yawRateNotUsed".into(), description: None, index: 1 },Enumeral { name: "unavailable".into(), description: None, index: 2 }], extensible: Some(3) })( 
          input
        )
    }
}


/* *
 * This DE indicates the acceleration confidence value which represents the estimated absolute accuracy range of a curvature value with a confidence level of 95 %.
 * If required, the confidence level can be defined by the corresponding standards applying this DE.
 * 
 * The value shall be set to:
 * - 0 - `onePerMeter-0-00002` - if the confidence value is less than or equal to 0,00002 m-1,
 * - 1 - `onePerMeter-0-0001`  - if the confidence value is less than or equal to 0,0001 m-1 and greater than 0,00002 m-1,
 * - 2 - `onePerMeter-0-0005`  - if the confidence value is less than or equal to 0,0005 m-1 and greater than 0,0001 m-1,
 * - 3 - `onePerMeter-0-002`   - if the confidence value is less than or equal to 0,002 m-1 and greater than 0,0005 m-1,
 * - 4 - `nePerMeter-0-01`     - if the confidence value is less than or equal to 0,01 m-1 and greater than 0,002 m-1,
 * - 5 - `nePerMeter-0-1`      - if the confidence value is less than or equal to 0,1 m-1  and greater than 0,01 m-1,
 * - 6 - `outOfRange`          - if the confidence value is out of range, i.e. greater than 0,1 m-1,
 * - 7 - `unavailable`         - if the confidence value is not available.
 * 
 * @note:	The fact that a curvature value is received with confidence value set to `unavailable(7)` can be caused by
 * several reasons, such as:
 * - the sensor cannot deliver the accuracy at the defined confidence level because it is a low-end sensor,
 * - the sensor cannot calculate the accuracy due to lack of variables, or
 * - there has been a vehicle bus (e.g. CAN bus) error.
 * In all 3 cases above, the curvature value may be valid and used by the application.
 * 
 * @note: If a curvature value is received and its confidence value is set to `outOfRange(6)`, it means that the curvature value is not valid 
 * and therefore cannot be trusted. Such value is not useful for the application.
 * 
 * @category: Vehicle information
 * @revision: Description revised in V2.1.1
*/
#[derive(Debug, Clone, PartialEq, Default)]
pub enum CurvatureConfidence {
  #[default]
  onePerMeter_0_00002 = 0,
	onePerMeter_0_0001 = 1,
	onePerMeter_0_0005 = 2,
	onePerMeter_0_002 = 3,
	onePerMeter_0_01 = 4,
	onePerMeter_0_1 = 5,
	outOfRange = 6,
	unavailable = 7,
}

impl TryFrom<i128> for CurvatureConfidence {
    type Error = DecodingError;

    fn try_from(v: i128) -> Result<Self, Self::Error> {
        match v {
            x if x == Self::onePerMeter_0_00002 as i128 => Ok(Self::onePerMeter_0_00002),
		  x if x == Self::onePerMeter_0_0001 as i128 => Ok(Self::onePerMeter_0_0001),
		  x if x == Self::onePerMeter_0_0005 as i128 => Ok(Self::onePerMeter_0_0005),
		  x if x == Self::onePerMeter_0_002 as i128 => Ok(Self::onePerMeter_0_002),
		  x if x == Self::onePerMeter_0_01 as i128 => Ok(Self::onePerMeter_0_01),
		  x if x == Self::onePerMeter_0_1 as i128 => Ok(Self::onePerMeter_0_1),
		  x if x == Self::outOfRange as i128 => Ok(Self::outOfRange),
		  x if x == Self::unavailable as i128 => Ok(Self::unavailable),
            _ => Err(
              DecodingError::new(
                &format!("Invalid enumerated index decoding CurvatureConfidence. Received index {}",v), DecodingErrorType::InvalidEnumeratedIndex
              )
            ),
        }
    }
}

impl Decode for CurvatureConfidence {
    fn decode<'a, D>(decoder: &D, input: &'a [u8]) -> IResult<&'a [u8], Self>
    where
        D: Decoder,
        Self: Sized,
    {
        decoder.decode_enumerated(AsnEnumerated { members: vec![Enumeral { name: "onePerMeter-0-00002".into(), description: None, index: 0 },Enumeral { name: "onePerMeter-0-0001".into(), description: None, index: 1 },Enumeral { name: "onePerMeter-0-0005".into(), description: None, index: 2 },Enumeral { name: "onePerMeter-0-002".into(), description: None, index: 3 },Enumeral { name: "onePerMeter-0-01".into(), description: None, index: 4 },Enumeral { name: "onePerMeter-0-1".into(), description: None, index: 5 },Enumeral { name: "outOfRange".into(), description: None, index: 6 },Enumeral { name: "unavailable".into(), description: None, index: 7 }], extensible: None })( 
          input
        )
    }
}


/* *
 * This DE describes vehicle turning curve with the following information:
 * ```
 *     Value = 1 / Radius * 10000
 * ```
 * wherein radius is the vehicle turning curve radius in metres. 
 * 
 * Positive values indicate a turning curve to the left hand side of the driver.
 * It corresponds to the vehicle coordinate system as defined in ISO 8855 [21].
 *
 * The value shall be set to:
 * - `-1023` for  values smaller than -1023,
 * - `n` (`n > -1023` and `n < 0`) for negative values equal to or less than `n`, and greater than `(n-1)`,
 * - `0` when the vehicle is moving straight,
 * - `n` (`n > 0` and `n < 1022`) for positive values equal to or less than `n`, and greater than `(n-1)`,
 * - `1022`, for values  greater than 1021,
 * - `1023`, if the information is not available.
 * 
 * @note: The present DE is limited to vehicle types as defined in ISO 8855 [21].
 * 
 * @unit: 1 over 10 000 metres
 * @category: Vehicle information
 * @revision: description revised in V2.1.1 (the definition of value 1022 has changed slightly)
 */
#[derive(Debug, Clone, PartialEq, Default)]
pub struct CurvatureValue(pub i16);

impl CurvatureValue {
  pub fn is_outOfRangeNegative(&self) -> bool { self.0 as i128 == -1023 }
  pub fn is_straight(&self) -> bool { self.0 as i128 == 0 }
  pub fn is_outOfRangePositive(&self) -> bool { self.0 as i128 == 1022 }
  pub fn is_unavailable(&self) -> bool { self.0 as i128 == 1023 }
}

impl Decode for CurvatureValue {
    fn decode<'a, D>(decoder: &D, input: &'a [u8]) -> IResult<&'a [u8], Self>
    where
        D: Decoder,
        Self: Sized,
    {
        decoder
            .decode_integer(AsnInteger { constraint: Some(Constraint { min_value: Some(-1023), max_value: Some(1023), extensible: false }), distinguished_values: Some(vec![DistinguishedValue { name: "outOfRangeNegative".into(), value: -1023 },DistinguishedValue { name: "straight".into(), value: 0 },DistinguishedValue { name: "outOfRangePositive".into(), value: 1022 },DistinguishedValue { name: "unavailable".into(), value: 1023 }]) })(input)
            .map(|(remaining, res)| (remaining, Self(res)))
    }
}


/* *
 * This DE represents the value of the sub cause codes of the @ref CauseCode `dangerousEndOfQueue`. 
 * 
 * The value shall be set to:
 * - 0 - `unavailable`     - in case information on the type of dangerous queue is unavailable,
 * - 1 - `suddenEndOfQueue`- in case a sudden end of queue is detected, e.g. due to accident or obstacle,
 * - 2 - `queueOverHill`   - in case the dangerous end of queue is detected on the road hill,
 * - 3 - `queueAroundBend` - in case the dangerous end of queue is detected around the road bend,
 * - 4 - `queueInTunnel`   - in case queue is detected in tunnel,
 * - 5-255                 - reserved for future usage.
 *
 * @category: Traffic information
 * @revision: V1.3.1
 */
#[derive(Debug, Clone, PartialEq, Default)]
pub struct DangerousEndOfQueueSubCauseCode(pub u8);

impl DangerousEndOfQueueSubCauseCode {
  pub fn is_unavailable(&self) -> bool { self.0 as i128 == 0 }
  pub fn is_suddenEndOfQueue(&self) -> bool { self.0 as i128 == 1 }
  pub fn is_queueOverHill(&self) -> bool { self.0 as i128 == 2 }
  pub fn is_queueAroundBend(&self) -> bool { self.0 as i128 == 3 }
  pub fn is_queueInTunnel(&self) -> bool { self.0 as i128 == 4 }
}

impl Decode for DangerousEndOfQueueSubCauseCode {
    fn decode<'a, D>(decoder: &D, input: &'a [u8]) -> IResult<&'a [u8], Self>
    where
        D: Decoder,
        Self: Sized,
    {
        decoder
            .decode_integer(AsnInteger { constraint: Some(Constraint { min_value: Some(0), max_value: Some(255), extensible: false }), distinguished_values: Some(vec![DistinguishedValue { name: "unavailable".into(), value: 0 },DistinguishedValue { name: "suddenEndOfQueue".into(), value: 1 },DistinguishedValue { name: "queueOverHill".into(), value: 2 },DistinguishedValue { name: "queueAroundBend".into(), value: 3 },DistinguishedValue { name: "queueInTunnel".into(), value: 4 }]) })(input)
            .map(|(remaining, res)| (remaining, Self(res)))
    }
}


/* *
 * This DE indicates the type of the dangerous goods being carried by a heavy vehicle.
 * The value is assigned according to `class` and `division` definitions of dangerous goods as specified in part II,
 * chapter 2.1.1.1 of European Agreement concerning the International Carriage of Dangerous Goods by Road [3].
 * 
 * 
 * @category Vehicle information
 * @revision: V1.3.1
 */
#[derive(Debug, Clone, PartialEq, Default)]
pub enum DangerousGoodsBasic {
  #[default]
  explosives1 = 0,
	explosives2 = 1,
	explosives3 = 2,
	explosives4 = 3,
	explosives5 = 4,
	explosives6 = 5,
	flammableGases = 6,
	nonFlammableGases = 7,
	toxicGases = 8,
	flammableLiquids = 9,
	flammableSolids = 10,
	substancesLiableToSpontaneousCombustion = 11,
	substancesEmittingFlammableGasesUponContactWithWater = 12,
	oxidizingSubstances = 13,
	organicPeroxides = 14,
	toxicSubstances = 15,
	infectiousSubstances = 16,
	radioactiveMaterial = 17,
	corrosiveSubstances = 18,
	miscellaneousDangerousSubstances = 19,
}

impl TryFrom<i128> for DangerousGoodsBasic {
    type Error = DecodingError;

    fn try_from(v: i128) -> Result<Self, Self::Error> {
        match v {
            x if x == Self::explosives1 as i128 => Ok(Self::explosives1),
		  x if x == Self::explosives2 as i128 => Ok(Self::explosives2),
		  x if x == Self::explosives3 as i128 => Ok(Self::explosives3),
		  x if x == Self::explosives4 as i128 => Ok(Self::explosives4),
		  x if x == Self::explosives5 as i128 => Ok(Self::explosives5),
		  x if x == Self::explosives6 as i128 => Ok(Self::explosives6),
		  x if x == Self::flammableGases as i128 => Ok(Self::flammableGases),
		  x if x == Self::nonFlammableGases as i128 => Ok(Self::nonFlammableGases),
		  x if x == Self::toxicGases as i128 => Ok(Self::toxicGases),
		  x if x == Self::flammableLiquids as i128 => Ok(Self::flammableLiquids),
		  x if x == Self::flammableSolids as i128 => Ok(Self::flammableSolids),
		  x if x == Self::substancesLiableToSpontaneousCombustion as i128 => Ok(Self::substancesLiableToSpontaneousCombustion),
		  x if x == Self::substancesEmittingFlammableGasesUponContactWithWater as i128 => Ok(Self::substancesEmittingFlammableGasesUponContactWithWater),
		  x if x == Self::oxidizingSubstances as i128 => Ok(Self::oxidizingSubstances),
		  x if x == Self::organicPeroxides as i128 => Ok(Self::organicPeroxides),
		  x if x == Self::toxicSubstances as i128 => Ok(Self::toxicSubstances),
		  x if x == Self::infectiousSubstances as i128 => Ok(Self::infectiousSubstances),
		  x if x == Self::radioactiveMaterial as i128 => Ok(Self::radioactiveMaterial),
		  x if x == Self::corrosiveSubstances as i128 => Ok(Self::corrosiveSubstances),
		  x if x == Self::miscellaneousDangerousSubstances as i128 => Ok(Self::miscellaneousDangerousSubstances),
            _ => Err(
              DecodingError::new(
                &format!("Invalid enumerated index decoding DangerousGoodsBasic. Received index {}",v), DecodingErrorType::InvalidEnumeratedIndex
              )
            ),
        }
    }
}

impl Decode for DangerousGoodsBasic {
    fn decode<'a, D>(decoder: &D, input: &'a [u8]) -> IResult<&'a [u8], Self>
    where
        D: Decoder,
        Self: Sized,
    {
        decoder.decode_enumerated(AsnEnumerated { members: vec![Enumeral { name: "explosives1".into(), description: None, index: 0 },Enumeral { name: "explosives2".into(), description: None, index: 1 },Enumeral { name: "explosives3".into(), description: None, index: 2 },Enumeral { name: "explosives4".into(), description: None, index: 3 },Enumeral { name: "explosives5".into(), description: None, index: 4 },Enumeral { name: "explosives6".into(), description: None, index: 5 },Enumeral { name: "flammableGases".into(), description: None, index: 6 },Enumeral { name: "nonFlammableGases".into(), description: None, index: 7 },Enumeral { name: "toxicGases".into(), description: None, index: 8 },Enumeral { name: "flammableLiquids".into(), description: None, index: 9 },Enumeral { name: "flammableSolids".into(), description: None, index: 10 },Enumeral { name: "substancesLiableToSpontaneousCombustion".into(), description: None, index: 11 },Enumeral { name: "substancesEmittingFlammableGasesUponContactWithWater".into(), description: None, index: 12 },Enumeral { name: "oxidizingSubstances".into(), description: None, index: 13 },Enumeral { name: "organicPeroxides".into(), description: None, index: 14 },Enumeral { name: "toxicSubstances".into(), description: None, index: 15 },Enumeral { name: "infectiousSubstances".into(), description: None, index: 16 },Enumeral { name: "radioactiveMaterial".into(), description: None, index: 17 },Enumeral { name: "corrosiveSubstances".into(), description: None, index: 18 },Enumeral { name: "miscellaneousDangerousSubstances".into(), description: None, index: 19 }], extensible: None })( 
          input
        )
    }
}


/* *
 * This DE represents the value of the sub cause codes of the @ref CauseCode `dangerousSituation` 
 * 
 * The value shall be set to:
 * - 0 - `unavailable`                      - in case information on the type of dangerous situation is unavailable,
 * - 1 - `emergencyElectronicBrakeEngaged`  - in case emergency electronic brake is engaged,
 * - 2 - `preCrashSystemEngaged`            - in case pre-crash system is engaged,
 * - 3 - `espEngaged`                       - in case Electronic Stability Program (ESP) system is engaged,
 * - 4 - `absEngaged`                       - in case Anti-lock Braking System (ABS) is engaged,
 * - 5 - `aebEngaged`                       - in case Autonomous Emergency Braking (AEB) system is engaged,
 * - 6 - `brakeWarningEngaged`              - in case brake warning is engaged,
 * - 7 - `collisionRiskWarningEngaged`      - in case collision risk warning is engaged,
 * - 8-255                                  - reserved for future usage.
 *
 * @category: Traffic information
 * @revision: V1.3.1
 */
#[derive(Debug, Clone, PartialEq, Default)]
pub struct DangerousSituationSubCauseCode(pub u8);

impl DangerousSituationSubCauseCode {
  pub fn is_unavailable(&self) -> bool { self.0 as i128 == 0 }
  pub fn is_emergencyElectronicBrakeEngaged(&self) -> bool { self.0 as i128 == 1 }
  pub fn is_preCrashSystemEngaged(&self) -> bool { self.0 as i128 == 2 }
  pub fn is_espEngaged(&self) -> bool { self.0 as i128 == 3 }
  pub fn is_absEngaged(&self) -> bool { self.0 as i128 == 4 }
  pub fn is_ebEngaged(&self) -> bool { self.0 as i128 == 5 }
  pub fn is_brakeWarningEngaged(&self) -> bool { self.0 as i128 == 6 }
  pub fn is_collisionRiskWarningEngaged(&self) -> bool { self.0 as i128 == 7 }
}

impl Decode for DangerousSituationSubCauseCode {
    fn decode<'a, D>(decoder: &D, input: &'a [u8]) -> IResult<&'a [u8], Self>
    where
        D: Decoder,
        Self: Sized,
    {
        decoder
            .decode_integer(AsnInteger { constraint: Some(Constraint { min_value: Some(0), max_value: Some(255), extensible: false }), distinguished_values: Some(vec![DistinguishedValue { name: "unavailable".into(), value: 0 },DistinguishedValue { name: "emergencyElectronicBrakeEngaged".into(), value: 1 },DistinguishedValue { name: "preCrashSystemEngaged".into(), value: 2 },DistinguishedValue { name: "espEngaged".into(), value: 3 },DistinguishedValue { name: "absEngaged".into(), value: 4 },DistinguishedValue { name: "ebEngaged".into(), value: 5 },DistinguishedValue { name: "brakeWarningEngaged".into(), value: 6 },DistinguishedValue { name: "collisionRiskWarningEngaged".into(), value: 7 }]) })(input)
            .map(|(remaining, res)| (remaining, Self(res)))
    }
}


/* *
 * This DE represents an offset altitude with regards to a defined altitude value.
 * It may be used to describe a geographical point with regards to a specific reference geographical position.
 *
 * The value shall be set to:
 * - `-12 700` for values equal to or lower than -127 metres,
 * - `n` (`n > -12 700` and `n <= 0`) for altitude offset n x 0,01 metre below the reference position,
 * - `0` for no altitudinal offset,
 * - `n` (`n > 0` and `n < 12799`) for altitude offset n x 0,01 metre above the reference position,
 * - `12 799` for values equal to or greater than 127,99 metres,
 * - `12 800` when the information is unavailable.
 *
 * @unit: 0,01 metre
 * @category: GeoReference information
 * @revision: editorial update in V2.1.1
 */
#[derive(Debug, Clone, PartialEq, Default)]
pub struct DeltaAltitude(pub i16);

impl DeltaAltitude {
  pub fn is_negativeOutOfRange(&self) -> bool { self.0 as i128 == -12700 }
  pub fn is_positiveOutOfRange(&self) -> bool { self.0 as i128 == 12799 }
  pub fn is_unavailable(&self) -> bool { self.0 as i128 == 12800 }
}

impl Decode for DeltaAltitude {
    fn decode<'a, D>(decoder: &D, input: &'a [u8]) -> IResult<&'a [u8], Self>
    where
        D: Decoder,
        Self: Sized,
    {
        decoder
            .decode_integer(AsnInteger { constraint: Some(Constraint { min_value: Some(-12700), max_value: Some(12800), extensible: false }), distinguished_values: Some(vec![DistinguishedValue { name: "negativeOutOfRange".into(), value: -12700 },DistinguishedValue { name: "positiveOutOfRange".into(), value: 12799 },DistinguishedValue { name: "unavailable".into(), value: 12800 }]) })(input)
            .map(|(remaining, res)| (remaining, Self(res)))
    }
}


/* *
 * This DE represents an offset latitude with regards to a defined latitude value.
 * It may be used to describe a geographical point with regards to a specific reference geographical position.
 *
 * The value shall be set to:
 * - `n` (`n >= -131 071` and `n < 0`) for offset n x 10^-7 degree towards the south from the reference position,
 * - `0` for no latitudinal offset,
 * - `n` (`n > 0` and `n < 131 072`) for offset n x 10^-7 degree towards the north from the reference position,
 * - `131 072` when the information is unavailable.
 *
 * @unit: 10^-7 degree
 * @category: GeoReference information
 * @revision: editorial update in V2.1.1
 */
#[derive(Debug, Clone, PartialEq, Default)]
pub struct DeltaLatitude(pub i32);

impl DeltaLatitude {
  pub fn is_unavailable(&self) -> bool { self.0 as i128 == 131072 }
}

impl Decode for DeltaLatitude {
    fn decode<'a, D>(decoder: &D, input: &'a [u8]) -> IResult<&'a [u8], Self>
    where
        D: Decoder,
        Self: Sized,
    {
        decoder
            .decode_integer(AsnInteger { constraint: Some(Constraint { min_value: Some(-131071), max_value: Some(131072), extensible: false }), distinguished_values: Some(vec![DistinguishedValue { name: "unavailable".into(), value: 131072 }]) })(input)
            .map(|(remaining, res)| (remaining, Self(res)))
    }
}


/* *
 * This DE represents an offset longitude with regards to a defined longitude value.
 * It may be used to describe a geographical point with regards to a specific reference geographical position.
 *
 * The value shall be set to:
 * - `n` (`n >= -131 071` and `n < 0`) for offset n x 10^-7 degree towards the west from the reference position,
 * - `0` for no longitudinal offset,
 * - `n` (`n > 0` and `n < 131 072`) for offset n x 10^-7 degree towards the east from the reference position, 
 * - `131 072` when the information is unavailable.
 *
 * @unit: 10^-7 degree
 * @category: GeoReference information
 * @revision: editorial update in V2.1.1
 */
#[derive(Debug, Clone, PartialEq, Default)]
pub struct DeltaLongitude(pub i32);

impl DeltaLongitude {
  pub fn is_unavailable(&self) -> bool { self.0 as i128 == 131072 }
}

impl Decode for DeltaLongitude {
    fn decode<'a, D>(decoder: &D, input: &'a [u8]) -> IResult<&'a [u8], Self>
    where
        D: Decoder,
        Self: Sized,
    {
        decoder
            .decode_integer(AsnInteger { constraint: Some(Constraint { min_value: Some(-131071), max_value: Some(131072), extensible: false }), distinguished_values: Some(vec![DistinguishedValue { name: "unavailable".into(), value: 131072 }]) })(input)
            .map(|(remaining, res)| (remaining, Self(res)))
    }
}


/* *
 * This DE represents a difference in time with respect to a reference time.
 *
 * The value shall be set to:
 * - `n` (`n > 0` and `n < 10001`) to indicate a time value equal to or less than n x 0,001 s, and greater than (n-1) x 0,001 s,
 *
 * Example: a time interval between two consecutive message transmissions.
 * 
 * @unit: 0,001 s
 * @category: Basic information
 * @revision: Created in V2.1.1 from the DE TransmissionInterval in [2]
 */
#[derive(Debug, Clone, PartialEq, Default)]
pub struct DeltaTimeMilliSecondPositive(pub u16);

impl Decode for DeltaTimeMilliSecondPositive {
    fn decode<'a, D>(decoder: &D, input: &'a [u8]) -> IResult<&'a [u8], Self>
    where
        D: Decoder,
        Self: Sized,
    {
        decoder
            .decode_integer(AsnInteger { constraint: Some(Constraint { min_value: Some(1), max_value: Some(10000), extensible: false }), distinguished_values: None })(input)
            .map(|(remaining, res)| (remaining, Self(res)))
    }
}


/* * 
 * This DE represents a signed difference in time with respect to a reference time.
 *
 * The value shall be set to:
 * - `-2048` for time values equal to or less than -2,048 s,
 * - `n` (`n > -2048` and `n < 2047`) to indicate a time value equal to or less than n x 0,001 s, and greater than (n-1) x 0,001 s,
 * - `2047` for time values greater than 2,046 s
 *
 * @unit: 0,001 s
 * @category: Basic information
 * @revision: Created in V2.1.1
*/
#[derive(Debug, Clone, PartialEq, Default)]
pub struct DeltaTimeMilliSecondSigned(pub i16);

impl Decode for DeltaTimeMilliSecondSigned {
    fn decode<'a, D>(decoder: &D, input: &'a [u8]) -> IResult<&'a [u8], Self>
    where
        D: Decoder,
        Self: Sized,
    {
        decoder
            .decode_integer(AsnInteger { constraint: Some(Constraint { min_value: Some(-2048), max_value: Some(2047), extensible: false }), distinguished_values: None })(input)
            .map(|(remaining, res)| (remaining, Self(res)))
    }
}


/* * 
 * This DE represents a difference in time with respect to a reference time.
 * It can be interpreted as the first 8 bits of a GenerationDeltaTime. To convert it to a @ref GenerationDeltaTime, 
 * multiply by 256 (i.e. append a `00` byte)
 *
 * @unit: 256 * 0,001 s 
 * @category: Basic information
 * @revision: Created in V2.1.1
 */
#[derive(Debug, Clone, PartialEq, Default)]
pub struct DeltaTimeQuarterSecond(pub u8);

impl DeltaTimeQuarterSecond {
  pub fn is_unavailable(&self) -> bool { self.0 as i128 == 255 }
}

impl Decode for DeltaTimeQuarterSecond {
    fn decode<'a, D>(decoder: &D, input: &'a [u8]) -> IResult<&'a [u8], Self>
    where
        D: Decoder,
        Self: Sized,
    {
        decoder
            .decode_integer(AsnInteger { constraint: Some(Constraint { min_value: Some(1), max_value: Some(255), extensible: false }), distinguished_values: Some(vec![DistinguishedValue { name: "unavailable".into(), value: 255 }]) })(input)
            .map(|(remaining, res)| (remaining, Self(res)))
    }
}


/* * 
 * This DE represents a difference in time with respect to a reference time.
 *
 * The value shall be set to:
 * - `0` for a difference in time of 0 seconds. 
 * - `n` (`n > 0` and `n < 128`) to indicate a time value equal to or less than n x 0,1 s, and greater than (n-1) x 0,1 s,
 *
 * @unit: 0,1 s
 * @category: Basic information
 * @revision: Created in V2.1.1
*/
#[derive(Debug, Clone, PartialEq, Default)]
pub struct DeltaTimeTenthOfSecond(pub u8);

impl DeltaTimeTenthOfSecond {
  pub fn is_unavailable(&self) -> bool { self.0 as i128 == 127 }
}

impl Decode for DeltaTimeTenthOfSecond {
    fn decode<'a, D>(decoder: &D, input: &'a [u8]) -> IResult<&'a [u8], Self>
    where
        D: Decoder,
        Self: Sized,
    {
        decoder
            .decode_integer(AsnInteger { constraint: Some(Constraint { min_value: Some(0), max_value: Some(127), extensible: false }), distinguished_values: Some(vec![DistinguishedValue { name: "unavailable".into(), value: 127 }]) })(input)
            .map(|(remaining, res)| (remaining, Self(res)))
    }
}


/* * 
 * This DE represents a  difference in time with respect to a reference time.
 *
 * The value shall be set to:
 * - `-0` for a difference in time of 0 seconds. 
 * - `n` (`n > 0` and `n <= 86400`) to indicate a time value equal to or less than n x 1 s, and greater than (n-1) x 1 s,
 *
 * @unit: 1 s
 * @category: Basic information
 * @revision: Created in V2.1.1 from ValidityDuration
*/
#[derive(Debug, Clone, PartialEq, Default)]
pub struct DeltaTimeSecond(pub u32);

impl Decode for DeltaTimeSecond {
    fn decode<'a, D>(decoder: &D, input: &'a [u8]) -> IResult<&'a [u8], Self>
    where
        D: Decoder,
        Self: Sized,
    {
        decoder
            .decode_integer(AsnInteger { constraint: Some(Constraint { min_value: Some(0), max_value: Some(86400), extensible: false }), distinguished_values: None })(input)
            .map(|(remaining, res)| (remaining, Self(res)))
    }
}


/* *
 * This DE indicates a direction with respect to a defined reference direction.
 * Example: a reference direction may be implicitly defined by the definition of a geographical zone.
 *
 * The value shall be set to:
 * - 0 - `sameDirection`     - to indicate the same direction as the reference direction,
 * - 1 - `oppositeDirection` - to indicate opposite direction as the reference direction,
 * - 2 - `bothDirections`    - to indicate both directions, i.e. the same and the opposite direction,
 * - 3 - `unavailable`       - to indicate that the information is unavailable.
 *
 * @category: GeoReference information
 * @revision: Created in V2.1.1
 */
#[derive(Debug, Clone, PartialEq, Default)]
pub struct Direction(pub u8);

impl Direction {
  pub fn is_sameDirection(&self) -> bool { self.0 as i128 == 0 }
  pub fn is_oppositeDirection(&self) -> bool { self.0 as i128 == 1 }
  pub fn is_bothDirections(&self) -> bool { self.0 as i128 == 2 }
  pub fn is_unavailable(&self) -> bool { self.0 as i128 == 3 }
}

impl Decode for Direction {
    fn decode<'a, D>(decoder: &D, input: &'a [u8]) -> IResult<&'a [u8], Self>
    where
        D: Decoder,
        Self: Sized,
    {
        decoder
            .decode_integer(AsnInteger { constraint: Some(Constraint { min_value: Some(0), max_value: Some(3), extensible: false }), distinguished_values: Some(vec![DistinguishedValue { name: "sameDirection".into(), value: 0 },DistinguishedValue { name: "oppositeDirection".into(), value: 1 },DistinguishedValue { name: "bothDirections".into(), value: 2 },DistinguishedValue { name: "unavailable".into(), value: 3 }]) })(input)
            .map(|(remaining, res)| (remaining, Self(res)))
    }
}


/* *
 * This DE indicates in which direction something is moving.
 *
 * The value shall be set to:
 * - 0 - `forward`     - to indicate it is moving forward,
 * - 1 - `backwards`   - to indicate it is moving backwards,
 * - 2 - `unavailable` - to indicate that the information is unavailable.
 *
 * @category: Kinematic information
 * @revision: editorial update in V2.1.1
 */
#[derive(Debug, Clone, PartialEq, Default)]
pub enum DriveDirection {
  #[default]
  ///  This
	forward = 0,
	backward = 1,
	unavailable = 2,
}

impl TryFrom<i128> for DriveDirection {
    type Error = DecodingError;

    fn try_from(v: i128) -> Result<Self, Self::Error> {
        match v {
            x if x == Self::forward as i128 => Ok(Self::forward),
		  x if x == Self::backward as i128 => Ok(Self::backward),
		  x if x == Self::unavailable as i128 => Ok(Self::unavailable),
            _ => Err(
              DecodingError::new(
                &format!("Invalid enumerated index decoding DriveDirection. Received index {}",v), DecodingErrorType::InvalidEnumeratedIndex
              )
            ),
        }
    }
}

impl Decode for DriveDirection {
    fn decode<'a, D>(decoder: &D, input: &'a [u8]) -> IResult<&'a [u8], Self>
    where
        D: Decoder,
        Self: Sized,
    {
        decoder.decode_enumerated(AsnEnumerated { members: vec![Enumeral { name: "forward".into(), description: Some(" This".into()), index: 0 },Enumeral { name: "backward".into(), description: None, index: 1 },Enumeral { name: "unavailable".into(), description: None, index: 2 }], extensible: None })( 
          input
        )
    }
}


/* *
 * This DE indicates whether a driving lane is open to traffic.
 * 
 * A lane is counted from inside border of the road excluding the hard shoulder. The size of the bit string shall
 * correspond to the total number of the driving lanes in the carriageway.
 * 
 * The numbering is matched to @ref LanePosition.
 * The bit `0` is used to indicate the innermost lane, bit `1` is used to indicate the second lane from inside border.
 * 
 * If a lane is closed to traffic, the corresponding bit shall be set to `1`. Otherwise, it shall be set to `0`.
 * 
 * @note: hard shoulder status is not provided by this DE but in @ref HardShoulderStatus.
 * 
 * @category: Traffic information
 * @revision: V1.3.1
 */
#[derive(Debug, Clone, PartialEq, Default)]
pub struct DrivingLaneStatus(pub Vec<bool>);

impl Decode for DrivingLaneStatus {
  fn decode<'a, D>(decoder: &D, input: &'a [u8]) -> IResult<&'a [u8], Self>
  where
      D: Decoder,
      Self: Sized,
  {
      decoder
          .decode_bit_string(AsnBitString { constraint: Some(Constraint { min_value: Some(1), max_value: Some(13), extensible: false }), distinguished_values: None })(input)
          .map(|(remaining, res)| (remaining, Self(res)))
  }
}


/* *
 * This DE indicates whether a vehicle (e.g. public transport vehicle, truck) is under the embarkation process.
 * If that is the case, the value is *TRUE*, otherwise *FALSE*.
 *
 * @category: Vehicle information
 * @revision: editorial update in V2.1.1
 */
#[derive(Debug, Clone, PartialEq, Default)]
pub struct EmbarkationStatus(pub bool);

impl Decode for EmbarkationStatus {
    fn decode<'a, D>(decoder: &D, input: &'a [u8]) -> IResult<&'a [u8], Self>
    where
        D: Decoder,
        Self: Sized,
    {
        decoder
            .decode_boolean(input)
            .map(|(remaining, res)| (remaining, Self(res)))
    }
}


/* *
 * This DE indicates the right of priority requested or assumed by an operating emergency vehicle.
 * The right-of-priority bit shall be set to `1` if the corresponding right is requested.
 * 
 * The corresponding bit shall be set to 1 under the following conditions:
 * - 0 - `requestForRightOfWay`                  - when the vehicle is requesting/assuming the right of way,
 * - 1 - `requestForFreeCrossingAtATrafficLight` - when the vehicle is requesting/assuming the right to pass at a (red) traffic light.
 *
 * @category: Traffic information
 * @revision: description revised in V2.1.1
 */
#[derive(Debug, Clone, PartialEq, Default)]
pub struct EmergencyPriority(pub Vec<bool>);

impl EmergencyPriority {
  pub fn is_requestForRightOfWay(&self) -> bool { *self.0.get(0).unwrap_or(&false) }
  pub fn is_requestForFreeCrossingAtATrafficLight(&self) -> bool { *self.0.get(1).unwrap_or(&false) }
}

impl Decode for EmergencyPriority {
  fn decode<'a, D>(decoder: &D, input: &'a [u8]) -> IResult<&'a [u8], Self>
  where
      D: Decoder,
      Self: Sized,
  {
      decoder
          .decode_bit_string(AsnBitString { constraint: Some(Constraint { min_value: Some(2), max_value: Some(2), extensible: false }), distinguished_values: Some(vec![DistinguishedValue { name: "requestForRightOfWay".into(), value: 0 },DistinguishedValue { name: "requestForFreeCrossingAtATrafficLight".into(), value: 1 }]) })(input)
          .map(|(remaining, res)| (remaining, Self(res)))
  }
}


/* *
 * This DE represents the value of the sub cause codes of the @ref CauseCode "emergencyVehicleApproaching". 
 * 
 * The value shall be set to:
 * - 0 - `unavailable`                   - in case further detailed information on the emergency vehicle approaching event 
 *                                         is unavailable,
 * - 1 - `emergencyVehicleApproaching`   - in case an operating emergency vehicle is approaching,
 * - 2 - `prioritizedVehicleApproaching` - in case a prioritized vehicle is approaching,
 * - 3-255                               - reserved for future usage.
 *
 * @category: Traffic information
 * @revision: V1.3.1
 */
#[derive(Debug, Clone, PartialEq, Default)]
pub struct EmergencyVehicleApproachingSubCauseCode(pub u8);

impl EmergencyVehicleApproachingSubCauseCode {
  pub fn is_unavailable(&self) -> bool { self.0 as i128 == 0 }
  pub fn is_emergencyVehicleApproaching(&self) -> bool { self.0 as i128 == 1 }
  pub fn is_prioritizedVehicleApproaching(&self) -> bool { self.0 as i128 == 2 }
}

impl Decode for EmergencyVehicleApproachingSubCauseCode {
    fn decode<'a, D>(decoder: &D, input: &'a [u8]) -> IResult<&'a [u8], Self>
    where
        D: Decoder,
        Self: Sized,
    {
        decoder
            .decode_integer(AsnInteger { constraint: Some(Constraint { min_value: Some(0), max_value: Some(255), extensible: false }), distinguished_values: Some(vec![DistinguishedValue { name: "unavailable".into(), value: 0 },DistinguishedValue { name: "emergencyVehicleApproaching".into(), value: 1 },DistinguishedValue { name: "prioritizedVehicleApproaching".into(), value: 2 }]) })(input)
            .map(|(remaining, res)| (remaining, Self(res)))
    }
}


/* *
 * This DE indicated the type of energy being used and stored in vehicle.
 *
 * The corresponding bit shall be set to 1 under the following conditions:
 * - 0 - `hydrogenStorage`       - when hydrogen is being used and stored in vehicle,
 * - 1 - `electricEnergyStorage` - when electric energy is being used and stored in vehicle,
 * - 2 - `liquidPropaneGas`      - when liquid Propane Gas (LPG) is being used and stored in vehicle,   
 * - 3 - `compressedNaturalGas ` - when compressedNaturalGas (CNG) is being used and stored in vehicle,
 * - 4 - `diesel`                - when diesel is being used and stored in vehicle,
 * - 5 - `gasoline`              - when gasoline is being used and stored in vehicle,
 * - 6 - `ammonia`               - when ammonia is being used and stored in vehicle.
 *
 * - Otherwise, the corresponding bit shall be set to `0`.
 *
 * @category: Vehicle information
 * @revision: editorial revision in V2.1.1 
 */
#[derive(Debug, Clone, PartialEq, Default)]
pub struct EnergyStorageType(pub Vec<bool>);

impl EnergyStorageType {
  pub fn is_hydrogenStorage(&self) -> bool { *self.0.get(0).unwrap_or(&false) }
  pub fn is_electricEnergyStorage(&self) -> bool { *self.0.get(1).unwrap_or(&false) }
  pub fn is_liquidPropaneGas(&self) -> bool { *self.0.get(2).unwrap_or(&false) }
  pub fn is_compressedNaturalGas(&self) -> bool { *self.0.get(3).unwrap_or(&false) }
  pub fn is_diesel(&self) -> bool { *self.0.get(4).unwrap_or(&false) }
  pub fn is_gasoline(&self) -> bool { *self.0.get(5).unwrap_or(&false) }
  pub fn is_ammonia(&self) -> bool { *self.0.get(6).unwrap_or(&false) }
}

impl Decode for EnergyStorageType {
  fn decode<'a, D>(decoder: &D, input: &'a [u8]) -> IResult<&'a [u8], Self>
  where
      D: Decoder,
      Self: Sized,
  {
      decoder
          .decode_bit_string(AsnBitString { constraint: Some(Constraint { min_value: Some(7), max_value: Some(7), extensible: false }), distinguished_values: Some(vec![DistinguishedValue { name: "hydrogenStorage".into(), value: 0 },DistinguishedValue { name: "electricEnergyStorage".into(), value: 1 },DistinguishedValue { name: "liquidPropaneGas".into(), value: 2 },DistinguishedValue { name: "compressedNaturalGas".into(), value: 3 },DistinguishedValue { name: "diesel".into(), value: 4 },DistinguishedValue { name: "gasoline".into(), value: 5 },DistinguishedValue { name: "ammonia".into(), value: 6 }]) })(input)
          .map(|(remaining, res)| (remaining, Self(res)))
  }
}


/* *
 * This DE represents one of the specific categories in the L category: L1, L2, L3, L4, L5, L6, or L7 according to UNECE/TRANS/WP.29/78/Rev.4 [16].
 *
 *
 * @category: Vehicle information
 * @revision: V2.1.1
 */
#[derive(Debug, Clone, PartialEq, Default)]
pub enum EuVehicleCategoryL {
  #[default]
  l1 = 0,
	l2 = 1,
	l3 = 2,
	l4 = 3,
	l5 = 4,
	l6 = 5,
	l7 = 6,
}

impl TryFrom<i128> for EuVehicleCategoryL {
    type Error = DecodingError;

    fn try_from(v: i128) -> Result<Self, Self::Error> {
        match v {
            x if x == Self::l1 as i128 => Ok(Self::l1),
		  x if x == Self::l2 as i128 => Ok(Self::l2),
		  x if x == Self::l3 as i128 => Ok(Self::l3),
		  x if x == Self::l4 as i128 => Ok(Self::l4),
		  x if x == Self::l5 as i128 => Ok(Self::l5),
		  x if x == Self::l6 as i128 => Ok(Self::l6),
		  x if x == Self::l7 as i128 => Ok(Self::l7),
            _ => Err(
              DecodingError::new(
                &format!("Invalid enumerated index decoding EuVehicleCategoryL. Received index {}",v), DecodingErrorType::InvalidEnumeratedIndex
              )
            ),
        }
    }
}

impl Decode for EuVehicleCategoryL {
    fn decode<'a, D>(decoder: &D, input: &'a [u8]) -> IResult<&'a [u8], Self>
    where
        D: Decoder,
        Self: Sized,
    {
        decoder.decode_enumerated(AsnEnumerated { members: vec![Enumeral { name: "l1".into(), description: None, index: 0 },Enumeral { name: "l2".into(), description: None, index: 1 },Enumeral { name: "l3".into(), description: None, index: 2 },Enumeral { name: "l4".into(), description: None, index: 3 },Enumeral { name: "l5".into(), description: None, index: 4 },Enumeral { name: "l6".into(), description: None, index: 5 },Enumeral { name: "l7".into(), description: None, index: 6 }], extensible: None })( 
          input
        )
    }
}


/* *
 * This DE represents one of the specific categories in the M category: M1, M2, or M3 according to UNECE/TRANS/WP.29/78/Rev.4 [16].
 *
 *
 * @category: Vehicle information
 * @revision: V2.1.1
 */
#[derive(Debug, Clone, PartialEq, Default)]
pub enum EuVehicleCategoryM {
  #[default]
  m1 = 0,
	m2 = 1,
	m3 = 2,
}

impl TryFrom<i128> for EuVehicleCategoryM {
    type Error = DecodingError;

    fn try_from(v: i128) -> Result<Self, Self::Error> {
        match v {
            x if x == Self::m1 as i128 => Ok(Self::m1),
		  x if x == Self::m2 as i128 => Ok(Self::m2),
		  x if x == Self::m3 as i128 => Ok(Self::m3),
            _ => Err(
              DecodingError::new(
                &format!("Invalid enumerated index decoding EuVehicleCategoryM. Received index {}",v), DecodingErrorType::InvalidEnumeratedIndex
              )
            ),
        }
    }
}

impl Decode for EuVehicleCategoryM {
    fn decode<'a, D>(decoder: &D, input: &'a [u8]) -> IResult<&'a [u8], Self>
    where
        D: Decoder,
        Self: Sized,
    {
        decoder.decode_enumerated(AsnEnumerated { members: vec![Enumeral { name: "m1".into(), description: None, index: 0 },Enumeral { name: "m2".into(), description: None, index: 1 },Enumeral { name: "m3".into(), description: None, index: 2 }], extensible: None })( 
          input
        )
    }
}


/* *
 * This DE represents one of the specific categories in the N category: N1, N2, or N3 according to UNECE/TRANS/WP.29/78/Rev.4 [16].
 *
 *
 * @category: Vehicle information
 * @revision: V2.1.1
 */
#[derive(Debug, Clone, PartialEq, Default)]
pub enum EuVehicleCategoryN {
  #[default]
  n1 = 0,
	n2 = 1,
	n3 = 2,
}

impl TryFrom<i128> for EuVehicleCategoryN {
    type Error = DecodingError;

    fn try_from(v: i128) -> Result<Self, Self::Error> {
        match v {
            x if x == Self::n1 as i128 => Ok(Self::n1),
		  x if x == Self::n2 as i128 => Ok(Self::n2),
		  x if x == Self::n3 as i128 => Ok(Self::n3),
            _ => Err(
              DecodingError::new(
                &format!("Invalid enumerated index decoding EuVehicleCategoryN. Received index {}",v), DecodingErrorType::InvalidEnumeratedIndex
              )
            ),
        }
    }
}

impl Decode for EuVehicleCategoryN {
    fn decode<'a, D>(decoder: &D, input: &'a [u8]) -> IResult<&'a [u8], Self>
    where
        D: Decoder,
        Self: Sized,
    {
        decoder.decode_enumerated(AsnEnumerated { members: vec![Enumeral { name: "n1".into(), description: None, index: 0 },Enumeral { name: "n2".into(), description: None, index: 1 },Enumeral { name: "n3".into(), description: None, index: 2 }], extensible: None })( 
          input
        )
    }
}


/* *
 * This DE represents one of the specific categories in the O category: O1, O2, O3 or O4 according to UNECE/TRANS/WP.29/78/Rev.4 [16].
 *
 *
 * @category: Vehicle information
 * @revision: V2.1.1
 */
#[derive(Debug, Clone, PartialEq, Default)]
pub enum EuVehicleCategoryO {
  #[default]
  o1 = 0,
	o2 = 1,
	o3 = 2,
	o4 = 3,
}

impl TryFrom<i128> for EuVehicleCategoryO {
    type Error = DecodingError;

    fn try_from(v: i128) -> Result<Self, Self::Error> {
        match v {
            x if x == Self::o1 as i128 => Ok(Self::o1),
		  x if x == Self::o2 as i128 => Ok(Self::o2),
		  x if x == Self::o3 as i128 => Ok(Self::o3),
		  x if x == Self::o4 as i128 => Ok(Self::o4),
            _ => Err(
              DecodingError::new(
                &format!("Invalid enumerated index decoding EuVehicleCategoryO. Received index {}",v), DecodingErrorType::InvalidEnumeratedIndex
              )
            ),
        }
    }
}

impl Decode for EuVehicleCategoryO {
    fn decode<'a, D>(decoder: &D, input: &'a [u8]) -> IResult<&'a [u8], Self>
    where
        D: Decoder,
        Self: Sized,
    {
        decoder.decode_enumerated(AsnEnumerated { members: vec![Enumeral { name: "o1".into(), description: None, index: 0 },Enumeral { name: "o2".into(), description: None, index: 1 },Enumeral { name: "o3".into(), description: None, index: 2 },Enumeral { name: "o4".into(), description: None, index: 3 }], extensible: None })( 
          input
        )
    }
}


/* *
 * This DE describes the status of the exterior light switches of a vehicle incl. VRU vehicles.
 *
 * The corresponding bit shall be set to 1 under the following conditions:
 * - 0 - `lowBeamHeadlightsOn`    - when the low beam head light switch is on,
 * - 1 - `highBeamHeadlightsOn`   - when the high beam head light switch is on,
 * - 2 - `leftTurnSignalOn`       - when the left turnSignal switch is on,
 * - 3 - `rightTurnSignalOn`      - when the right turn signal switch is on,
 * - 4 - `daytimeRunningLightsOn` - when the daytime running light switch is on,
 * - 5 - `reverseLightOn`         - when the reverse light switch is on,
 * - 6 - `fogLightOn`             - when the tail fog light switch is on,
 * - 7 - `parkingLightsOn`        - when the parking light switch is on.
 * 
 * @note: The value of each bit indicates the state of the switch, which commands the corresponding light.
 * The bit corresponding to a specific light is set to `1`, when the corresponding switch is turned on,
 * either manually by the driver or automatically by a vehicle system. The bit value does not indicate
 * if the corresponding lamps are alight or not.
 * 
 * If a vehicle is not equipped with a certain light or if the light switch status information is not available,
 * the corresponding bit shall be set to `0`.
 * 
 * As the bit value indicates only the state of the switch, the turn signal and hazard signal bit values shall not
 * alternate with the blinking interval.
 * 
 * For hazard indicator, the `leftTurnSignalOn (2)` and `rightTurnSignalOn (3)` shall be both set to `1`.
 * 
 * @category Vehicle information
 * @revision: Description revised in V2.1.1
 */
#[derive(Debug, Clone, PartialEq, Default)]
pub struct ExteriorLights(pub Vec<bool>);

impl ExteriorLights {
  pub fn is_lowBeamHeadlightsOn(&self) -> bool { *self.0.get(0).unwrap_or(&false) }
  pub fn is_highBeamHeadlightsOn(&self) -> bool { *self.0.get(1).unwrap_or(&false) }
  pub fn is_leftTurnSignalOn(&self) -> bool { *self.0.get(2).unwrap_or(&false) }
  pub fn is_rightTurnSignalOn(&self) -> bool { *self.0.get(3).unwrap_or(&false) }
  pub fn is_daytimeRunningLightsOn(&self) -> bool { *self.0.get(4).unwrap_or(&false) }
  pub fn is_reverseLightOn(&self) -> bool { *self.0.get(5).unwrap_or(&false) }
  pub fn is_fogLightOn(&self) -> bool { *self.0.get(6).unwrap_or(&false) }
  pub fn is_parkingLightsOn(&self) -> bool { *self.0.get(7).unwrap_or(&false) }
}

impl Decode for ExteriorLights {
  fn decode<'a, D>(decoder: &D, input: &'a [u8]) -> IResult<&'a [u8], Self>
  where
      D: Decoder,
      Self: Sized,
  {
      decoder
          .decode_bit_string(AsnBitString { constraint: Some(Constraint { min_value: Some(8), max_value: Some(8), extensible: false }), distinguished_values: Some(vec![DistinguishedValue { name: "lowBeamHeadlightsOn".into(), value: 0 },DistinguishedValue { name: "highBeamHeadlightsOn".into(), value: 1 },DistinguishedValue { name: "leftTurnSignalOn".into(), value: 2 },DistinguishedValue { name: "rightTurnSignalOn".into(), value: 3 },DistinguishedValue { name: "daytimeRunningLightsOn".into(), value: 4 },DistinguishedValue { name: "reverseLightOn".into(), value: 5 },DistinguishedValue { name: "fogLightOn".into(), value: 6 },DistinguishedValue { name: "parkingLightsOn".into(), value: 7 }]) })(input)
          .map(|(remaining, res)| (remaining, Self(res)))
  }
}


/* *
 * This DE represents a timestamp based on TimestampIts modulo 65 536.
 * This means that generationDeltaTime = TimestampIts mod 65 536.
 *
 * @category: Basic information
 * @revision: Created in V2.1.1 based on ETSI TS 103 900 [1]
*/
#[derive(Debug, Clone, PartialEq, Default)]
pub struct GenerationDeltaTime(pub u16);

impl GenerationDeltaTime {
  pub fn is_oneMilliSec(&self) -> bool { self.0 as i128 == 1 }
}

impl Decode for GenerationDeltaTime {
    fn decode<'a, D>(decoder: &D, input: &'a [u8]) -> IResult<&'a [u8], Self>
    where
        D: Decoder,
        Self: Sized,
    {
        decoder
            .decode_integer(AsnInteger { constraint: Some(Constraint { min_value: Some(0), max_value: Some(65535), extensible: false }), distinguished_values: Some(vec![DistinguishedValue { name: "oneMilliSec".into(), value: 1 }]) })(input)
            .map(|(remaining, res)| (remaining, Self(res)))
    }
}


/* *
 * This DE indicates the current status of a hard shoulder: whether it is available for special usage
 * (e.g. for stopping or for driving) or closed for all vehicles.
 * 
 * The value shall be set to:
 * - 0 - `availableForStopping` - if the hard shoulder is available for stopping in e.g. emergency situations,
 * - 1 - `closed`               - if the hard shoulder is closed and cannot be occupied in any case,
 * - 2 - `availableForDriving`  - if the hard shoulder is available for regular driving.
 *
 * @category: Traffic information
 * @revision: Description revised in V2.1.1
 */
#[derive(Debug, Clone, PartialEq, Default)]
pub enum HardShoulderStatus {
  #[default]
  availableForStopping = 0,
	closed = 1,
	availableForDriving = 2,
}

impl TryFrom<i128> for HardShoulderStatus {
    type Error = DecodingError;

    fn try_from(v: i128) -> Result<Self, Self::Error> {
        match v {
            x if x == Self::availableForStopping as i128 => Ok(Self::availableForStopping),
		  x if x == Self::closed as i128 => Ok(Self::closed),
		  x if x == Self::availableForDriving as i128 => Ok(Self::availableForDriving),
            _ => Err(
              DecodingError::new(
                &format!("Invalid enumerated index decoding HardShoulderStatus. Received index {}",v), DecodingErrorType::InvalidEnumeratedIndex
              )
            ),
        }
    }
}

impl Decode for HardShoulderStatus {
    fn decode<'a, D>(decoder: &D, input: &'a [u8]) -> IResult<&'a [u8], Self>
    where
        D: Decoder,
        Self: Sized,
    {
        decoder.decode_enumerated(AsnEnumerated { members: vec![Enumeral { name: "availableForStopping".into(), description: None, index: 0 },Enumeral { name: "closed".into(), description: None, index: 1 },Enumeral { name: "availableForDriving".into(), description: None, index: 2 }], extensible: None })( 
          input
        )
    }
}


/* *
 * This DE represents the value of the sub cause code of the @ref CauseCode `hazardousLocation-AnimalOnTheRoad`.
 * 
 * The value shall be set to:
 * - 0 - `unavailable`  - in case further detailed information on the animal on the road event is unavailable,
 * - 1 - `wildAnimals`  - in case wild animals are detected on the road,
 * - 2 - `herdOfAnimals`- in case herd of animals are detected on the road,
 * - 3 - `smallAnimals` - in case small size animals are detected on the road,
 * - 4 - `largeAnimals` - in case large size animals are detected on the road.
 * - 5-255              - are reserved for future usage.
 *
 * @category: Traffic information
 * @revision: V1.3.1
 */
#[derive(Debug, Clone, PartialEq, Default)]
pub struct HazardousLocation_AnimalOnTheRoadSubCauseCode(pub u8);

impl HazardousLocation_AnimalOnTheRoadSubCauseCode {
  pub fn is_unavailable(&self) -> bool { self.0 as i128 == 0 }
  pub fn is_wildAnimals(&self) -> bool { self.0 as i128 == 1 }
  pub fn is_herdOfAnimals(&self) -> bool { self.0 as i128 == 2 }
  pub fn is_smallAnimals(&self) -> bool { self.0 as i128 == 3 }
  pub fn is_largeAnimals(&self) -> bool { self.0 as i128 == 4 }
}

impl Decode for HazardousLocation_AnimalOnTheRoadSubCauseCode {
    fn decode<'a, D>(decoder: &D, input: &'a [u8]) -> IResult<&'a [u8], Self>
    where
        D: Decoder,
        Self: Sized,
    {
        decoder
            .decode_integer(AsnInteger { constraint: Some(Constraint { min_value: Some(0), max_value: Some(255), extensible: false }), distinguished_values: Some(vec![DistinguishedValue { name: "unavailable".into(), value: 0 },DistinguishedValue { name: "wildAnimals".into(), value: 1 },DistinguishedValue { name: "herdOfAnimals".into(), value: 2 },DistinguishedValue { name: "smallAnimals".into(), value: 3 },DistinguishedValue { name: "largeAnimals".into(), value: 4 }]) })(input)
            .map(|(remaining, res)| (remaining, Self(res)))
    }
}


/* *
 * This DE represents the sub cause code of the @ref CauseCode  `hazardousLocation-DangerousCurve`.
 * 
 * The value shall be set to:
 * - 0 - `unavailable`                                        - in case further detailed information on the dangerous curve is unavailable,
 * - 1 - `dangerousLeftTurnCurve`                             - in case the dangerous curve is a left turn curve,
 * - 2 - `dangerousRightTurnCurve`                            - in case the dangerous curve is a right turn curve,
 * - 3 - `multipleCurvesStartingWithUnknownTurningDirection`  - in case of multiple curves for which the starting curve turning direction is not known,
 * - 4 - `multipleCurvesStartingWithLeftTurn`                 - in case of multiple curves starting with a left turn curve,
 * - 5 - `multipleCurvesStartingWithRightTurn`                - in case of multiple curves starting with a right turn curve.
 * - 6-255                                                    - are reserved for future usage.
 * 
 * The definition of whether a curve is dangerous may vary according to region and according to vehicle types/mass
 * and vehicle speed driving on the curve. This definition is out of scope of the present document.
 *
 * @category: Traffic information
 * @revision: V1.3.1
 */
#[derive(Debug, Clone, PartialEq, Default)]
pub struct HazardousLocation_DangerousCurveSubCauseCode(pub u8);

impl HazardousLocation_DangerousCurveSubCauseCode {
  pub fn is_unavailable(&self) -> bool { self.0 as i128 == 0 }
  pub fn is_dangerousLeftTurnCurve(&self) -> bool { self.0 as i128 == 1 }
  pub fn is_dangerousRightTurnCurve(&self) -> bool { self.0 as i128 == 2 }
  pub fn is_multipleCurvesStartingWithUnknownTurningDirection(&self) -> bool { self.0 as i128 == 3 }
  pub fn is_multipleCurvesStartingWithLeftTurn(&self) -> bool { self.0 as i128 == 4 }
  pub fn is_multipleCurvesStartingWithRightTurn(&self) -> bool { self.0 as i128 == 5 }
}

impl Decode for HazardousLocation_DangerousCurveSubCauseCode {
    fn decode<'a, D>(decoder: &D, input: &'a [u8]) -> IResult<&'a [u8], Self>
    where
        D: Decoder,
        Self: Sized,
    {
        decoder
            .decode_integer(AsnInteger { constraint: Some(Constraint { min_value: Some(0), max_value: Some(255), extensible: false }), distinguished_values: Some(vec![DistinguishedValue { name: "unavailable".into(), value: 0 },DistinguishedValue { name: "dangerousLeftTurnCurve".into(), value: 1 },DistinguishedValue { name: "dangerousRightTurnCurve".into(), value: 2 },DistinguishedValue { name: "multipleCurvesStartingWithUnknownTurningDirection".into(), value: 3 },DistinguishedValue { name: "multipleCurvesStartingWithLeftTurn".into(), value: 4 },DistinguishedValue { name: "multipleCurvesStartingWithRightTurn".into(), value: 5 }]) })(input)
            .map(|(remaining, res)| (remaining, Self(res)))
    }
}


/* *
 * This DE represents the value of the sub cause code of the @ref CauseCode `hazardousLocation-ObstacleOnTheRoad`. 
 * 
 * The value shall be set to:
 * - 0 - `unavailable`    - in case further detailed information on the detected obstacle is unavailable,
 * - 1 - `shedLoad`       - in case detected obstacle is large amount of obstacles (shedload),
 * - 2 - `partsOfVehicles`- in case detected obstacles are parts of vehicles,
 * - 3 - `partsOfTyres`   - in case the detected obstacles are parts of tyres,
 * - 4 - `bigObjects`     - in case the detected obstacles are big objects,
 * - 5 - `fallenTrees`    - in case the detected obstacles are fallen trees,
 * - 6 - `hubCaps`        - in case the detected obstacles are hub caps,
 * - 7 - `waitingVehicles`- in case the detected obstacles are waiting vehicles.
 * - 8-255                - are reserved for future usage.
 *
 * @category: Traffic information
 * @revision: V1.3.1
 */
#[derive(Debug, Clone, PartialEq, Default)]
pub struct HazardousLocation_ObstacleOnTheRoadSubCauseCode(pub u8);

impl HazardousLocation_ObstacleOnTheRoadSubCauseCode {
  pub fn is_unavailable(&self) -> bool { self.0 as i128 == 0 }
  pub fn is_shedLoad(&self) -> bool { self.0 as i128 == 1 }
  pub fn is_partsOfVehicles(&self) -> bool { self.0 as i128 == 2 }
  pub fn is_partsOfTyres(&self) -> bool { self.0 as i128 == 3 }
  pub fn is_bigObjects(&self) -> bool { self.0 as i128 == 4 }
  pub fn is_fallenTrees(&self) -> bool { self.0 as i128 == 5 }
  pub fn is_hubCaps(&self) -> bool { self.0 as i128 == 6 }
  pub fn is_waitingVehicles(&self) -> bool { self.0 as i128 == 7 }
}

impl Decode for HazardousLocation_ObstacleOnTheRoadSubCauseCode {
    fn decode<'a, D>(decoder: &D, input: &'a [u8]) -> IResult<&'a [u8], Self>
    where
        D: Decoder,
        Self: Sized,
    {
        decoder
            .decode_integer(AsnInteger { constraint: Some(Constraint { min_value: Some(0), max_value: Some(255), extensible: false }), distinguished_values: Some(vec![DistinguishedValue { name: "unavailable".into(), value: 0 },DistinguishedValue { name: "shedLoad".into(), value: 1 },DistinguishedValue { name: "partsOfVehicles".into(), value: 2 },DistinguishedValue { name: "partsOfTyres".into(), value: 3 },DistinguishedValue { name: "bigObjects".into(), value: 4 },DistinguishedValue { name: "fallenTrees".into(), value: 5 },DistinguishedValue { name: "hubCaps".into(), value: 6 },DistinguishedValue { name: "waitingVehicles".into(), value: 7 }]) })(input)
            .map(|(remaining, res)| (remaining, Self(res)))
    }
}


/* *
 * This DE represents the value of the sub cause code of the @ref CauseCode `hazardousLocation-SurfaceCondition`. 
 * 
The value shall be set to:
 * - 0  - `unavailable`     - in case further detailed information on the road surface condition is unavailable,
 * - 1  - `rockfalls`       - in case rock falls are detected on the road surface,
 * - 2  - `earthquakeDamage`- in case the road surface is damaged by earthquake,
 * - 3  - `sewerCollapse`   - in case of sewer collapse on the road surface,
 * - 4  - `subsidence`      - in case road surface is damaged by subsidence,
 * - 5  - `snowDrifts`      - in case road surface is damaged due to snow drift,
 * - 6  - `stormDamage`     - in case road surface is damaged by strong storm,
 * - 7  - `burstPipe`       - in case road surface is damaged due to pipe burst,
 * - 8  - `volcanoEruption` - in case road surface is damaged due to volcano eruption,
 * - 9  - `fallingIce`      - in case road surface damage is due to falling ice,
 * - 10 - `fire`            - in case there is fire on or near to the road surface.
 * - 11-255                 - are reserved for future usage.
 *
 * @category: Traffic information
 * @revision: V1.3.1
 */
#[derive(Debug, Clone, PartialEq, Default)]
pub struct HazardousLocation_SurfaceConditionSubCauseCode(pub u8);

impl HazardousLocation_SurfaceConditionSubCauseCode {
  pub fn is_unavailable(&self) -> bool { self.0 as i128 == 0 }
  pub fn is_rockfalls(&self) -> bool { self.0 as i128 == 1 }
  pub fn is_earthquakeDamage(&self) -> bool { self.0 as i128 == 2 }
  pub fn is_sewerCollapse(&self) -> bool { self.0 as i128 == 3 }
  pub fn is_subsidence(&self) -> bool { self.0 as i128 == 4 }
  pub fn is_snowDrifts(&self) -> bool { self.0 as i128 == 5 }
  pub fn is_stormDamage(&self) -> bool { self.0 as i128 == 6 }
  pub fn is_burstPipe(&self) -> bool { self.0 as i128 == 7 }
  pub fn is_volcanoEruption(&self) -> bool { self.0 as i128 == 8 }
  pub fn is_fallingIce(&self) -> bool { self.0 as i128 == 9 }
  pub fn is_fire(&self) -> bool { self.0 as i128 == 10 }
}

impl Decode for HazardousLocation_SurfaceConditionSubCauseCode {
    fn decode<'a, D>(decoder: &D, input: &'a [u8]) -> IResult<&'a [u8], Self>
    where
        D: Decoder,
        Self: Sized,
    {
        decoder
            .decode_integer(AsnInteger { constraint: Some(Constraint { min_value: Some(0), max_value: Some(255), extensible: false }), distinguished_values: Some(vec![DistinguishedValue { name: "unavailable".into(), value: 0 },DistinguishedValue { name: "rockfalls".into(), value: 1 },DistinguishedValue { name: "earthquakeDamage".into(), value: 2 },DistinguishedValue { name: "sewerCollapse".into(), value: 3 },DistinguishedValue { name: "subsidence".into(), value: 4 },DistinguishedValue { name: "snowDrifts".into(), value: 5 },DistinguishedValue { name: "stormDamage".into(), value: 6 },DistinguishedValue { name: "burstPipe".into(), value: 7 },DistinguishedValue { name: "volcanoEruption".into(), value: 8 },DistinguishedValue { name: "fallingIce".into(), value: 9 },DistinguishedValue { name: "fire".into(), value: 10 }]) })(input)
            .map(|(remaining, res)| (remaining, Self(res)))
    }
}


/* *
 * This DE indicates the heading confidence value which represents the estimated absolute accuracy of a heading value with a confidence level of 95 %.
 * 
 * The value shall be set to:
 * - `n` (`n > 0` and `n < 126`) if the confidence value is equal to or less than n x 0,1 degree and more than (n-1) x 0,1 degree,
 * - `126` if the confidence value is out of range, i.e. greater than 12,5 degrees,
 * - `127` if the confidence value information is not available.
 * 
 * @note:	The fact that a value is received with confidence value set to `unavailable(127)` can be caused by several reasons,
 * such as:
 * - the sensor cannot deliver the accuracy at the defined confidence level because it is a low-end sensor,
 * - the sensor cannot calculate the accuracy due to lack of variables, or
 * - there has been a vehicle bus (e.g. CAN bus) error.
 * In all 3 cases above, the heading value may be valid and used by the application.
 *
 * @note: If a heading value is received and its confidence value is set to `outOfRange(126)`, it means that the 
 * heading value is not valid and therefore cannot be trusted. Such value is not useful for the application.
 * @note: this DE is kept for backwards compatibility reasons only. It is recommended to use the @ref Wgs84AngleConfidence instead. 
 * 
 * @unit: 0,1 degree
 * @category: GeoReference information
 * @revision: Description revised in V2.1.1
 */
#[derive(Debug, Clone, PartialEq, Default)]
pub struct HeadingConfidence(pub u8);

impl HeadingConfidence {
  pub fn is_outOfRange(&self) -> bool { self.0 as i128 == 126 }
  pub fn is_unavailable(&self) -> bool { self.0 as i128 == 127 }
}

impl Decode for HeadingConfidence {
    fn decode<'a, D>(decoder: &D, input: &'a [u8]) -> IResult<&'a [u8], Self>
    where
        D: Decoder,
        Self: Sized,
    {
        decoder
            .decode_integer(AsnInteger { constraint: Some(Constraint { min_value: Some(1), max_value: Some(127), extensible: false }), distinguished_values: Some(vec![DistinguishedValue { name: "outOfRange".into(), value: 126 },DistinguishedValue { name: "unavailable".into(), value: 127 }]) })(input)
            .map(|(remaining, res)| (remaining, Self(res)))
    }
}


/* *
 * This DE represents the orientation of the horizontal velocity vector with regards to the WGS84 north.
 * When the information is not available, the DE shall be set to 3 601. The value 3600 shall not be used.
 *
 * @note: this DE is kept for backwards compatibility reasons only. It is recommended to use the @ref Wgs84AngleValue instead. 
 *
 * Unit: 0,1 degree
 * Categories: GeoReference information
 * @revision: Description revised in V2.1.1 (usage of value 3600 specified) 
*/
#[derive(Debug, Clone, PartialEq, Default)]
pub struct HeadingValue(pub u16);

impl HeadingValue {
  pub fn is_wgs84North(&self) -> bool { self.0 as i128 == 0 }
  pub fn is_wgs84East(&self) -> bool { self.0 as i128 == 900 }
  pub fn is_wgs84South(&self) -> bool { self.0 as i128 == 1800 }
  pub fn is_wgs84West(&self) -> bool { self.0 as i128 == 2700 }
  pub fn is_doNotUse(&self) -> bool { self.0 as i128 == 3600 }
  pub fn is_unavailable(&self) -> bool { self.0 as i128 == 3601 }
}

impl Decode for HeadingValue {
    fn decode<'a, D>(decoder: &D, input: &'a [u8]) -> IResult<&'a [u8], Self>
    where
        D: Decoder,
        Self: Sized,
    {
        decoder
            .decode_integer(AsnInteger { constraint: Some(Constraint { min_value: Some(0), max_value: Some(3601), extensible: false }), distinguished_values: Some(vec![DistinguishedValue { name: "wgs84North".into(), value: 0 },DistinguishedValue { name: "wgs84East".into(), value: 900 },DistinguishedValue { name: "wgs84South".into(), value: 1800 },DistinguishedValue { name: "wgs84West".into(), value: 2700 },DistinguishedValue { name: "doNotUse".into(), value: 3600 },DistinguishedValue { name: "unavailable".into(), value: 3601 }]) })(input)
            .map(|(remaining, res)| (remaining, Self(res)))
    }
}


/* *
 * This DE represents the height of the left or right longitude carrier of vehicle from base to top (left or right carrier seen from vehicle
 * rear to front). 
 *
 * The value shall be set to:
 * - `n` (`n >= 1` and `n < 99`) if the height information is equal to or less than n x 0,01 metre and more than (n-1) x 0,01 metre,
 * - `99` if the height is out of range, i.e. equal to or greater than 0,98 m,
 * - `100` if the height information is not available.
 *
 * @unit 0,01 metre
 * @category Vehicle information
 * @revision: Description revised in V2.1.1 (the definition of 99 has changed slightly) 
 */
#[derive(Debug, Clone, PartialEq, Default)]
pub struct HeightLonCarr(pub u8);

impl HeightLonCarr {
  pub fn is_outOfRange(&self) -> bool { self.0 as i128 == 99 }
  pub fn is_unavailable(&self) -> bool { self.0 as i128 == 100 }
}

impl Decode for HeightLonCarr {
    fn decode<'a, D>(decoder: &D, input: &'a [u8]) -> IResult<&'a [u8], Self>
    where
        D: Decoder,
        Self: Sized,
    {
        decoder
            .decode_integer(AsnInteger { constraint: Some(Constraint { min_value: Some(1), max_value: Some(100), extensible: false }), distinguished_values: Some(vec![DistinguishedValue { name: "outOfRange".into(), value: 99 },DistinguishedValue { name: "unavailable".into(), value: 100 }]) })(input)
            .map(|(remaining, res)| (remaining, Self(res)))
    }
}


/* *
 * This DE represents the value of the sub cause code of the @ref CauseCode `humanPresenceOnTheRoad`.
 * 
 * The value shall be set to:
 * - 0 - `unavailable`          - in case further detailed information on human presence on the road is unavailable,
 * - 1 - `childrenOnRoadway`    - in case children are detected on the road,
 * - 2 - `cyclistOnRoadway`     - in case cyclist presence is detected on the road,
 * - 3 - `motorcyclistOnRoadway`- in case motorcyclist presence is detected on the road.
 * - 4-255                      - are reserved for future usage.
 *
 * @category: Traffic information
 * @revision: editorial revision in V2.1.1
 */
#[derive(Debug, Clone, PartialEq, Default)]
pub struct HumanPresenceOnTheRoadSubCauseCode(pub u8);

impl HumanPresenceOnTheRoadSubCauseCode {
  pub fn is_unavailable(&self) -> bool { self.0 as i128 == 0 }
  pub fn is_childrenOnRoadway(&self) -> bool { self.0 as i128 == 1 }
  pub fn is_cyclistOnRoadway(&self) -> bool { self.0 as i128 == 2 }
  pub fn is_motorcyclistOnRoadway(&self) -> bool { self.0 as i128 == 3 }
}

impl Decode for HumanPresenceOnTheRoadSubCauseCode {
    fn decode<'a, D>(decoder: &D, input: &'a [u8]) -> IResult<&'a [u8], Self>
    where
        D: Decoder,
        Self: Sized,
    {
        decoder
            .decode_integer(AsnInteger { constraint: Some(Constraint { min_value: Some(0), max_value: Some(255), extensible: false }), distinguished_values: Some(vec![DistinguishedValue { name: "unavailable".into(), value: 0 },DistinguishedValue { name: "childrenOnRoadway".into(), value: 1 },DistinguishedValue { name: "cyclistOnRoadway".into(), value: 2 },DistinguishedValue { name: "motorcyclistOnRoadway".into(), value: 3 }]) })(input)
            .map(|(remaining, res)| (remaining, Self(res)))
    }
}


/* *
 * This DE represents the value of the sub cause codes of the @ref CauseCode "humanProblem".
 * 
 * The value shall be set to:
 * - 0 - `unavailable`    - in case further detailed information on human health problem is unavailable,
 * - 1 - `glycemiaProblem`- in case human problem is due to glycaemia problem,
 * - 2 - `heartProblem`   - in case human problem is due to heart problem.
 * - 3-255                - reserved for future usage.
 *
 * @category: Traffic information
 * @revision: V1.3.1
 */
#[derive(Debug, Clone, PartialEq, Default)]
pub struct HumanProblemSubCauseCode(pub u8);

impl HumanProblemSubCauseCode {
  pub fn is_unavailable(&self) -> bool { self.0 as i128 == 0 }
  pub fn is_glycemiaProblem(&self) -> bool { self.0 as i128 == 1 }
  pub fn is_heartProblem(&self) -> bool { self.0 as i128 == 2 }
}

impl Decode for HumanProblemSubCauseCode {
    fn decode<'a, D>(decoder: &D, input: &'a [u8]) -> IResult<&'a [u8], Self>
    where
        D: Decoder,
        Self: Sized,
    {
        decoder
            .decode_integer(AsnInteger { constraint: Some(Constraint { min_value: Some(0), max_value: Some(255), extensible: false }), distinguished_values: Some(vec![DistinguishedValue { name: "unavailable".into(), value: 0 },DistinguishedValue { name: "glycemiaProblem".into(), value: 1 },DistinguishedValue { name: "heartProblem".into(), value: 2 }]) })(input)
            .map(|(remaining, res)| (remaining, Self(res)))
    }
}


/* * 
 * This DE is a general identifier.
 * 
 * @category: Basic information
 * @revision: Created in V2.1.1
*/
#[derive(Debug, Clone, PartialEq, Default)]
pub struct Identifier1B(pub u8);

impl Decode for Identifier1B {
    fn decode<'a, D>(decoder: &D, input: &'a [u8]) -> IResult<&'a [u8], Self>
    where
        D: Decoder,
        Self: Sized,
    {
        decoder
            .decode_integer(AsnInteger { constraint: Some(Constraint { min_value: Some(0), max_value: Some(255), extensible: false }), distinguished_values: None })(input)
            .map(|(remaining, res)| (remaining, Self(res)))
    }
}


/* * 
 * This DE is a general identifier.
 * 
 * @category: Basic information
 * @revision: Created in V2.1.1
*/
#[derive(Debug, Clone, PartialEq, Default)]
pub struct Identifier2B(pub u16);

impl Decode for Identifier2B {
    fn decode<'a, D>(decoder: &D, input: &'a [u8]) -> IResult<&'a [u8], Self>
    where
        D: Decoder,
        Self: Sized,
    {
        decoder
            .decode_integer(AsnInteger { constraint: Some(Constraint { min_value: Some(0), max_value: Some(65535), extensible: false }), distinguished_values: None })(input)
            .map(|(remaining, res)| (remaining, Self(res)))
    }
}


/* *
 * This DE represents the quality level of provided information.
 * 
 * The value shall be set to:
 * - `0` if the information is unavailable,
 * - `1` if the quality level is lowest,
 * - `n` (`n > 1` and `n < 7`) if the quality level is n, 
 * - `7` if the quality level is highest.
 *
 * @note: Definition of quality level is out of scope of the present document.
 * @category: Basic information
 * @revision: Editorial update in V2.1.1
 */
#[derive(Debug, Clone, PartialEq, Default)]
pub struct InformationQuality(pub u8);

impl Decode for InformationQuality {
    fn decode<'a, D>(decoder: &D, input: &'a [u8]) -> IResult<&'a [u8], Self>
    where
        D: Decoder,
        Self: Sized,
    {
        decoder
            .decode_integer(AsnInteger { constraint: Some(Constraint { min_value: Some(0), max_value: Some(7), extensible: false }), distinguished_values: None })(input)
            .map(|(remaining, res)| (remaining, Self(res)))
    }
}


/* * 
 * This DE defines the type of an interference management zone, so that an ITS-S can 
 * assert the actions to do while passing by such zone (e.g. reduce the transmit power in case of a DSRC tolling station).
 * It is an extension of the type @ref ProtectedZoneType.
 *
 * The value shall be set to:
 * - 0 - `permanentCenDsrcTolling` - as specified in ETSI TS 102 792 [14],
 * - 1 - `temporaryCenDsrcTolling` - as specified in ETSI TS 102 792 [14],
 * - 2 - `unavailable`             - default value. Set to 2 for backwards compatibility with DSRC tolling,
 * - 3 - `urbanRail`               - as specified in ETSI TS 103 724 [13], clause 7,
 * - 4 - `satelliteStation`        - as specified in ETSI TS 103 724 [13], clause 7,
 * - 5 - `fixedLinks`              - as specified in ETSI TS 103 724 [13], clause 7.
 *
 * @category: Communication information
 * @revision: Created in V2.1.1
 */
#[derive(Debug, Clone, PartialEq, Default)]
pub enum InterferenceManagementZoneType {
  #[default]
  permanentCenDsrcTolling = 0,
	temporaryCenDsrcTolling = 1,
	unavailable = 2,
	urbanRail = 3,
	satelliteStation = 4,
	fixedLinks = 5,
}

impl TryFrom<i128> for InterferenceManagementZoneType {
    type Error = DecodingError;

    fn try_from(v: i128) -> Result<Self, Self::Error> {
        match v {
            x if x == Self::permanentCenDsrcTolling as i128 => Ok(Self::permanentCenDsrcTolling),
		  x if x == Self::temporaryCenDsrcTolling as i128 => Ok(Self::temporaryCenDsrcTolling),
		  x if x == Self::unavailable as i128 => Ok(Self::unavailable),
		  x if x == Self::urbanRail as i128 => Ok(Self::urbanRail),
		  x if x == Self::satelliteStation as i128 => Ok(Self::satelliteStation),
		  x if x == Self::fixedLinks as i128 => Ok(Self::fixedLinks),
            _ => Err(
              DecodingError::new(
                &format!("Invalid enumerated index decoding InterferenceManagementZoneType. Received index {}",v), DecodingErrorType::InvalidEnumeratedIndex
              )
            ),
        }
    }
}

impl Decode for InterferenceManagementZoneType {
    fn decode<'a, D>(decoder: &D, input: &'a [u8]) -> IResult<&'a [u8], Self>
    where
        D: Decoder,
        Self: Sized,
    {
        decoder.decode_enumerated(AsnEnumerated { members: vec![Enumeral { name: "permanentCenDsrcTolling".into(), description: None, index: 0 },Enumeral { name: "temporaryCenDsrcTolling".into(), description: None, index: 1 },Enumeral { name: "unavailable".into(), description: None, index: 2 },Enumeral { name: "urbanRail".into(), description: None, index: 3 },Enumeral { name: "satelliteStation".into(), description: None, index: 4 },Enumeral { name: "fixedLinks".into(), description: None, index: 5 }], extensible: Some(6) })( 
          input
        )
    }
}


/* *
 * This DE represents the vehicle type according to ISO 3833 [22].
 * A "term No" refers to the number of the corresponding term and its definition in ISO 3833.
 *
 * The value shall be set to:
 * - 0	- `passengerCar`              - term No 3.1.1
 * - 1	- `saloon`                    - term No 3.1.1.1 (sedan)
 * - 2	- `convertibleSaloon`         - term No 3.1.1.2
 * - 3	- `pullmanSaloon`             - term No 3.1.1.3
 * - 4	- `stationWagon`              - term No 3.1.1.4
 * - 5	- `truckStationWagon`         - term No 3.1.1.4.1
 * - 6	- `coupe`                     - term No 3.1.1.5 (coupe)
 * - 7	- `convertible`               - term No 3.1.1.6 (open tourer, roadstar, spider)
 * - 8	- `multipurposePassengerCar`  - term No 3.1.1.7
 * - 9	- `forwardControlPassengerCar`- term No 3.1.1.8
 * - 10	- `specialPassengerCar`       - term No 3.1.1.9
 * - 11	- `bus`                       - term No 3.1.2
 * - 12	- `minibus`                   - term No 3.1.2.1
 * - 13	- `urbanBus`                  - term No 3.1.2.2
 * - 14	- `interurbanCoach`           - term No 3.1.2.3
 * - 15	- `longDistanceCoach`         - term No 3.1.2.4
 * - 16	- `articulatedBus`            - term No 3.1.2.5
 * - 17	- `trolleyBus	`             - term No 3.1.2.6
 * - 18	- `specialBus`                - term No 3.1.2.7
 * - 19	- `commercialVehicle`         - term No 3.1.3
 * - 20	- `specialCommercialVehicle`  - term No 3.1.3.1
 * - 21	- `specialVehicle`            - term No 3.1.4
 * - 22	- `trailingTowingVehicle`     - term No 3.1.5 (draw-bar tractor)
 * - 23	- `semiTrailerTowingVehicle`  - term No 3.1.6 (fifth wheel tractor)
 * - 24	- `trailer`                   - term No 3.2.1
 * - 25	- `busTrailer`                - term No 3.2.1.1
 * - 26	- `generalPurposeTrailer`     - term No 3.2.1.2
 * - 27	- `caravan`                   - term No 3.2.1.3
 * - 28	- `specialTrailer`            - term No 3.2.1.4
 * - 29	- `semiTrailer`               - term No 3.2.2
 * - 30	- `busSemiTrailer`            - term No 3.2.2.1
 * - 31	- `generalPurposeSemiTrailer` - term No 3.2.2.2
 * - 32	- `specialSemiTrailer`        - term No 3.2.2.3
 * - 33	- `roadTrain`                 - term No 3.3.1
 * - 34	- `passengerRoadTrain`        - term No 3.3.2
 * - 35	- `articulatedRoadTrain`      - term No 3.3.3
 * - 36	- `doubleRoadTrain`           - term No 3.3.4
 * - 37	- `compositeRoadTrain`        - term No 3.3.5
 * - 38	- `specialRoadTrain`          - term No 3.3.6
 * - 39	- `moped`                     - term No 3.4
 * - 40	- `motorCycle`                - term No 3.5
 * - 41-255                           - reserved for future use
 * 
 * @category: Vehicle information
 * @revision: Created in V2.1.1
 */
#[derive(Debug, Clone, PartialEq, Default)]
pub struct Iso3833VehicleType(pub u8);

impl Iso3833VehicleType {
  pub fn is_passengerCar(&self) -> bool { self.0 as i128 == 0 }
  pub fn is_saloon(&self) -> bool { self.0 as i128 == 1 }
  pub fn is_convertibleSaloon(&self) -> bool { self.0 as i128 == 2 }
  pub fn is_pullmanSaloon(&self) -> bool { self.0 as i128 == 3 }
  pub fn is_stationWagon(&self) -> bool { self.0 as i128 == 4 }
  pub fn is_truckStationWagon(&self) -> bool { self.0 as i128 == 5 }
  pub fn is_coupe(&self) -> bool { self.0 as i128 == 6 }
  pub fn is_convertible(&self) -> bool { self.0 as i128 == 7 }
  pub fn is_multipurposePassengerCar(&self) -> bool { self.0 as i128 == 8 }
  pub fn is_forwardControlPassengerCar(&self) -> bool { self.0 as i128 == 9 }
  pub fn is_specialPassengerCar(&self) -> bool { self.0 as i128 == 10 }
  pub fn is_bus(&self) -> bool { self.0 as i128 == 11 }
  pub fn is_minibus(&self) -> bool { self.0 as i128 == 12 }
  pub fn is_urbanBus(&self) -> bool { self.0 as i128 == 13 }
  pub fn is_interurbanCoach(&self) -> bool { self.0 as i128 == 14 }
  pub fn is_longDistanceCoach(&self) -> bool { self.0 as i128 == 15 }
  pub fn is_articulatedBus(&self) -> bool { self.0 as i128 == 16 }
  pub fn is_trolleyBus(&self) -> bool { self.0 as i128 == 17 }
  pub fn is_specialBus(&self) -> bool { self.0 as i128 == 18 }
  pub fn is_commercialVehicle(&self) -> bool { self.0 as i128 == 19 }
  pub fn is_specialCommercialVehicle(&self) -> bool { self.0 as i128 == 20 }
  pub fn is_specialVehicle(&self) -> bool { self.0 as i128 == 21 }
  pub fn is_trailingTowingVehicle(&self) -> bool { self.0 as i128 == 22 }
  pub fn is_semiTrailerTowingVehicle(&self) -> bool { self.0 as i128 == 23 }
  pub fn is_trailer(&self) -> bool { self.0 as i128 == 24 }
  pub fn is_busTrailer(&self) -> bool { self.0 as i128 == 25 }
  pub fn is_generalPurposeTrailer(&self) -> bool { self.0 as i128 == 26 }
  pub fn is_caravan(&self) -> bool { self.0 as i128 == 27 }
  pub fn is_specialTrailer(&self) -> bool { self.0 as i128 == 28 }
  pub fn is_semiTrailer(&self) -> bool { self.0 as i128 == 29 }
  pub fn is_busSemiTrailer(&self) -> bool { self.0 as i128 == 30 }
  pub fn is_generalPurposeSemiTrailer(&self) -> bool { self.0 as i128 == 31 }
  pub fn is_specialSemiTrailer(&self) -> bool { self.0 as i128 == 32 }
  pub fn is_roadTrain(&self) -> bool { self.0 as i128 == 33 }
  pub fn is_passengerRoadTrain(&self) -> bool { self.0 as i128 == 34 }
  pub fn is_articulatedRoadTrain(&self) -> bool { self.0 as i128 == 35 }
  pub fn is_doubleRoadTrain(&self) -> bool { self.0 as i128 == 36 }
  pub fn is_compositeRoadTrain(&self) -> bool { self.0 as i128 == 37 }
  pub fn is_specialRoadTrain(&self) -> bool { self.0 as i128 == 38 }
  pub fn is_moped(&self) -> bool { self.0 as i128 == 39 }
  pub fn is_motorCycle(&self) -> bool { self.0 as i128 == 40 }
}

impl Decode for Iso3833VehicleType {
    fn decode<'a, D>(decoder: &D, input: &'a [u8]) -> IResult<&'a [u8], Self>
    where
        D: Decoder,
        Self: Sized,
    {
        decoder
            .decode_integer(AsnInteger { constraint: Some(Constraint { min_value: Some(0), max_value: Some(255), extensible: false }), distinguished_values: Some(vec![DistinguishedValue { name: "passengerCar".into(), value: 0 },DistinguishedValue { name: "saloon".into(), value: 1 },DistinguishedValue { name: "convertibleSaloon".into(), value: 2 },DistinguishedValue { name: "pullmanSaloon".into(), value: 3 },DistinguishedValue { name: "stationWagon".into(), value: 4 },DistinguishedValue { name: "truckStationWagon".into(), value: 5 },DistinguishedValue { name: "coupe".into(), value: 6 },DistinguishedValue { name: "convertible".into(), value: 7 },DistinguishedValue { name: "multipurposePassengerCar".into(), value: 8 },DistinguishedValue { name: "forwardControlPassengerCar".into(), value: 9 },DistinguishedValue { name: "specialPassengerCar".into(), value: 10 },DistinguishedValue { name: "bus".into(), value: 11 },DistinguishedValue { name: "minibus".into(), value: 12 },DistinguishedValue { name: "urbanBus".into(), value: 13 },DistinguishedValue { name: "interurbanCoach".into(), value: 14 },DistinguishedValue { name: "longDistanceCoach".into(), value: 15 },DistinguishedValue { name: "articulatedBus".into(), value: 16 },DistinguishedValue { name: "trolleyBus".into(), value: 17 },DistinguishedValue { name: "specialBus".into(), value: 18 },DistinguishedValue { name: "commercialVehicle".into(), value: 19 },DistinguishedValue { name: "specialCommercialVehicle".into(), value: 20 },DistinguishedValue { name: "specialVehicle".into(), value: 21 },DistinguishedValue { name: "trailingTowingVehicle".into(), value: 22 },DistinguishedValue { name: "semiTrailerTowingVehicle".into(), value: 23 },DistinguishedValue { name: "trailer".into(), value: 24 },DistinguishedValue { name: "busTrailer".into(), value: 25 },DistinguishedValue { name: "generalPurposeTrailer".into(), value: 26 },DistinguishedValue { name: "caravan".into(), value: 27 },DistinguishedValue { name: "specialTrailer".into(), value: 28 },DistinguishedValue { name: "semiTrailer".into(), value: 29 },DistinguishedValue { name: "busSemiTrailer".into(), value: 30 },DistinguishedValue { name: "generalPurposeSemiTrailer".into(), value: 31 },DistinguishedValue { name: "specialSemiTrailer".into(), value: 32 },DistinguishedValue { name: "roadTrain".into(), value: 33 },DistinguishedValue { name: "passengerRoadTrain".into(), value: 34 },DistinguishedValue { name: "articulatedRoadTrain".into(), value: 35 },DistinguishedValue { name: "doubleRoadTrain".into(), value: 36 },DistinguishedValue { name: "compositeRoadTrain".into(), value: 37 },DistinguishedValue { name: "specialRoadTrain".into(), value: 38 },DistinguishedValue { name: "moped".into(), value: 39 },DistinguishedValue { name: "motorCycle".into(), value: 40 }]) })(input)
            .map(|(remaining, res)| (remaining, Self(res)))
    }
}


/* *
 * This DE indicates a transversal position on the carriageway at a specific longitudinal position, in resolution of lanes of the carriageway. 
 *
 * For right-hand traffic roads, the value shall be set to:
 * - `-1` if the position is off, i.e. besides the road,
 * - `0` if the position is on the inner hard shoulder, i.e. the hard should adjacent to the leftmost lane,
 * - `n` (`n > 0` and `n < 14`), if the position is on the n-th driving lane counted from the leftmost lane to the rightmost lane of a specific traffic direction,
 * - `14` if the position is on the outer hard shoulder, i.e. the hard should adjacent to rightmost lane (if present).
 *
 * For left-hand traffic roads, the value shall be set to:
 * - `-1` if the position is off, i.e. besides the road,
 * - `0` if the position is on the inner hard shoulder, i.e. the hard should adjacent to the rightmost lane,
 * - `n` (`n > 0` and `n < 14`), if the position is on the n-th driving lane counted from the rightmost lane to the leftmost lane of a specific traffic direction,
 * - `14` if the position is on the outer hard shoulder, i.e. the hard should adjacent to leftmost lane (if present).

 *  @note: in practice this means that the position is counted from "inside" to "outside" no matter which traffic practice is used.
 *
 * If the carriageway allows only traffic in one direction (e.g. in case of dual or multiple carriageway roads), the position is counted from the physical border of the carriageway. 
 * If the carriageway allows traffic in both directions and there is no physical delimitation between traffic directions (e.g. on a single carrriageway road), 
 * the position is counted from the legal (i.e. optical) separation between traffic directions (horizontal marking). 

 * @category: Road topology information
 * @revision: Description revised in V2.1.1
*/
#[derive(Debug, Clone, PartialEq, Default)]
pub struct LanePosition(pub i8);

impl LanePosition {
  pub fn is_offTheRoad(&self) -> bool { self.0 as i128 == -1 }
  pub fn is_innerHardShoulder(&self) -> bool { self.0 as i128 == 0 }
  pub fn is_outerHardShoulder(&self) -> bool { self.0 as i128 == 14 }
}

impl Decode for LanePosition {
    fn decode<'a, D>(decoder: &D, input: &'a [u8]) -> IResult<&'a [u8], Self>
    where
        D: Decoder,
        Self: Sized,
    {
        decoder
            .decode_integer(AsnInteger { constraint: Some(Constraint { min_value: Some(-1), max_value: Some(14), extensible: false }), distinguished_values: Some(vec![DistinguishedValue { name: "offTheRoad".into(), value: -1 },DistinguishedValue { name: "innerHardShoulder".into(), value: 0 },DistinguishedValue { name: "outerHardShoulder".into(), value: 14 }]) })(input)
            .map(|(remaining, res)| (remaining, Self(res)))
    }
}


/* *
 * This DE represents the type of a lane. 
 * 
 * The value shall be set to:
 * - 0	- `traffic`            - Lane dedicated to the movement of vehicles,
 * - 1	- `through`            - Lane dedicated to the movement of vehicles travelling ahead and not turning,
 * - 2	- `reversible`         - Lane where the direction of traffic can be changed to match the peak flow,
 * - 3	- `acceleration`	   - Lane that allows vehicles entering a road to accelerate to the speed of through traffic before merging with it,
 * - 4	- `deceleration`       - Lane that allows vehicles exiting a road to decelerate before leaving it,
 * - 5	- `leftHandTurning`    - Lane reserved for slowing down and making a left turn, so as not to disrupt traffic,
 * - 6	- `rightHandTurning`   - Lane reserved for slowing down and making a right turn so as not to disrupt traffic,
 * - 7	- `dedicatedVehicle`   - Lane dedicated to movement of motor vehicles with specific characteristics, such as heavy goods vehicles, etc., 
 * - 8	- `bus`                - Lane dedicated to movement of buses providing public transport,
 * - 9	- `taxi`               - Lane dedicated to movement of taxis,
 * - 10	- `hov`                - Carpooling lane or high occupancy vehicle lane,
 * - 11	- `hot`                - High occupancy vehicle lanes that is allowed to be used without meeting the occupancy criteria by paying a toll,
 * - 12	- `pedestrian`         - Lanes dedicated to pedestrians such as pedestrian sidewalk paths,
 * - 13	- `cycleLane`	       - Lane dedicated to exclusive or preferred use by bicycles,
 * - 14	- `median`             - Lane not dedicated to movement of vehicles but representing a median / central reservation  such as the central median, 
                                 separating the two directional carriageways of the highway,
 * - 15	- `striping`	       - Lane not dedicated to movement of vehicles but covered with roadway markings,
 * - 16	- `trackedVehicle`     - Lane dedicated to movement of trains, trams and trolleys,
 * - 17	- `parking`            - Lanes dedicated to vehicles parking, stopping and loading lanes,
 * - 18	- `emergency`          - Lane dedicated to vehicles in breakdown or to emergency vehicles also called hard shoulder,
 * - 19	- `verge`              - Lane representing the verge, i.e. a narrow strip of grass or plants and sometimes also trees located between 
                                 the road surface edge and the boundary of a road,
 * - 20	`minimumRiskManoeuvre` - Lane dedicated to automated vehicles making a minimum risk manoeuvre.
 * - values 21 to 30             reserved for future use. 
 *
 * @category: Road topology information
 * @revision: Created in V2.1.1
*/
#[derive(Debug, Clone, PartialEq, Default)]
pub struct LaneType(pub u8);

impl LaneType {
  pub fn is_traffic(&self) -> bool { self.0 as i128 == 0 }
  pub fn is_through(&self) -> bool { self.0 as i128 == 1 }
  pub fn is_reversible(&self) -> bool { self.0 as i128 == 2 }
  pub fn is_acceleration(&self) -> bool { self.0 as i128 == 3 }
  pub fn is_deceleration(&self) -> bool { self.0 as i128 == 4 }
  pub fn is_leftHandTurning(&self) -> bool { self.0 as i128 == 5 }
  pub fn is_rightHandTurning(&self) -> bool { self.0 as i128 == 6 }
  pub fn is_dedicatedVehicle(&self) -> bool { self.0 as i128 == 7 }
  pub fn is_bus(&self) -> bool { self.0 as i128 == 8 }
  pub fn is_taxi(&self) -> bool { self.0 as i128 == 9 }
  pub fn is_hov(&self) -> bool { self.0 as i128 == 10 }
  pub fn is_hot(&self) -> bool { self.0 as i128 == 11 }
  pub fn is_pedestrian(&self) -> bool { self.0 as i128 == 12 }
  pub fn is_cycleLane(&self) -> bool { self.0 as i128 == 13 }
  pub fn is_median(&self) -> bool { self.0 as i128 == 14 }
  pub fn is_striping(&self) -> bool { self.0 as i128 == 15 }
  pub fn is_trackedVehicle(&self) -> bool { self.0 as i128 == 16 }
  pub fn is_parking(&self) -> bool { self.0 as i128 == 17 }
  pub fn is_emergency(&self) -> bool { self.0 as i128 == 18 }
  pub fn is_verge(&self) -> bool { self.0 as i128 == 19 }
  pub fn is_minimumRiskManoeuvre(&self) -> bool { self.0 as i128 == 20 }
  pub fn is_unknown(&self) -> bool { self.0 as i128 == 31 }
}

impl Decode for LaneType {
    fn decode<'a, D>(decoder: &D, input: &'a [u8]) -> IResult<&'a [u8], Self>
    where
        D: Decoder,
        Self: Sized,
    {
        decoder
            .decode_integer(AsnInteger { constraint: Some(Constraint { min_value: Some(0), max_value: Some(31), extensible: false }), distinguished_values: Some(vec![DistinguishedValue { name: "traffic".into(), value: 0 },DistinguishedValue { name: "through".into(), value: 1 },DistinguishedValue { name: "reversible".into(), value: 2 },DistinguishedValue { name: "acceleration".into(), value: 3 },DistinguishedValue { name: "deceleration".into(), value: 4 },DistinguishedValue { name: "leftHandTurning".into(), value: 5 },DistinguishedValue { name: "rightHandTurning".into(), value: 6 },DistinguishedValue { name: "dedicatedVehicle".into(), value: 7 },DistinguishedValue { name: "bus".into(), value: 8 },DistinguishedValue { name: "taxi".into(), value: 9 },DistinguishedValue { name: "hov".into(), value: 10 },DistinguishedValue { name: "hot".into(), value: 11 },DistinguishedValue { name: "pedestrian".into(), value: 12 },DistinguishedValue { name: "cycleLane".into(), value: 13 },DistinguishedValue { name: "median".into(), value: 14 },DistinguishedValue { name: "striping".into(), value: 15 },DistinguishedValue { name: "trackedVehicle".into(), value: 16 },DistinguishedValue { name: "parking".into(), value: 17 },DistinguishedValue { name: "emergency".into(), value: 18 },DistinguishedValue { name: "verge".into(), value: 19 },DistinguishedValue { name: "minimumRiskManoeuvre".into(), value: 20 },DistinguishedValue { name: "unknown".into(), value: 31 }]) })(input)
            .map(|(remaining, res)| (remaining, Self(res)))
    }
}


/* *
 * This DE represents the width of a lane measured at a defined position.
 *
 * The value shall be set to:
 * - `n` (`n > 0` and `n < 1022`) if the lane width information is equal to or less than n x 0,01 metre and more than (n-1) x 0,01 metre,
 * - `1022` if the lane width is out of range, i.e. greater than 10,21 m,
 * - `1023` if the lane width information is not available.
 *
 * The value 0 shall not be used.
 *
 * @unit: 0,01 metre
 * @category: Road topology information
 * @revision: Created in V2.1.1
 */
#[derive(Debug, Clone, PartialEq, Default)]
pub struct LaneWidth(pub u16);

impl Decode for LaneWidth {
    fn decode<'a, D>(decoder: &D, input: &'a [u8]) -> IResult<&'a [u8], Self>
    where
        D: Decoder,
        Self: Sized,
    {
        decoder
            .decode_integer(AsnInteger { constraint: Some(Constraint { min_value: Some(0), max_value: Some(1023), extensible: false }), distinguished_values: None })(input)
            .map(|(remaining, res)| (remaining, Self(res)))
    }
}


/* *
 * This DE represents the absolute geographical latitude in a WGS84 coordinate system, providing a range of 90 degrees in north or
 * in south hemisphere.
 * The specific WGS84 coordinate system is specified by the corresponding standards applying this DE.
 *
 * The value shall be set to:
 * - `n` (`n >= -900 000 000` and `n < 0`) x 10^-7 degree, i.e. negative values for latitudes south of the Equator,
 * - `0` is used for the latitude of the equator,
 * - `n` (`n > 0` and `n < 900 000 001`) x 10^-7 degree, i.e. positive values for latitudes north of the Equator,
 * - `900 000 001` when the information is unavailable.
 *
 * @unit: 10^-7 degree
 * @category: GeoReference information
 * @revision: Editorial update in V2.1.1
 */
#[derive(Debug, Clone, PartialEq, Default)]
pub struct Latitude(pub i32);

impl Latitude {
  pub fn is_unavailable(&self) -> bool { self.0 as i128 == 900000001 }
}

impl Decode for Latitude {
    fn decode<'a, D>(decoder: &D, input: &'a [u8]) -> IResult<&'a [u8], Self>
    where
        D: Decoder,
        Self: Sized,
    {
        decoder
            .decode_integer(AsnInteger { constraint: Some(Constraint { min_value: Some(-900000000), max_value: Some(900000001), extensible: false }), distinguished_values: Some(vec![DistinguishedValue { name: "unavailable".into(), value: 900000001 }]) })(input)
            .map(|(remaining, res)| (remaining, Self(res)))
    }
}


/* *
 * This DE represents the vehicle acceleration at lateral direction in the centre of the mass of the empty vehicle.
 * It corresponds to the vehicle coordinate system as specified in ISO 8855 [21].
 *
 * The value shall be set to:
 * - `-160` for acceleration values equal to or less than -16 m/s^2,
 * - `n` (`n > -160` and `n <= 0`) to indicate that the vehicle is accelerating towards the right side with regards to the vehicle orientation 
 *                            with acceleration equal to or less than n x 0,1 m/s^2 and greater than (n-1) x 0,1 m/s^2,
 * - `n` (`n > 0` and `n < 160`) to indicate that the vehicle is accelerating towards the left hand side with regards to the vehicle orientation 
						     with acceleration equal to or less than n x 0,1 m/s^2 and greater than (n-1) x 0,1 m/s^2,
 * - `160` for acceleration values greater than 15,9 m/s^2,
 * - `161` when the data is unavailable.
 *
 * @note: the empty load vehicle is defined in ISO 1176 [8], clause 4.6.
 * @note: this DF is kept for backwards compatibility reasons only. It is recommended to use @ref AccelerationValue instead.
 *  
 * @unit: 0,1 m/s^2
 * @category: Vehicle information
 * @revision: Description updated in V2.1.1 (the meaning of 160 has changed slightly). 
 */
#[derive(Debug, Clone, PartialEq, Default)]
pub struct LateralAccelerationValue(pub i16);

impl LateralAccelerationValue {
  pub fn is_negativeOutOfRange(&self) -> bool { self.0 as i128 == -160 }
  pub fn is_positiveOutOfRange(&self) -> bool { self.0 as i128 == 160 }
  pub fn is_unavailable(&self) -> bool { self.0 as i128 == 161 }
}

impl Decode for LateralAccelerationValue {
    fn decode<'a, D>(decoder: &D, input: &'a [u8]) -> IResult<&'a [u8], Self>
    where
        D: Decoder,
        Self: Sized,
    {
        decoder
            .decode_integer(AsnInteger { constraint: Some(Constraint { min_value: Some(-160), max_value: Some(161), extensible: false }), distinguished_values: Some(vec![DistinguishedValue { name: "negativeOutOfRange".into(), value: -160 },DistinguishedValue { name: "positiveOutOfRange".into(), value: 160 },DistinguishedValue { name: "unavailable".into(), value: 161 }]) })(input)
            .map(|(remaining, res)| (remaining, Self(res)))
    }
}


/* *
 * This DE indicates the status of light bar and any sort of audible alarm system besides the horn.
 * This includes various common sirens as well as backup up beepers and other slow speed manoeuvring alerts.
 *
 * The corresponding bit shall be set to 1 under the following conditions:
 * - 0 - `lightBarActivated`      - when the light bar is activated,
 * - 1 - `sirenActivated`         - when the siren is activated.
 *
 * Otherwise, it shall be set to 0.
 *
 * @category Vehicle information
 * @revision: Editorial update in V2.1.1
 */
#[derive(Debug, Clone, PartialEq, Default)]
pub struct LightBarSirenInUse(pub Vec<bool>);

impl LightBarSirenInUse {
  pub fn is_lightBarActivated(&self) -> bool { *self.0.get(0).unwrap_or(&false) }
  pub fn is_sirenActivated(&self) -> bool { *self.0.get(1).unwrap_or(&false) }
}

impl Decode for LightBarSirenInUse {
  fn decode<'a, D>(decoder: &D, input: &'a [u8]) -> IResult<&'a [u8], Self>
  where
      D: Decoder,
      Self: Sized,
  {
      decoder
          .decode_bit_string(AsnBitString { constraint: Some(Constraint { min_value: Some(2), max_value: Some(2), extensible: false }), distinguished_values: Some(vec![DistinguishedValue { name: "lightBarActivated".into(), value: 0 },DistinguishedValue { name: "sirenActivated".into(), value: 1 }]) })(input)
          .map(|(remaining, res)| (remaining, Self(res)))
  }
}


/* *
 * This DE represents the absolute geographical longitude in a WGS84 coordinate system, providing a range of 180 degrees
 * to the east or to the west of the prime meridian.
 * The specific WGS84 coordinate system is specified by the corresponding standards applying this DE.
 *
 * The value shall be set to:
 * - `n` (`n > -1 800 000 000` and `n < 0`) x 10^-7 degree, i.e. negative values for longitudes to the west,
 * - `0` to indicate the prime meridian,
 * - `n` (`n > 0` and `n < 1 800 000 001`) x 10^-7 degree, i.e. positive values for longitudes to the east,
 * - `1 800 000 001` when the information is unavailable.
 *
 * The value -1 800 000 000 shall not be used. 
 * 
 * @unit: 10^-7 degree
 * @category: GeoReference information
 * @revision: Description revised in V2.1.1
 */
#[derive(Debug, Clone, PartialEq, Default)]
pub struct Longitude(pub i32);

impl Longitude {
  pub fn is_valueNotUsed(&self) -> bool { self.0 as i128 == -1800000000 }
  pub fn is_unavailable(&self) -> bool { self.0 as i128 == 1800000001 }
}

impl Decode for Longitude {
    fn decode<'a, D>(decoder: &D, input: &'a [u8]) -> IResult<&'a [u8], Self>
    where
        D: Decoder,
        Self: Sized,
    {
        decoder
            .decode_integer(AsnInteger { constraint: Some(Constraint { min_value: Some(-1800000000), max_value: Some(1800000001), extensible: false }), distinguished_values: Some(vec![DistinguishedValue { name: "valueNotUsed".into(), value: -1800000000 },DistinguishedValue { name: "unavailable".into(), value: 1800000001 }]) })(input)
            .map(|(remaining, res)| (remaining, Self(res)))
    }
}


/* *
 * This DE represents the vehicle acceleration at longitudinal direction in the centre of the mass of the empty vehicle.
 * The value shall be provided in the vehicle coordinate system as defined in ISO 8855 [21], clause 2.11.
 *
 * The value shall be set to:
 * - `-160` for acceleration values equal to or less than -16 m/s^2,
 * - `n` (`n > -160` and `n <= 0`) to indicate that the vehicle is braking with acceleration equal to or less than n x 0,1 m/s^2, and greater than (n-1) x 0,1 m/s^2
 * - `n` (`n > 0` and `n < 160`) to indicate that the vehicle is accelerating with acceleration equal to or less than n x 0,1 m/s^2, and greater than (n-1) x 0,1 m/s^2,
 * - `160` for acceleration values greater than 15,9 m/s^2,
 * - `161` when the data is unavailable. 
 * 
 * This acceleration is along the tangent plane of the road surface and does not include gravity components.
 * @note: this DF is kept for backwards compatibility reasons only. It is recommended to use @ref AccelerationValue instead.
 * 
 * @note: The empty load vehicle is defined in ISO 1176 [8], clause 4.6.
 * @unit: 0,1 m/s^2
 * @category: Vehicle information
 * @revision: description revised in V2.1.1 (the meaning of 160 has changed slightly). T
 */
#[derive(Debug, Clone, PartialEq, Default)]
pub struct LongitudinalAccelerationValue(pub i16);

impl LongitudinalAccelerationValue {
  pub fn is_negativeOutOfRange(&self) -> bool { self.0 as i128 == -160 }
  pub fn is_positiveOutOfRange(&self) -> bool { self.0 as i128 == 160 }
  pub fn is_unavailable(&self) -> bool { self.0 as i128 == 161 }
}

impl Decode for LongitudinalAccelerationValue {
    fn decode<'a, D>(decoder: &D, input: &'a [u8]) -> IResult<&'a [u8], Self>
    where
        D: Decoder,
        Self: Sized,
    {
        decoder
            .decode_integer(AsnInteger { constraint: Some(Constraint { min_value: Some(-160), max_value: Some(161), extensible: false }), distinguished_values: Some(vec![DistinguishedValue { name: "negativeOutOfRange".into(), value: -160 },DistinguishedValue { name: "positiveOutOfRange".into(), value: 160 },DistinguishedValue { name: "unavailable".into(), value: 161 }]) })(input)
            .map(|(remaining, res)| (remaining, Self(res)))
    }
}


/* * 
 * This DE represents the longitudinal offset of a map-matched position along a matched lane, beginning from the lane's starting point.
 * 
 * The value shall be set to:
 * - `n` (`n >= 0` and `n < 32766`) if the longitudinal offset information is equal to or less than n x 0,1 metre and more than (n-1) x 0,1 metre,
 * - `32 766` if the longitudinal offset is out of range, i.e. greater than 3276,5 m,
 * - `32 767` if the longitudinal offset information is not available. 
 *
 * @unit 0,1 metre
 * @category: GeoReference information
 * @revision: Created in V2.1.1
*/
#[derive(Debug, Clone, PartialEq, Default)]
pub struct LongitudinalLanePositionValue(pub u16);

impl LongitudinalLanePositionValue {
  pub fn is_outOfRange(&self) -> bool { self.0 as i128 == 32766 }
  pub fn is_unavailable(&self) -> bool { self.0 as i128 == 32767 }
}

impl Decode for LongitudinalLanePositionValue {
    fn decode<'a, D>(decoder: &D, input: &'a [u8]) -> IResult<&'a [u8], Self>
    where
        D: Decoder,
        Self: Sized,
    {
        decoder
            .decode_integer(AsnInteger { constraint: Some(Constraint { min_value: Some(0), max_value: Some(32767), extensible: false }), distinguished_values: Some(vec![DistinguishedValue { name: "outOfRange".into(), value: 32766 },DistinguishedValue { name: "unavailable".into(), value: 32767 }]) })(input)
            .map(|(remaining, res)| (remaining, Self(res)))
    }
}


/* * 
 * This DE indicates the longitudinal lane position confidence value which represents the estimated accuracy of longitudinal lane position measurement with a default confidence level of 95 %.
 * If required, the confidence level can be defined by the corresponding standards applying this DE.
 *
 * The value shall be set to:
 * - `n` (`n > 0` and `n < 1 022`) if the  confidence value is equal to or less than n x 0,1 m, and more than (n-1) x 0,1 m,
 * - `1 022` if the confidence value is out of range i.e. greater than 102,1 m,
 * - `1 023` if the confidence value is unavailable.
 *
 * @unit 0,1 metre
 * @category: GeoReference information
 * @revision: Created in V2.1.1
*/
#[derive(Debug, Clone, PartialEq, Default)]
pub struct LongitudinalLanePositionConfidence(pub u16);

impl LongitudinalLanePositionConfidence {
  pub fn is_outOfRange(&self) -> bool { self.0 as i128 == 1022 }
  pub fn is_unavailable(&self) -> bool { self.0 as i128 == 1023 }
}

impl Decode for LongitudinalLanePositionConfidence {
    fn decode<'a, D>(decoder: &D, input: &'a [u8]) -> IResult<&'a [u8], Self>
    where
        D: Decoder,
        Self: Sized,
    {
        decoder
            .decode_integer(AsnInteger { constraint: Some(Constraint { min_value: Some(0), max_value: Some(1023), extensible: false }), distinguished_values: Some(vec![DistinguishedValue { name: "outOfRange".into(), value: 1022 },DistinguishedValue { name: "unavailable".into(), value: 1023 }]) })(input)
            .map(|(remaining, res)| (remaining, Self(res)))
    }
}


/* *
 * This DE indicates the components of an @ref PerceivedObject that are included in the @ref LowerTriangularPositiveSemidefiniteMatrix.
 *
 * The corresponding bit shall be set to 1 if the component is included:
 * - 0 - `xCoordinate`                   - when the component xCoordinate of the component @ref CartesianPosition3dWithConfidence is included,
 * - 1 - `yCoordinate`                   - when the component yCoordinate of the component @ref CartesianPosition3dWithConfidence is included,   
 * - 2 - `zCoordinate`                   - when the component zCoordinate of the component @ref CartesianPosition3dWithConfidence is included, 
 * - 3 - `xVelocityOrVelocityMagnitude`  - when the component xVelocity of the component @ref VelocityCartesian or the component VelocityMagnitude of the component @ref VelocityPolarWithZ is included,   
 * - 4 - `yVelocityOrVelocityDirection`  - when the component yVelocity of the component @ref VelocityCartesian or the component VelocityDirection of the component @ref VelocityPolarWithZ is included,   
 * - 5 - `zVelocity`                     - when the component zVelocity of the component @ref VelocityCartesian or of the component @ref VelocityPolarWithZ is included,
 * - 6 - `xAccelOrAccelMagnitude`        - when the component xAcceleration of the component @ref AccelerationCartesian or the component AccelerationMagnitude of the component @ref AccelerationPolarWithZ is included,  
 * - 7 - `yAccelOrAccelDirection`        - when the component yAcceleration of the component @ref AccelerationCartesian or the component AccelerationDirection of the component @ref AccelerationPolarWithZ is included,   
 * - 8 - `zAcceleration`                 - when the component zAcceleration of the component @ref AccelerationCartesian or of the component @ref AccelerationPolarWithZ is included,
 * - 9 - `zAngle`                        - when the component zAngle is included,
 * - 10 - `yAngle`                       - when the component yAngle is included,   
 * - 11 - `xAngle`                       - when the component xAngle is included,   
 * - 12 - `zAngularVelocity`             - when the component zAngularVelocity is included.   
 *
 * Otherwise, it shall be set to 0.
 *
 * @category: Sensing information
 * @revision: Created in V2.1.1
 */
#[derive(Debug, Clone, PartialEq, Default)]
pub struct MatrixIncludedComponents(pub Vec<bool>);

impl MatrixIncludedComponents {
  pub fn is_xPosition(&self) -> bool { *self.0.get(0).unwrap_or(&false) }
  pub fn is_yPosition(&self) -> bool { *self.0.get(1).unwrap_or(&false) }
  pub fn is_zPosition(&self) -> bool { *self.0.get(2).unwrap_or(&false) }
  pub fn is_xVelocityOrVelocityMagnitude(&self) -> bool { *self.0.get(3).unwrap_or(&false) }
  pub fn is_yVelocityOrVelocityDirection(&self) -> bool { *self.0.get(4).unwrap_or(&false) }
  pub fn is_zSpeed(&self) -> bool { *self.0.get(5).unwrap_or(&false) }
  pub fn is_xAccelOrAccelMagnitude(&self) -> bool { *self.0.get(6).unwrap_or(&false) }
  pub fn is_yAccelOrAccelDirection(&self) -> bool { *self.0.get(7).unwrap_or(&false) }
  pub fn is_zAcceleration(&self) -> bool { *self.0.get(8).unwrap_or(&false) }
  pub fn is_zAngle(&self) -> bool { *self.0.get(9).unwrap_or(&false) }
  pub fn is_yAngle(&self) -> bool { *self.0.get(10).unwrap_or(&false) }
  pub fn is_xAngle(&self) -> bool { *self.0.get(11).unwrap_or(&false) }
  pub fn is_zAngularVelocity(&self) -> bool { *self.0.get(12).unwrap_or(&false) }
}

impl Decode for MatrixIncludedComponents {
  fn decode<'a, D>(decoder: &D, input: &'a [u8]) -> IResult<&'a [u8], Self>
  where
      D: Decoder,
      Self: Sized,
  {
      decoder
          .decode_bit_string(AsnBitString { constraint: Some(Constraint { min_value: Some(13), max_value: Some(13), extensible: true }), distinguished_values: Some(vec![DistinguishedValue { name: "xPosition".into(), value: 0 },DistinguishedValue { name: "yPosition".into(), value: 1 },DistinguishedValue { name: "zPosition".into(), value: 2 },DistinguishedValue { name: "xVelocityOrVelocityMagnitude".into(), value: 3 },DistinguishedValue { name: "yVelocityOrVelocityDirection".into(), value: 4 },DistinguishedValue { name: "zSpeed".into(), value: 5 },DistinguishedValue { name: "xAccelOrAccelMagnitude".into(), value: 6 },DistinguishedValue { name: "yAccelOrAccelDirection".into(), value: 7 },DistinguishedValue { name: "zAcceleration".into(), value: 8 },DistinguishedValue { name: "zAngle".into(), value: 9 },DistinguishedValue { name: "yAngle".into(), value: 10 },DistinguishedValue { name: "xAngle".into(), value: 11 },DistinguishedValue { name: "zAngularVelocity".into(), value: 12 }]) })(input)
          .map(|(remaining, res)| (remaining, Self(res)))
  }
}


/* * 
 * This DE represents the type of facility layer message.
 *
 *  The value shall be set to:
 *	- 1  - `denm`              - for Decentralized Environmental Notification Message (DENM) as specified in ETSI EN 302 637-3 [2],
 *  - 2  - `cam`               - for Cooperative Awareness Message (CAM) as specified in ETSI EN 302 637-2 [1],
 *  - 3  - `poi`               - for Point of Interest message as specified in ETSI TS 101 556-1 [9],
 *  - 4  - `spatem`            - for Signal Phase And Timing Extended Message (SPATEM) as specified in ETSI TS 103 301 [15],
 *  - 5  - `mapem`             - for MAP Extended Message (MAPEM) as specified in ETSI TS 103 301 [15],
 *  - 6  - `ivim`              - for in Vehicle Information Message (IVIM) as specified in ETSI TS 103 301 [15],
 *  - 7  - `ev-rsr`            - for Electric vehicle recharging spot reservation message, as defined in ETSI TS 101 556-3 [11],
 *  - 8  - `tistpgtransaction` - for messages for Tyre Information System (TIS) and Tyre Pressure Gauge (TPG) interoperability, as specified in ETSI TS 101 556-2 [10],
 *  - 9  - `srem`              - for Signal Request Extended Message as specified in ETSI TS 103 301 [15],
 *  - 10 - `ssem`              - for Signal request Status Extended Message as specified in ETSI TS 103 301 [15],
 *  - 11 - `evcsn`             - for Electrical Vehicle Charging Spot Notification message as specified in ETSI TS 101 556-1 [9],
 *  - 12 - `saem`              - for Services Announcement Extended Message as specified in ETSI EN 302 890-1 [17],
 *  - 13 - `rtcmem`            - for Radio Technical Commission for Maritime Services Extended Message (RTCMEM) as specified in ETSI TS 103 301 [15],
 *  - 14 - `cpm`               - reserved for Collective Perception Message (CPM), 
 *  - 15 - `imzm`              - for Interference Management Zone Message (IMZM) as specified in ETSI TS 103 724 [13],
 *  - 16 - `vam`               - for Vulnerable Road User Awareness Message as specified in ETSI TS 130 300-3 [12], 
 *  - 17 - `dsm`               - reserved for Diagnosis, logging and Status Message,
 *  - 18 - `pcim`              - reserved for Parking Control Infrastructure Message,
 *  - 19 - `pcvm`              - reserved for Parking Control Vehicle Message,
 *  - 20 - `mcm`               - reserved for Manoeuvre Coordination Message,
 *  - 21 - `pam`               - reserved for Parking Availability Message,
 *  - 22-255                   - reserved for future usage.
 *
 * @category: Communication information
 * @revision: Created in V2.1.1 from @ref ItsPduHeader.
 */
#[derive(Debug, Clone, PartialEq, Default)]
pub struct MessageId(pub u8);

impl MessageId {
  pub fn is_denm(&self) -> bool { self.0 as i128 == 1 }
  pub fn is_cam(&self) -> bool { self.0 as i128 == 2 }
  pub fn is_poi(&self) -> bool { self.0 as i128 == 3 }
  pub fn is_spatem(&self) -> bool { self.0 as i128 == 4 }
  pub fn is_mapem(&self) -> bool { self.0 as i128 == 5 }
  pub fn is_ivim(&self) -> bool { self.0 as i128 == 6 }
  pub fn is_ev_rsr(&self) -> bool { self.0 as i128 == 7 }
  pub fn is_tistpgtransaction(&self) -> bool { self.0 as i128 == 8 }
  pub fn is_srem(&self) -> bool { self.0 as i128 == 9 }
  pub fn is_ssem(&self) -> bool { self.0 as i128 == 10 }
  pub fn is_evcsn(&self) -> bool { self.0 as i128 == 11 }
  pub fn is_saem(&self) -> bool { self.0 as i128 == 12 }
  pub fn is_rtcmem(&self) -> bool { self.0 as i128 == 13 }
  pub fn is_cpm(&self) -> bool { self.0 as i128 == 14 }
  pub fn is_imzm(&self) -> bool { self.0 as i128 == 15 }
  pub fn is_vam(&self) -> bool { self.0 as i128 == 16 }
  pub fn is_dsm(&self) -> bool { self.0 as i128 == 17 }
  pub fn is_pcim(&self) -> bool { self.0 as i128 == 18 }
  pub fn is_pcvm(&self) -> bool { self.0 as i128 == 19 }
  pub fn is_mcm(&self) -> bool { self.0 as i128 == 20 }
  pub fn is_pam(&self) -> bool { self.0 as i128 == 21 }
}

impl Decode for MessageId {
    fn decode<'a, D>(decoder: &D, input: &'a [u8]) -> IResult<&'a [u8], Self>
    where
        D: Decoder,
        Self: Sized,
    {
        decoder
            .decode_integer(AsnInteger { constraint: Some(Constraint { min_value: Some(0), max_value: Some(255), extensible: false }), distinguished_values: Some(vec![DistinguishedValue { name: "denm".into(), value: 1 },DistinguishedValue { name: "cam".into(), value: 2 },DistinguishedValue { name: "poi".into(), value: 3 },DistinguishedValue { name: "spatem".into(), value: 4 },DistinguishedValue { name: "mapem".into(), value: 5 },DistinguishedValue { name: "ivim".into(), value: 6 },DistinguishedValue { name: "ev-rsr".into(), value: 7 },DistinguishedValue { name: "tistpgtransaction".into(), value: 8 },DistinguishedValue { name: "srem".into(), value: 9 },DistinguishedValue { name: "ssem".into(), value: 10 },DistinguishedValue { name: "evcsn".into(), value: 11 },DistinguishedValue { name: "saem".into(), value: 12 },DistinguishedValue { name: "rtcmem".into(), value: 13 },DistinguishedValue { name: "cpm".into(), value: 14 },DistinguishedValue { name: "imzm".into(), value: 15 },DistinguishedValue { name: "vam".into(), value: 16 },DistinguishedValue { name: "dsm".into(), value: 17 },DistinguishedValue { name: "pcim".into(), value: 18 },DistinguishedValue { name: "pcvm".into(), value: 19 },DistinguishedValue { name: "mcm".into(), value: 20 },DistinguishedValue { name: "pam".into(), value: 21 }]) })(input)
            .map(|(remaining, res)| (remaining, Self(res)))
    }
}


/* *
 * This DE represents the number of occupants in a vehicle.
 *
 * The value shall be set to:
 * - `n` (`n >= 0` and `n < 126`) for the number n of occupants,
 * - `126` for values equal to or higher than 125,
 * - `127` if information is not available.
 *
 * @unit: 1 person
 * @category: Vehicle information
 * @revision: Editorial update in V2.1.1
 */
#[derive(Debug, Clone, PartialEq, Default)]
pub struct NumberOfOccupants(pub u8);

impl NumberOfOccupants {
  pub fn is_outOfRange(&self) -> bool { self.0 as i128 == 126 }
  pub fn is_unavailable(&self) -> bool { self.0 as i128 == 127 }
}

impl Decode for NumberOfOccupants {
    fn decode<'a, D>(decoder: &D, input: &'a [u8]) -> IResult<&'a [u8], Self>
    where
        D: Decoder,
        Self: Sized,
    {
        decoder
            .decode_integer(AsnInteger { constraint: Some(Constraint { min_value: Some(0), max_value: Some(127), extensible: false }), distinguished_values: Some(vec![DistinguishedValue { name: "outOfRange".into(), value: 126 },DistinguishedValue { name: "unavailable".into(), value: 127 }]) })(input)
            .map(|(remaining, res)| (remaining, Self(res)))
    }
}


/* * 
 * This DE represents a single-value indication about the overall information quality of a perceived object.
 * 
 * The value shall be set to:  
 * - `0`                        : if there is no confidence in detected object, e.g. for "ghost"-objects or if confidence could not be computed,
 * - `n` (`n > 0` and `n < 15`) : for the applicable confidence value,
 * - `15`                       : if there is full confidence in the detected Object.
 * 
 * @unit n/a
 * @category: Sensing information
 * @revision: Created in V2.1.1 
*/
#[derive(Debug, Clone, PartialEq, Default)]
pub struct ObjectPerceptionQuality(pub u8);

impl ObjectPerceptionQuality {
  pub fn is_noConfidence(&self) -> bool { self.0 as i128 == 0 }
  pub fn is_fullConfidence(&self) -> bool { self.0 as i128 == 15 }
}

impl Decode for ObjectPerceptionQuality {
    fn decode<'a, D>(decoder: &D, input: &'a [u8]) -> IResult<&'a [u8], Self>
    where
        D: Decoder,
        Self: Sized,
    {
        decoder
            .decode_integer(AsnInteger { constraint: Some(Constraint { min_value: Some(0), max_value: Some(15), extensible: false }), distinguished_values: Some(vec![DistinguishedValue { name: "noConfidence".into(), value: 0 },DistinguishedValue { name: "fullConfidence".into(), value: 15 }]) })(input)
            .map(|(remaining, res)| (remaining, Self(res)))
    }
}


/* * 
 * This DE represents a single dimension of an object.
 *
 * The value shall be set to:
 * - `n` (`n > 0` and `n < 255`) if the  accuracy is equal to or less than n x 0,1 m, and more than (n-1) x 0,1 m,
 * - `255` if the accuracy is out of range i.e. greater than 25,4 m,
 * - `256` if the data is unavailable.
 *
 * @unit 0,1 m
 * @category: Basic information
 * @revision: Created in V2.1.1 
*/
#[derive(Debug, Clone, PartialEq, Default)]
pub struct ObjectDimensionValue(pub u8);

impl ObjectDimensionValue {
  pub fn is_outOfRange(&self) -> bool { self.0 as i128 == 255 }
  pub fn is_unavailable(&self) -> bool { self.0 as i128 == 256 }
}

impl Decode for ObjectDimensionValue {
    fn decode<'a, D>(decoder: &D, input: &'a [u8]) -> IResult<&'a [u8], Self>
    where
        D: Decoder,
        Self: Sized,
    {
        decoder
            .decode_integer(AsnInteger { constraint: Some(Constraint { min_value: Some(1), max_value: Some(256), extensible: false }), distinguished_values: Some(vec![DistinguishedValue { name: "outOfRange".into(), value: 255 },DistinguishedValue { name: "unavailable".into(), value: 256 }]) })(input)
            .map(|(remaining, res)| (remaining, Self(res)))
    }
}


/* * 
 * This DE indicates the object dimension confidence value which represents the estimated absolute accuracy of an object dimension value with a default confidence level of 95 %.
 * If required, the confidence level can be defined by the corresponding standards applying this DE.
 *
 * The value shall be set to:
 * - `n` (`n > 0` and `n < 31`) if the confidence value is equal to or less than n x 0,1 metre, and more than (n-1) x 0,1 metre,
 * - `31` if the confidence value is out of range i.e. greater than 3,0 m,
 * - `32` if the confidence value is unavailable.
 *
 * @unit 0,1 m
 * @category: Sensing information
 * @revision: Created in V2.1.1 
*/
#[derive(Debug, Clone, PartialEq, Default)]
pub struct ObjectDimensionConfidence(pub u8);

impl ObjectDimensionConfidence {
  pub fn is_outOfRange(&self) -> bool { self.0 as i128 == 31 }
  pub fn is_unavailable(&self) -> bool { self.0 as i128 == 32 }
}

impl Decode for ObjectDimensionConfidence {
    fn decode<'a, D>(decoder: &D, input: &'a [u8]) -> IResult<&'a [u8], Self>
    where
        D: Decoder,
        Self: Sized,
    {
        decoder
            .decode_integer(AsnInteger { constraint: Some(Constraint { min_value: Some(1), max_value: Some(32), extensible: false }), distinguished_values: Some(vec![DistinguishedValue { name: "outOfRange".into(), value: 31 },DistinguishedValue { name: "unavailable".into(), value: 32 }]) })(input)
            .map(|(remaining, res)| (remaining, Self(res)))
    }
}


/* *
 * This DE indicates the face or part of a face of a solid object.
 *
 * The object is modelled  as a rectangular prism that has a length that is greater than its width, with the faces of the object being defined as:
 * - front: the face defined by the prism's width and height, and which is the first face in direction of longitudinal movement of the object,
 * - back: the face defined by the prism's width and height, and which is the last face in direction of longitudinal movement of the object,
 * - side: the faces defined by the prism's length and height with "left" and "right" defined by looking at the front face and "front" and "back" defined w.r.t to the front and back faces. 
 *
 * Note: It is permissible to derive the required object dimensions and orientation from models to provide a best guess.
 * 
 * @category: Basic information
 * @revision: V2.1.1
*/
#[derive(Debug, Clone, PartialEq, Default)]
pub enum ObjectFace {
  #[default]
  front = 0,
	sideLeftFront = 1,
	sideLeftBack = 2,
	sideRightFront = 3,
	sideRightBack = 4,
	back = 5,
}

impl TryFrom<i128> for ObjectFace {
    type Error = DecodingError;

    fn try_from(v: i128) -> Result<Self, Self::Error> {
        match v {
            x if x == Self::front as i128 => Ok(Self::front),
		  x if x == Self::sideLeftFront as i128 => Ok(Self::sideLeftFront),
		  x if x == Self::sideLeftBack as i128 => Ok(Self::sideLeftBack),
		  x if x == Self::sideRightFront as i128 => Ok(Self::sideRightFront),
		  x if x == Self::sideRightBack as i128 => Ok(Self::sideRightBack),
		  x if x == Self::back as i128 => Ok(Self::back),
            _ => Err(
              DecodingError::new(
                &format!("Invalid enumerated index decoding ObjectFace. Received index {}",v), DecodingErrorType::InvalidEnumeratedIndex
              )
            ),
        }
    }
}

impl Decode for ObjectFace {
    fn decode<'a, D>(decoder: &D, input: &'a [u8]) -> IResult<&'a [u8], Self>
    where
        D: Decoder,
        Self: Sized,
    {
        decoder.decode_enumerated(AsnEnumerated { members: vec![Enumeral { name: "front".into(), description: None, index: 0 },Enumeral { name: "sideLeftFront".into(), description: None, index: 1 },Enumeral { name: "sideLeftBack".into(), description: None, index: 2 },Enumeral { name: "sideRightFront".into(), description: None, index: 3 },Enumeral { name: "sideRightBack".into(), description: None, index: 4 },Enumeral { name: "back".into(), description: None, index: 5 }], extensible: None })( 
          input
        )
    }
}


/* *
 * This DE represents a time period to describe the opening days and hours of a Point of Interest.
 * (for example local commerce).
 *
 * @category: Basic information
 * @revision: V1.3.1
 */
#[derive(Debug, Clone, PartialEq, Default)]
pub struct OpeningDaysHours(pub String);

impl Decode for OpeningDaysHours {
fn decode<'a, D>(decoder: &D, input: &'a [u8]) -> IResult<&'a [u8], Self>
where
    D: Decoder,
    Self: Sized,
{
    decoder
        .decode_character_string(AsnCharacterString { constraint: None, r#type: CharacterStringType::UTF8String })(input)
        .map(|(remaining, res)| (remaining, Self(res)))
}
}


/* *
 * The DE represents an ordinal number that indicates the position of an element in a set. 
 * 
 * @category: Basic information
 * @revision: Created in V2.1.1
*/
#[derive(Debug, Clone, PartialEq, Default)]
pub struct OrdinalNumber1B(pub u8);

impl Decode for OrdinalNumber1B {
    fn decode<'a, D>(decoder: &D, input: &'a [u8]) -> IResult<&'a [u8], Self>
    where
        D: Decoder,
        Self: Sized,
    {
        decoder
            .decode_integer(AsnInteger { constraint: Some(Constraint { min_value: Some(0), max_value: Some(255), extensible: false }), distinguished_values: None })(input)
            .map(|(remaining, res)| (remaining, Self(res)))
    }
}


/* *
 * The DE represents an ordinal number that indicates the position of an element in a set. 
 * 
 * @category: Basic information
 * @revision: Created in V2.1.1
*/
#[derive(Debug, Clone, PartialEq, Default)]
pub struct OrdinalNumber3b(pub u8);

impl Decode for OrdinalNumber3b {
    fn decode<'a, D>(decoder: &D, input: &'a [u8]) -> IResult<&'a [u8], Self>
    where
        D: Decoder,
        Self: Sized,
    {
        decoder
            .decode_integer(AsnInteger { constraint: Some(Constraint { min_value: Some(1), max_value: Some(8), extensible: false }), distinguished_values: None })(input)
            .map(|(remaining, res)| (remaining, Self(res)))
    }
}


/* * 
 * This DE indicates the subclass of a detected object for @ref ObjectClass "otherSubclass".
 *
 * The value shall be set to:
 * - `0` - unknown          - if the subclass is unknown.
 * - `1` - singleObject     - if the object is a single object.
 * - `2` - multipleObjects  - if the object is a group of multiple objects.
 * - `3` - bulkMaterial     - if the object is a bulk material.
 *
 * @category: Sensing information
 * @revision: Created in V2.1.1
 */
#[derive(Debug, Clone, PartialEq, Default)]
pub struct OtherSubClass(pub u8);

impl OtherSubClass {
  pub fn is_unknown(&self) -> bool { self.0 as i128 == 0 }
  pub fn is_singleObject(&self) -> bool { self.0 as i128 == 1 }
  pub fn is_multipleObjects(&self) -> bool { self.0 as i128 == 2 }
  pub fn is_bulkMaterial(&self) -> bool { self.0 as i128 == 3 }
}

impl Decode for OtherSubClass {
    fn decode<'a, D>(decoder: &D, input: &'a [u8]) -> IResult<&'a [u8], Self>
    where
        D: Decoder,
        Self: Sized,
    {
        decoder
            .decode_integer(AsnInteger { constraint: Some(Constraint { min_value: Some(0), max_value: Some(255), extensible: false }), distinguished_values: Some(vec![DistinguishedValue { name: "unknown".into(), value: 0 },DistinguishedValue { name: "singleObject".into(), value: 1 },DistinguishedValue { name: "multipleObjects".into(), value: 2 },DistinguishedValue { name: "bulkMaterial".into(), value: 3 }]) })(input)
            .map(|(remaining, res)| (remaining, Self(res)))
    }
}


/* *
 * This DE represents the recorded or estimated travel time between a position and a predefined reference position. 
 *
 * @unit 0,01 second
 * @category: GeoReference information
 * @revision: V1.3.1
 */
#[derive(Debug, Clone, PartialEq, Default)]
pub struct PathDeltaTime(pub u16);

impl Decode for PathDeltaTime {
    fn decode<'a, D>(decoder: &D, input: &'a [u8]) -> IResult<&'a [u8], Self>
    where
        D: Decoder,
        Self: Sized,
    {
        decoder
            .decode_integer(AsnInteger { constraint: Some(Constraint { min_value: Some(1), max_value: Some(65535), extensible: true }), distinguished_values: None })(input)
            .map(|(remaining, res)| (remaining, Self(res)))
    }
}


/* *
 * This DE denotes the ability of an ITS-S to provide up-to-date information.
 * A performance class value is used to describe age of data. The exact values are out of scope of the present document.
 * 
 *  The value shall be set to:
 * - `0` if  the performance class is unknown,
 * - `1` for performance class A as defined in ETSI TS 101 539-1 [5],
 * - `2` for performance class B as defined in ETSI TS 101 539-1 [5],
 * -  3-7 reserved for future use.
 *
 * @category: Vehicle information
 * @revision: Editorial update in V2.1.1
 */
#[derive(Debug, Clone, PartialEq, Default)]
pub struct PerformanceClass(pub u8);

impl PerformanceClass {
  pub fn is_unavailable(&self) -> bool { self.0 as i128 == 0 }
  pub fn is_performanceClassA(&self) -> bool { self.0 as i128 == 1 }
  pub fn is_performanceClassB(&self) -> bool { self.0 as i128 == 2 }
}

impl Decode for PerformanceClass {
    fn decode<'a, D>(decoder: &D, input: &'a [u8]) -> IResult<&'a [u8], Self>
    where
        D: Decoder,
        Self: Sized,
    {
        decoder
            .decode_integer(AsnInteger { constraint: Some(Constraint { min_value: Some(0), max_value: Some(7), extensible: false }), distinguished_values: Some(vec![DistinguishedValue { name: "unavailable".into(), value: 0 },DistinguishedValue { name: "performanceClassA".into(), value: 1 },DistinguishedValue { name: "performanceClassB".into(), value: 2 }]) })(input)
            .map(|(remaining, res)| (remaining, Self(res)))
    }
}


/* *
 * This DE indicates the perpendicular distance from the centre of mass of an empty load vehicle to the front line of
 * the vehicle bounding box of the empty load vehicle.
 *
 * The value shall be set to:
 * - `n` (`n > 0` and `n < 62`) for any aplicable value n between 0,1 metre and 6,2 metres, 
 * - `62` for values equal to or higher than 6.1 metres,
 * - `63`  if the information is unavailable.
 * 
 * @note:	The empty load vehicle is defined in ISO 1176 [8], clause 4.6.
 *
 * @unit 0,1 metre 
 * @category Vehicle information
 * @revision: description revised in V2.1.1 (the meaning of 62 has changed slightly) 
 */
#[derive(Debug, Clone, PartialEq, Default)]
pub struct PosCentMass(pub u8);

impl PosCentMass {
  pub fn is_tenCentimetres(&self) -> bool { self.0 as i128 == 1 }
  pub fn is_outOfRange(&self) -> bool { self.0 as i128 == 62 }
  pub fn is_unavailable(&self) -> bool { self.0 as i128 == 63 }
}

impl Decode for PosCentMass {
    fn decode<'a, D>(decoder: &D, input: &'a [u8]) -> IResult<&'a [u8], Self>
    where
        D: Decoder,
        Self: Sized,
    {
        decoder
            .decode_integer(AsnInteger { constraint: Some(Constraint { min_value: Some(1), max_value: Some(63), extensible: false }), distinguished_values: Some(vec![DistinguishedValue { name: "tenCentimetres".into(), value: 1 },DistinguishedValue { name: "outOfRange".into(), value: 62 },DistinguishedValue { name: "unavailable".into(), value: 63 }]) })(input)
            .map(|(remaining, res)| (remaining, Self(res)))
    }
}


/* *
 * This DE indicates the positioning technology being used to estimate a geographical position.
 *
 * The value shall be set to:
 * - 0 `noPositioningSolution`  - no positioning solution used,
 * - 1 `sGNSS`                  - Global Navigation Satellite System used,
 * - 2 `dGNSS`                  - Differential GNSS used,
 * - 3 `sGNSSplusDR`            - GNSS and dead reckoning used,
 * - 4 `dGNSSplusDR`            - Differential GNSS and dead reckoning used,
 * - 5 `dR`                     - dead reckoning used.
 *
 * @category: GeoReference information
 * @revision: V1.3.1
 */
#[derive(Debug, Clone, PartialEq, Default)]
pub enum PositioningSolutionType {
  #[default]
  noPositioningSolution = 0,
	sGNSS = 1,
	dGNSS = 2,
	sGNSSplusDR = 3,
	dGNSSplusDR = 4,
	dR = 5,
}

impl TryFrom<i128> for PositioningSolutionType {
    type Error = DecodingError;

    fn try_from(v: i128) -> Result<Self, Self::Error> {
        match v {
            x if x == Self::noPositioningSolution as i128 => Ok(Self::noPositioningSolution),
		  x if x == Self::sGNSS as i128 => Ok(Self::sGNSS),
		  x if x == Self::dGNSS as i128 => Ok(Self::dGNSS),
		  x if x == Self::sGNSSplusDR as i128 => Ok(Self::sGNSSplusDR),
		  x if x == Self::dGNSSplusDR as i128 => Ok(Self::dGNSSplusDR),
		  x if x == Self::dR as i128 => Ok(Self::dR),
            _ => Err(
              DecodingError::new(
                &format!("Invalid enumerated index decoding PositioningSolutionType. Received index {}",v), DecodingErrorType::InvalidEnumeratedIndex
              )
            ),
        }
    }
}

impl Decode for PositioningSolutionType {
    fn decode<'a, D>(decoder: &D, input: &'a [u8]) -> IResult<&'a [u8], Self>
    where
        D: Decoder,
        Self: Sized,
    {
        decoder.decode_enumerated(AsnEnumerated { members: vec![Enumeral { name: "noPositioningSolution".into(), description: None, index: 0 },Enumeral { name: "sGNSS".into(), description: None, index: 1 },Enumeral { name: "dGNSS".into(), description: None, index: 2 },Enumeral { name: "sGNSSplusDR".into(), description: None, index: 3 },Enumeral { name: "dGNSSplusDR".into(), description: None, index: 4 },Enumeral { name: "dR".into(), description: None, index: 5 }], extensible: Some(6) })( 
          input
        )
    }
}


/* *
 * This DE indicates whether a passenger seat is occupied or whether the occupation status is detectable or not.
 * 
 * The number of row in vehicle seats layout is counted in rows from the driver row backwards from front to the rear
 * of the vehicle.
 * The left side seat of a row refers to the left hand side seen from vehicle rear to front.
 * Additionally, a bit is reserved for each seat row, to indicate if the seat occupation of a row is detectable or not,
 * i.e. `row1NotDetectable (3)`, `row2NotDetectable(8)`, `row3NotDetectable(13)` and `row4NotDetectable(18)`.
 * Finally, a bit is reserved for each row seat to indicate if the seat row is present or not in the vehicle,
 * i.e. `row1NotPresent (4)`, `row2NotPresent (9)`, `row3NotPresent(14)`, `row4NotPresent(19)`.
 * 
 * When a seat is detected to be occupied, the corresponding seat occupation bit shall be set to `1`.
 * For example, when the row 1 left seat is occupied, `row1LeftOccupied(0)` bit shall be set to `1`.
 * When a seat is detected to be not occupied, the corresponding seat occupation bit shall be set to `0`.
 * Otherwise, the value of seat occupation bit shall be set according to the following conditions:
 * - If the seat occupation of a seat row is not detectable, the corresponding bit shall be set to `1`.
 *   When any seat row not detectable bit is set to `1`, all corresponding seat occupation bits of the same row
 *   shall be set to `1`.
 * - If the seat row is not present, the corresponding not present bit of the same row shall be set to `1`.
 *   When any of the seat row not present bit is set to `1`, the corresponding not detectable bit for that row
 *   shall be set to `1`, and all the corresponding seat occupation bits in that row shall be set to `0`.
 * 
 * @category: Vehicle information
 * @revision: V1.3.1
 */
#[derive(Debug, Clone, PartialEq, Default)]
pub struct PositionOfOccupants(pub Vec<bool>);

impl PositionOfOccupants {
  pub fn is_row1LeftOccupied(&self) -> bool { *self.0.get(0).unwrap_or(&false) }
  pub fn is_row1RightOccupied(&self) -> bool { *self.0.get(1).unwrap_or(&false) }
  pub fn is_row1MidOccupied(&self) -> bool { *self.0.get(2).unwrap_or(&false) }
  pub fn is_row1NotDetectable(&self) -> bool { *self.0.get(3).unwrap_or(&false) }
  pub fn is_row1NotPresent(&self) -> bool { *self.0.get(4).unwrap_or(&false) }
  pub fn is_row2LeftOccupied(&self) -> bool { *self.0.get(5).unwrap_or(&false) }
  pub fn is_row2RightOccupied(&self) -> bool { *self.0.get(6).unwrap_or(&false) }
  pub fn is_row2MidOccupied(&self) -> bool { *self.0.get(7).unwrap_or(&false) }
  pub fn is_row2NotDetectable(&self) -> bool { *self.0.get(8).unwrap_or(&false) }
  pub fn is_row2NotPresent(&self) -> bool { *self.0.get(9).unwrap_or(&false) }
  pub fn is_row3LeftOccupied(&self) -> bool { *self.0.get(10).unwrap_or(&false) }
  pub fn is_row3RightOccupied(&self) -> bool { *self.0.get(11).unwrap_or(&false) }
  pub fn is_row3MidOccupied(&self) -> bool { *self.0.get(12).unwrap_or(&false) }
  pub fn is_row3NotDetectable(&self) -> bool { *self.0.get(13).unwrap_or(&false) }
  pub fn is_row3NotPresent(&self) -> bool { *self.0.get(14).unwrap_or(&false) }
  pub fn is_row4LeftOccupied(&self) -> bool { *self.0.get(15).unwrap_or(&false) }
  pub fn is_row4RightOccupied(&self) -> bool { *self.0.get(16).unwrap_or(&false) }
  pub fn is_row4MidOccupied(&self) -> bool { *self.0.get(17).unwrap_or(&false) }
  pub fn is_row4NotDetectable(&self) -> bool { *self.0.get(18).unwrap_or(&false) }
  pub fn is_row4NotPresent(&self) -> bool { *self.0.get(19).unwrap_or(&false) }
}

impl Decode for PositionOfOccupants {
  fn decode<'a, D>(decoder: &D, input: &'a [u8]) -> IResult<&'a [u8], Self>
  where
      D: Decoder,
      Self: Sized,
  {
      decoder
          .decode_bit_string(AsnBitString { constraint: Some(Constraint { min_value: Some(20), max_value: Some(20), extensible: false }), distinguished_values: Some(vec![DistinguishedValue { name: "row1LeftOccupied".into(), value: 0 },DistinguishedValue { name: "row1RightOccupied".into(), value: 1 },DistinguishedValue { name: "row1MidOccupied".into(), value: 2 },DistinguishedValue { name: "row1NotDetectable".into(), value: 3 },DistinguishedValue { name: "row1NotPresent".into(), value: 4 },DistinguishedValue { name: "row2LeftOccupied".into(), value: 5 },DistinguishedValue { name: "row2RightOccupied".into(), value: 6 },DistinguishedValue { name: "row2MidOccupied".into(), value: 7 },DistinguishedValue { name: "row2NotDetectable".into(), value: 8 },DistinguishedValue { name: "row2NotPresent".into(), value: 9 },DistinguishedValue { name: "row3LeftOccupied".into(), value: 10 },DistinguishedValue { name: "row3RightOccupied".into(), value: 11 },DistinguishedValue { name: "row3MidOccupied".into(), value: 12 },DistinguishedValue { name: "row3NotDetectable".into(), value: 13 },DistinguishedValue { name: "row3NotPresent".into(), value: 14 },DistinguishedValue { name: "row4LeftOccupied".into(), value: 15 },DistinguishedValue { name: "row4RightOccupied".into(), value: 16 },DistinguishedValue { name: "row4MidOccupied".into(), value: 17 },DistinguishedValue { name: "row4NotDetectable".into(), value: 18 },DistinguishedValue { name: "row4NotPresent".into(), value: 19 }]) })(input)
          .map(|(remaining, res)| (remaining, Self(res)))
  }
}


/* *
 * This DE indicates the perpendicular distance between the vehicle front line of the bounding box and the front wheel axle in 0,1 metre.
 *
 * The value shall be set to:
 * - `n` (`n > 0` and `n < 19`) for any aplicable value between 0,1 metre and 1,9 metres,
 * - `19` for values equal to or higher than 1.8 metres,
 * - `20` if the information is unavailable.
 *
 * @category: Vehicle information
 * @unit 0,1 metre
 * @revision: description revised in V2.1.1 (the meaning of 19 has changed slightly) 
 */
#[derive(Debug, Clone, PartialEq, Default)]
pub struct PosFrontAx(pub u8);

impl PosFrontAx {
  pub fn is_outOfRange(&self) -> bool { self.0 as i128 == 19 }
  pub fn is_unavailable(&self) -> bool { self.0 as i128 == 20 }
}

impl Decode for PosFrontAx {
    fn decode<'a, D>(decoder: &D, input: &'a [u8]) -> IResult<&'a [u8], Self>
    where
        D: Decoder,
        Self: Sized,
    {
        decoder
            .decode_integer(AsnInteger { constraint: Some(Constraint { min_value: Some(1), max_value: Some(20), extensible: false }), distinguished_values: Some(vec![DistinguishedValue { name: "outOfRange".into(), value: 19 },DistinguishedValue { name: "unavailable".into(), value: 20 }]) })(input)
            .map(|(remaining, res)| (remaining, Self(res)))
    }
}


/* *
 * This DE represents the distance from the centre of vehicle front bumper to the right or left longitudinal carrier of vehicle.
 * The left/right carrier refers to the left/right as seen from a passenger sitting in the vehicle.
 *
 * The value shall be set to:
 * - `n` (`n > 0` and `n < 126`) for any aplicable value between 0,01 metre and 1,26 metres, 
 * - `126` for values equal to or higher than 1.25 metres,
 * - `127` if the information is unavailable.
 *
 * @unit 0,01 metre 
 * @category Vehicle information
 * @revision: description revised in V2.1.1 (the meaning of 126 has changed slightly) 
 */
#[derive(Debug, Clone, PartialEq, Default)]
pub struct PosLonCarr(pub u8);

impl PosLonCarr {
  pub fn is_outOfRange(&self) -> bool { self.0 as i128 == 126 }
  pub fn is_unavailable(&self) -> bool { self.0 as i128 == 127 }
}

impl Decode for PosLonCarr {
    fn decode<'a, D>(decoder: &D, input: &'a [u8]) -> IResult<&'a [u8], Self>
    where
        D: Decoder,
        Self: Sized,
    {
        decoder
            .decode_integer(AsnInteger { constraint: Some(Constraint { min_value: Some(1), max_value: Some(127), extensible: false }), distinguished_values: Some(vec![DistinguishedValue { name: "outOfRange".into(), value: 126 },DistinguishedValue { name: "unavailable".into(), value: 127 }]) })(input)
            .map(|(remaining, res)| (remaining, Self(res)))
    }
}


/* *
 * This DE represents the perpendicular inter-distance of neighbouring pillar axis of vehicle starting from the
 * middle point of the front line of the vehicle bounding box.
 *
 * The value shall be set to:
 * - `n` (`n > 0` and `n < 29`) for any aplicable value between 0,1 metre and 2,9 metres, 
 * - `29` for values equal to or greater than 2.8 metres,
 * - `30` if the information is unavailable.
 * 
 * @unit 0,1 metre 
 * @category Vehicle information
 * @revision: description revised in V2.1.1 (the meaning of 29 has changed slightly) 
 */
#[derive(Debug, Clone, PartialEq, Default)]
pub struct PosPillar(pub u8);

impl PosPillar {
  pub fn is_outOfRange(&self) -> bool { self.0 as i128 == 29 }
  pub fn is_unavailable(&self) -> bool { self.0 as i128 == 30 }
}

impl Decode for PosPillar {
    fn decode<'a, D>(decoder: &D, input: &'a [u8]) -> IResult<&'a [u8], Self>
    where
        D: Decoder,
        Self: Sized,
    {
        decoder
            .decode_integer(AsnInteger { constraint: Some(Constraint { min_value: Some(1), max_value: Some(30), extensible: false }), distinguished_values: Some(vec![DistinguishedValue { name: "outOfRange".into(), value: 29 },DistinguishedValue { name: "unavailable".into(), value: 30 }]) })(input)
            .map(|(remaining, res)| (remaining, Self(res)))
    }
}


/* *
 * This DE represents the value of the sub cause codes of the @ref CauseCode `postCrash` .
 * 
 * The value shall be set to:
 * - 0 `unavailable`                                               - in case further detailed information on post crash event is unavailable,
 * - 1 `accidentWithoutECallTriggered`                             - in case no eCall has been triggered for an accident,
 * - 2 `accidentWithECallManuallyTriggered`                        - in case eCall has been manually triggered and transmitted to eCall back end,
 * - 3 `accidentWithECallAutomaticallyTriggered`                   - in case eCall has been automatically triggered and transmitted to eCall back end,
 * - 4 `accidentWithECallTriggeredWithoutAccessToCellularNetwork`  - in case eCall has been triggered but cellular network is not accessible from triggering vehicle.
 * - 5-255                                                         - are reserved for future usage.
 *
 * @category: Traffic information
 * @revision: V1.3.1
 */
#[derive(Debug, Clone, PartialEq, Default)]
pub struct PostCrashSubCauseCode(pub u8);

impl PostCrashSubCauseCode {
  pub fn is_unavailable(&self) -> bool { self.0 as i128 == 0 }
  pub fn is_accidentWithoutECallTriggered(&self) -> bool { self.0 as i128 == 1 }
  pub fn is_accidentWithECallManuallyTriggered(&self) -> bool { self.0 as i128 == 2 }
  pub fn is_accidentWithECallAutomaticallyTriggered(&self) -> bool { self.0 as i128 == 3 }
  pub fn is_accidentWithECallTriggeredWithoutAccessToCellularNetwork(&self) -> bool { self.0 as i128 == 4 }
}

impl Decode for PostCrashSubCauseCode {
    fn decode<'a, D>(decoder: &D, input: &'a [u8]) -> IResult<&'a [u8], Self>
    where
        D: Decoder,
        Self: Sized,
    {
        decoder
            .decode_integer(AsnInteger { constraint: Some(Constraint { min_value: Some(0), max_value: Some(255), extensible: false }), distinguished_values: Some(vec![DistinguishedValue { name: "unavailable".into(), value: 0 },DistinguishedValue { name: "accidentWithoutECallTriggered".into(), value: 1 },DistinguishedValue { name: "accidentWithECallManuallyTriggered".into(), value: 2 },DistinguishedValue { name: "accidentWithECallAutomaticallyTriggered".into(), value: 3 },DistinguishedValue { name: "accidentWithECallTriggeredWithoutAccessToCellularNetwork".into(), value: 4 }]) })(input)
            .map(|(remaining, res)| (remaining, Self(res)))
    }
}


/* *
* This DE represent the total amount of rain falling during one hour. It is measured in mm per hour at an area of 1 square metre.  
* 
* The following values are specified:
* - `n` (`n > 0` and `n < 2000`) if the amount of rain falling is equal to or less than n x 0,1 mm/h and greater than (n-1) x 0,1 mm/h,
* - `2000` if the amount of rain falling is greater than 199.9 mm/h, 
* - `2001` if the information is not available.
*
* @unit: 0,1 mm/h 
* @category: Basic Information
* @revision: created in V2.1.1
*/
#[derive(Debug, Clone, PartialEq, Default)]
pub struct PrecipitationIntensity(pub u16);

impl PrecipitationIntensity {
  pub fn is_outOfRange(&self) -> bool { self.0 as i128 == 2000 }
  pub fn is_unavailable(&self) -> bool { self.0 as i128 == 2001 }
}

impl Decode for PrecipitationIntensity {
    fn decode<'a, D>(decoder: &D, input: &'a [u8]) -> IResult<&'a [u8], Self>
    where
        D: Decoder,
        Self: Sized,
    {
        decoder
            .decode_integer(AsnInteger { constraint: Some(Constraint { min_value: Some(1), max_value: Some(2001), extensible: false }), distinguished_values: Some(vec![DistinguishedValue { name: "outOfRange".into(), value: 2000 },DistinguishedValue { name: "unavailable".into(), value: 2001 }]) })(input)
            .map(|(remaining, res)| (remaining, Self(res)))
    }
}


/* *
 * This DE represents the indentifier of a protected communication zone.
 * 
 * 
 * @category: Infrastructure information, Communication information
 * @revision: Revision in V2.1.1 (changed name from ProtectedZoneID to ProtectedZoneId)
 */
#[derive(Debug, Clone, PartialEq, Default)]
pub struct ProtectedZoneId(pub u32);

impl Decode for ProtectedZoneId {
    fn decode<'a, D>(decoder: &D, input: &'a [u8]) -> IResult<&'a [u8], Self>
    where
        D: Decoder,
        Self: Sized,
    {
        decoder
            .decode_integer(AsnInteger { constraint: Some(Constraint { min_value: Some(0), max_value: Some(134217727), extensible: false }), distinguished_values: None })(input)
            .map(|(remaining, res)| (remaining, Self(res)))
    }
}


/* *
 * This DE represents the radius of a protected communication zone. 
 * 
 * 
 * @unit: metre
 * @category: Infrastructure information, Communication information
 * @revision: V1.3.1
 */
#[derive(Debug, Clone, PartialEq, Default)]
pub struct ProtectedZoneRadius(pub u8);

impl Decode for ProtectedZoneRadius {
    fn decode<'a, D>(decoder: &D, input: &'a [u8]) -> IResult<&'a [u8], Self>
    where
        D: Decoder,
        Self: Sized,
    {
        decoder
            .decode_integer(AsnInteger { constraint: Some(Constraint { min_value: Some(1), max_value: Some(255), extensible: true }), distinguished_values: None })(input)
            .map(|(remaining, res)| (remaining, Self(res)))
    }
}


/* *
 * This DE indicates the type of a protected communication zone, so that an ITS-S is aware of the actions to do
 * while passing by such zone (e.g. reduce the transmit power in case of a DSRC tolling station).
 * 
 * The protected zone type is defined in ETSI TS 102 792 [14].
 * 
 * 
 * @category: Communication information
 * @revision: V1.3.1
 */
#[derive(Debug, Clone, PartialEq, Default)]
pub enum ProtectedZoneType {
  #[default]
  permanentCenDsrcTolling = 0,
	temporaryCenDsrcTolling = 1,
}

impl TryFrom<i128> for ProtectedZoneType {
    type Error = DecodingError;

    fn try_from(v: i128) -> Result<Self, Self::Error> {
        match v {
            x if x == Self::permanentCenDsrcTolling as i128 => Ok(Self::permanentCenDsrcTolling),
		  x if x == Self::temporaryCenDsrcTolling as i128 => Ok(Self::temporaryCenDsrcTolling),
            _ => Err(
              DecodingError::new(
                &format!("Invalid enumerated index decoding ProtectedZoneType. Received index {}",v), DecodingErrorType::InvalidEnumeratedIndex
              )
            ),
        }
    }
}

impl Decode for ProtectedZoneType {
    fn decode<'a, D>(decoder: &D, input: &'a [u8]) -> IResult<&'a [u8], Self>
    where
        D: Decoder,
        Self: Sized,
    {
        decoder.decode_enumerated(AsnEnumerated { members: vec![Enumeral { name: "permanentCenDsrcTolling".into(), description: None, index: 0 },Enumeral { name: "temporaryCenDsrcTolling".into(), description: None, index: 1 }], extensible: Some(1) })( 
          input
        )
    }
}


/* *
 * This DE is used for various tasks in the public transportation environment, especially for controlling traffic
 * signal systems to prioritize and speed up public transportation in urban area (e.g. intersection "_bottlenecks_").
 * The traffic lights may be controlled by an approaching bus or tram automatically. This permits "_In Time_" activation
 * of the green phase, will enable the individual traffic to clear a potential traffic jam in advance. Thereby the
 * approaching bus or tram may pass an intersection with activated green light without slowing down the speed due to
 * traffic congestion. Other usage of the DE is the provision of information like the public transport line number
 * or the schedule delay of a public transport vehicle.
 * 
 * @category: Vehicle information
 * @revision: V1.3.1
 */
#[derive(Debug, Clone, PartialEq, Default)]
pub struct PtActivationData(pub String);

impl Decode for PtActivationData {
fn decode<'a, D>(decoder: &D, input: &'a [u8]) -> IResult<&'a [u8], Self>
where
    D: Decoder,
    Self: Sized,
{
    decoder
        .decode_character_string(AsnCharacterString { constraint: Some(Constraint { min_value: Some(1), max_value: Some(20), extensible: false }), r#type: CharacterStringType::OctetString })(input)
        .map(|(remaining, res)| (remaining, Self(res)))
}
}


/* *
 * This DE indicates a certain coding type of the PtActivationData data.
 *
 * The folowing value are specified:
 * - 0 `undefinedCodingType`  : undefined coding type,
 * - 1 `r09-16CodingType`     : coding of PtActivationData conform to VDV recommendation 420 [7],
 * - 2 `vdv-50149CodingType`  : coding of PtActivationData based on VDV recommendation 420 [7].
 * - 3 - 255                  : reserved for alternative and future use.
 * 
 * @category: Vehicle information 
 * @revision: V1.3.1
 */
#[derive(Debug, Clone, PartialEq, Default)]
pub struct PtActivationType(pub u8);

impl PtActivationType {
  pub fn is_undefinedCodingType(&self) -> bool { self.0 as i128 == 0 }
  pub fn is_r09_16CodingType(&self) -> bool { self.0 as i128 == 1 }
  pub fn is_vdv_50149CodingType(&self) -> bool { self.0 as i128 == 2 }
}

impl Decode for PtActivationType {
    fn decode<'a, D>(decoder: &D, input: &'a [u8]) -> IResult<&'a [u8], Self>
    where
        D: Decoder,
        Self: Sized,
    {
        decoder
            .decode_integer(AsnInteger { constraint: Some(Constraint { min_value: Some(0), max_value: Some(255), extensible: false }), distinguished_values: Some(vec![DistinguishedValue { name: "undefinedCodingType".into(), value: 0 },DistinguishedValue { name: "r09-16CodingType".into(), value: 1 },DistinguishedValue { name: "vdv-50149CodingType".into(), value: 2 }]) })(input)
            .map(|(remaining, res)| (remaining, Self(res)))
    }
}


/* *
 * This DE represents the value of the sub cause codes of the @ref CauseCode `railwayLevelCrossing` .
 * 
 * The value shall be set to:
 * - 0 `unavailable`                   - in case no further detailed information on the railway level crossing status is available,
 * - 1 `doNotCrossAbnormalSituation`   - in case when something wrong is detected by equation or sensors of the railway level crossing, 
                                         including level crossing is closed for too long (e.g. more than 10 minutes long ; default value),
 * - 2 `closed`                        - in case the crossing is closed (barriers down),
 * - 3 `unguarded`                     - in case the level crossing is unguarded (i.e a Saint Andrew cross level crossing without detection of train),
 * - 4 `nominal`                       - in case the barriers are up and lights are off.
 * - 5-255: reserved for future usage.
 *
 * @category: Traffic information
 * @revision: V1.3.1
 */
#[derive(Debug, Clone, PartialEq, Default)]
pub struct RailwayLevelCrossingSubCauseCode(pub u8);

impl RailwayLevelCrossingSubCauseCode {
  pub fn is_unavailable(&self) -> bool { self.0 as i128 == 0 }
  pub fn is_doNotCrossAbnormalSituation(&self) -> bool { self.0 as i128 == 1 }
  pub fn is_closed(&self) -> bool { self.0 as i128 == 2 }
  pub fn is_unguarded(&self) -> bool { self.0 as i128 == 3 }
  pub fn is_nominal(&self) -> bool { self.0 as i128 == 4 }
}

impl Decode for RailwayLevelCrossingSubCauseCode {
    fn decode<'a, D>(decoder: &D, input: &'a [u8]) -> IResult<&'a [u8], Self>
    where
        D: Decoder,
        Self: Sized,
    {
        decoder
            .decode_integer(AsnInteger { constraint: Some(Constraint { min_value: Some(0), max_value: Some(255), extensible: false }), distinguished_values: Some(vec![DistinguishedValue { name: "unavailable".into(), value: 0 },DistinguishedValue { name: "doNotCrossAbnormalSituation".into(), value: 1 },DistinguishedValue { name: "closed".into(), value: 2 },DistinguishedValue { name: "unguarded".into(), value: 3 },DistinguishedValue { name: "nominal".into(), value: 4 }]) })(input)
            .map(|(remaining, res)| (remaining, Self(res)))
    }
}


/* *
 * This DE describes a distance of relevance for information indicated in a message.
 *
 * The value shall be set to:
 * - 0 `lessThan50m`   - for distances below 50 m,
 * - 1 `lessThan100m`  - for distances below 100 m, 
 * - 2 `lessThan200m`  - for distances below 200 m, 
 * - 3 `lessThan500m`  - for distances below 300 m, 
 * - 4 `lessThan1000m` - for distances below 1 000 m, 
 * - 5 `lessThan5km`   - for distances below 5 000 m, 
 * - 6 `lessThan10km`  - for distances below 10 000 m, 
 * - 7 `over10km`      - for distances over 10 000 m. 
 * 
 * @note: this DE is kept for backwards compatibility reasons only. It is recommended to use the @ref StandardLength3b instead. 
 *
 * @category: GeoReference information
 * @revision: Editorial update in V2.1.1
 */
#[derive(Debug, Clone, PartialEq, Default)]
pub enum RelevanceDistance {
  #[default]
  lessThan50m = 0,
	lessThan100m = 1,
	lessThan200m = 2,
	lessThan500m = 3,
	lessThan1000m = 4,
	lessThan5km = 5,
	lessThan10km = 6,
	over10km = 7,
}

impl TryFrom<i128> for RelevanceDistance {
    type Error = DecodingError;

    fn try_from(v: i128) -> Result<Self, Self::Error> {
        match v {
            x if x == Self::lessThan50m as i128 => Ok(Self::lessThan50m),
		  x if x == Self::lessThan100m as i128 => Ok(Self::lessThan100m),
		  x if x == Self::lessThan200m as i128 => Ok(Self::lessThan200m),
		  x if x == Self::lessThan500m as i128 => Ok(Self::lessThan500m),
		  x if x == Self::lessThan1000m as i128 => Ok(Self::lessThan1000m),
		  x if x == Self::lessThan5km as i128 => Ok(Self::lessThan5km),
		  x if x == Self::lessThan10km as i128 => Ok(Self::lessThan10km),
		  x if x == Self::over10km as i128 => Ok(Self::over10km),
            _ => Err(
              DecodingError::new(
                &format!("Invalid enumerated index decoding RelevanceDistance. Received index {}",v), DecodingErrorType::InvalidEnumeratedIndex
              )
            ),
        }
    }
}

impl Decode for RelevanceDistance {
    fn decode<'a, D>(decoder: &D, input: &'a [u8]) -> IResult<&'a [u8], Self>
    where
        D: Decoder,
        Self: Sized,
    {
        decoder.decode_enumerated(AsnEnumerated { members: vec![Enumeral { name: "lessThan50m".into(), description: None, index: 0 },Enumeral { name: "lessThan100m".into(), description: None, index: 1 },Enumeral { name: "lessThan200m".into(), description: None, index: 2 },Enumeral { name: "lessThan500m".into(), description: None, index: 3 },Enumeral { name: "lessThan1000m".into(), description: None, index: 4 },Enumeral { name: "lessThan5km".into(), description: None, index: 5 },Enumeral { name: "lessThan10km".into(), description: None, index: 6 },Enumeral { name: "over10km".into(), description: None, index: 7 }], extensible: None })( 
          input
        )
    }
}


/* *
 * This DE indicates a traffic direction that is relevant to information indicated in a message.
 * 
 * The value shall be set to:
 * - 0 `allTrafficDirections` - for all traffic directions, 
 * - 1 `upstreamTraffic`      - for upstream traffic, 
 * - 2 `downstreamTraffic`    - for downstream traffic, 
 * - 3 `oppositeTraffic`      - for traffic in the opposite direction. 
 *
 * The terms `upstream`, `downstream` and `oppositeTraffic` are relative to the event position.
 *
 * @note: Upstream traffic corresponds to the incoming traffic towards the event position,
 * and downstream traffic to the departing traffic away from the event position.
 *
 * @note: this DE is kept for backwards compatibility reasons only. It is recommended to use the @ref TrafficDirection instead. 
 *
 * @category: GeoReference information
 * @revision: Editorial update in V2.1.1
 */
#[derive(Debug, Clone, PartialEq, Default)]
pub enum RelevanceTrafficDirection {
  #[default]
  allTrafficDirections = 0,
	upstreamTraffic = 1,
	downstreamTraffic = 2,
	oppositeTraffic = 3,
}

impl TryFrom<i128> for RelevanceTrafficDirection {
    type Error = DecodingError;

    fn try_from(v: i128) -> Result<Self, Self::Error> {
        match v {
            x if x == Self::allTrafficDirections as i128 => Ok(Self::allTrafficDirections),
		  x if x == Self::upstreamTraffic as i128 => Ok(Self::upstreamTraffic),
		  x if x == Self::downstreamTraffic as i128 => Ok(Self::downstreamTraffic),
		  x if x == Self::oppositeTraffic as i128 => Ok(Self::oppositeTraffic),
            _ => Err(
              DecodingError::new(
                &format!("Invalid enumerated index decoding RelevanceTrafficDirection. Received index {}",v), DecodingErrorType::InvalidEnumeratedIndex
              )
            ),
        }
    }
}

impl Decode for RelevanceTrafficDirection {
    fn decode<'a, D>(decoder: &D, input: &'a [u8]) -> IResult<&'a [u8], Self>
    where
        D: Decoder,
        Self: Sized,
    {
        decoder.decode_enumerated(AsnEnumerated { members: vec![Enumeral { name: "allTrafficDirections".into(), description: None, index: 0 },Enumeral { name: "upstreamTraffic".into(), description: None, index: 1 },Enumeral { name: "downstreamTraffic".into(), description: None, index: 2 },Enumeral { name: "oppositeTraffic".into(), description: None, index: 3 }], extensible: None })( 
          input
        )
    }
}


/* *
 * This DE indicates whether an ITS message is transmitted as request from ITS-S or a response transmitted from
 * ITS-S after receiving request from other ITS-Ss.
 *
 * The value shall be set to:
 * - 0 `request`  - for a request message, 
 * - 1 `response` - for a response message.  
 *
 * @category Communication information
 * @revision: Editorial update in V2.1.1
 */
#[derive(Debug, Clone, PartialEq, Default)]
pub enum RequestResponseIndication {
  #[default]
  request = 0,
	response = 1,
}

impl TryFrom<i128> for RequestResponseIndication {
    type Error = DecodingError;

    fn try_from(v: i128) -> Result<Self, Self::Error> {
        match v {
            x if x == Self::request as i128 => Ok(Self::request),
		  x if x == Self::response as i128 => Ok(Self::response),
            _ => Err(
              DecodingError::new(
                &format!("Invalid enumerated index decoding RequestResponseIndication. Received index {}",v), DecodingErrorType::InvalidEnumeratedIndex
              )
            ),
        }
    }
}

impl Decode for RequestResponseIndication {
    fn decode<'a, D>(decoder: &D, input: &'a [u8]) -> IResult<&'a [u8], Self>
    where
        D: Decoder,
        Self: Sized,
    {
        decoder.decode_enumerated(AsnEnumerated { members: vec![Enumeral { name: "request".into(), description: None, index: 0 },Enumeral { name: "response".into(), description: None, index: 1 }], extensible: None })( 
          input
        )
    }
}


/* *
 * This DE represents the value of the sub cause codes of the @ref CauseCode `rescueAndRecoveryWorkInProgress` 
 * 
 * The value shall be set to:
 * - 0 `unavailable`             - in case further detailed information on rescue and recovery work is unavailable,
 * - 1 `emergencyVehicles`       - in case rescue work is ongoing by emergency vehicles,
 * - 2 `rescueHelicopterLanding` - in case rescue helicopter is landing,
 * - 3 `policeActivityOngoing`   - in case police activity is ongoing,
 * - 4 `medicalEmergencyOngoing` - in case medical emergency recovery is ongoing,
 * - 5 `childAbductionInProgress`- in case a child kidnapping alarm is activated and rescue work is ongoing,
 * - 6-255: reserved for future usage.
 *
 * @category: Traffic information
 * @revision: V1.3.1
 */
#[derive(Debug, Clone, PartialEq, Default)]
pub struct RescueAndRecoveryWorkInProgressSubCauseCode(pub u8);

impl RescueAndRecoveryWorkInProgressSubCauseCode {
  pub fn is_unavailable(&self) -> bool { self.0 as i128 == 0 }
  pub fn is_emergencyVehicles(&self) -> bool { self.0 as i128 == 1 }
  pub fn is_rescueHelicopterLanding(&self) -> bool { self.0 as i128 == 2 }
  pub fn is_policeActivityOngoing(&self) -> bool { self.0 as i128 == 3 }
  pub fn is_medicalEmergencyOngoing(&self) -> bool { self.0 as i128 == 4 }
  pub fn is_childAbductionInProgress(&self) -> bool { self.0 as i128 == 5 }
}

impl Decode for RescueAndRecoveryWorkInProgressSubCauseCode {
    fn decode<'a, D>(decoder: &D, input: &'a [u8]) -> IResult<&'a [u8], Self>
    where
        D: Decoder,
        Self: Sized,
    {
        decoder
            .decode_integer(AsnInteger { constraint: Some(Constraint { min_value: Some(0), max_value: Some(255), extensible: false }), distinguished_values: Some(vec![DistinguishedValue { name: "unavailable".into(), value: 0 },DistinguishedValue { name: "emergencyVehicles".into(), value: 1 },DistinguishedValue { name: "rescueHelicopterLanding".into(), value: 2 },DistinguishedValue { name: "policeActivityOngoing".into(), value: 3 },DistinguishedValue { name: "medicalEmergencyOngoing".into(), value: 4 },DistinguishedValue { name: "childAbductionInProgress".into(), value: 5 }]) })(input)
            .map(|(remaining, res)| (remaining, Self(res)))
    }
}


/* *
 * This DE indicates the type of a road segment.
 * 
 * The value shall be set to:
 * - 0 `urban-NoStructuralSeparationToOppositeLanes`       - for an urban road with no structural separation between lanes carrying traffic in opposite directions,
 * - 1 `urban-WithStructuralSeparationToOppositeLanes`     - for an urban road with structural separation between lanes carrying traffic in opposite directions,
 * - 2 `nonUrban-NoStructuralSeparationToOppositeLanes`    - for an non urban road with no structural separation between lanes carrying traffic in opposite directions,
 * - 3 `nonUrban-WithStructuralSeparationToOppositeLanes`  - for an non urban road with structural separation between lanes carrying traffic in opposite directions.
 *
 * @category: Road Topology Information
 * @revision: Editorial update in V2.1.1
 */
#[derive(Debug, Clone, PartialEq, Default)]
pub enum RoadType {
  #[default]
  urban_NoStructuralSeparationToOppositeLanes = 0,
	urban_WithStructuralSeparationToOppositeLanes = 1,
	nonUrban_NoStructuralSeparationToOppositeLanes = 2,
	nonUrban_WithStructuralSeparationToOppositeLanes = 3,
}

impl TryFrom<i128> for RoadType {
    type Error = DecodingError;

    fn try_from(v: i128) -> Result<Self, Self::Error> {
        match v {
            x if x == Self::urban_NoStructuralSeparationToOppositeLanes as i128 => Ok(Self::urban_NoStructuralSeparationToOppositeLanes),
		  x if x == Self::urban_WithStructuralSeparationToOppositeLanes as i128 => Ok(Self::urban_WithStructuralSeparationToOppositeLanes),
		  x if x == Self::nonUrban_NoStructuralSeparationToOppositeLanes as i128 => Ok(Self::nonUrban_NoStructuralSeparationToOppositeLanes),
		  x if x == Self::nonUrban_WithStructuralSeparationToOppositeLanes as i128 => Ok(Self::nonUrban_WithStructuralSeparationToOppositeLanes),
            _ => Err(
              DecodingError::new(
                &format!("Invalid enumerated index decoding RoadType. Received index {}",v), DecodingErrorType::InvalidEnumeratedIndex
              )
            ),
        }
    }
}

impl Decode for RoadType {
    fn decode<'a, D>(decoder: &D, input: &'a [u8]) -> IResult<&'a [u8], Self>
    where
        D: Decoder,
        Self: Sized,
    {
        decoder.decode_enumerated(AsnEnumerated { members: vec![Enumeral { name: "urban-NoStructuralSeparationToOppositeLanes".into(), description: None, index: 0 },Enumeral { name: "urban-WithStructuralSeparationToOppositeLanes".into(), description: None, index: 1 },Enumeral { name: "nonUrban-NoStructuralSeparationToOppositeLanes".into(), description: None, index: 2 },Enumeral { name: "nonUrban-WithStructuralSeparationToOppositeLanes".into(), description: None, index: 3 }], extensible: None })( 
          input
        )
    }
}


/* *
 * This DE represents the value of the sub cause codes of the @ref CauseCode `roadworks`.
 * 
The value shall be set to:
 * - 0 `unavailable`                 - in case further detailed information on roadworks is unavailable,
 * - 1 `majorRoadworks`              - in case a major roadworks is ongoing,
 * - 2 `roadMarkingWork`             - in case a road marking work is ongoing,
 * - 3 `slowMovingRoadMaintenance`   - in case slow moving road maintenance work is ongoing,
 * - 4 `shortTermStationaryRoadworks`- in case a short term stationary roadwork is ongoing,
 * - 5 `streetCleaning`              - in case a vehicle street cleaning work is ongoing,
 * - 6 `winterService`               - in case winter service work is ongoing.
 * - 7-255                           - are reserved for future usage.
 *
 * @category: Traffic information
 * @revision: V1.3.1
 */
#[derive(Debug, Clone, PartialEq, Default)]
pub struct RoadworksSubCauseCode(pub u8);

impl RoadworksSubCauseCode {
  pub fn is_unavailable(&self) -> bool { self.0 as i128 == 0 }
  pub fn is_majorRoadworks(&self) -> bool { self.0 as i128 == 1 }
  pub fn is_roadMarkingWork(&self) -> bool { self.0 as i128 == 2 }
  pub fn is_slowMovingRoadMaintenance(&self) -> bool { self.0 as i128 == 3 }
  pub fn is_shortTermStationaryRoadworks(&self) -> bool { self.0 as i128 == 4 }
  pub fn is_streetCleaning(&self) -> bool { self.0 as i128 == 5 }
  pub fn is_winterService(&self) -> bool { self.0 as i128 == 6 }
}

impl Decode for RoadworksSubCauseCode {
    fn decode<'a, D>(decoder: &D, input: &'a [u8]) -> IResult<&'a [u8], Self>
    where
        D: Decoder,
        Self: Sized,
    {
        decoder
            .decode_integer(AsnInteger { constraint: Some(Constraint { min_value: Some(0), max_value: Some(255), extensible: false }), distinguished_values: Some(vec![DistinguishedValue { name: "unavailable".into(), value: 0 },DistinguishedValue { name: "majorRoadworks".into(), value: 1 },DistinguishedValue { name: "roadMarkingWork".into(), value: 2 },DistinguishedValue { name: "slowMovingRoadMaintenance".into(), value: 3 },DistinguishedValue { name: "shortTermStationaryRoadworks".into(), value: 4 },DistinguishedValue { name: "streetCleaning".into(), value: 5 },DistinguishedValue { name: "winterService".into(), value: 6 }]) })(input)
            .map(|(remaining, res)| (remaining, Self(res)))
    }
}


/* *
 * This DE indicates if a distance is safe. 
 *
 * The value shall be set to:
 * -  `FALSE`  if  the triple  {LaD,  LoD, VD} < {MSLaD, MSLoD, MSVD} is simultaneously  satisfied with confidence level of  90 % or  more, 
 * -  `TRUE` otherwise. 
 *
 * @note: the abbreviations used are Lateral Distance (LaD),  Longitudinal Distance (LoD) and Vertical Distance (VD) 
 * and their respective  thresholds, Minimum  Safe  Lateral  Distance (MSLaD), Minimum  Safe  Longitudinal Distance  (MSLoD),  and  Minimum  Safe Vertical Distance (MSVD).
 *
 * @category: Traffic information, Kinematic information
 * @revision: created in V2.1.1
*/
#[derive(Debug, Clone, PartialEq, Default)]
pub struct SafeDistanceIndicator(pub bool);

impl Decode for SafeDistanceIndicator {
    fn decode<'a, D>(decoder: &D, input: &'a [u8]) -> IResult<&'a [u8], Self>
    where
        D: Decoder,
        Self: Sized,
    {
        decoder
            .decode_boolean(input)
            .map(|(remaining, res)| (remaining, Self(res)))
    }
}


/* *
 * This DE indicates the horizontal position confidence value which represents the estimated absolute position accuracy, in one of the axis direction as defined in a shape of ellipse with a 
 * confidence level of 95 %. 
 * 
 * The value shall be set to:
 * - `n` (`n > 0` and `n < 4 094`) if the accuracy is equal to or less than n * 0,01 metre,
 * - `4 094` if the accuracy is out of range, i.e. greater than 4,093 m,
 * - `4 095` if the accuracy information is unavailable.
 *
 * The value 0 shall not be used.
 * 
 * @note: The fact that a position coordinate value is received with confidence value set to `unavailable(4095)`.
 * can be caused by several reasons, such as:
 * - the sensor cannot deliver the accuracy at the defined confidence level because it is a low-end sensor,
 * - the sensor cannot calculate the accuracy due to lack of variables, or
 * - there has been a vehicle bus (e.g. CAN bus) error.
 * In all 3 cases above, the position coordinate value may be valid and used by the application.
 * If a position coordinate value is received and its confidence value is set to `outOfRange(4094)`, it means that
 * the position coordinate value is not valid and therefore cannot be trusted. Such value is not useful
 * for the application.

 * @unit 0,01 metre 
 * @category: GeoReference Information
 * @revision: Description revised in V2.1.1
 */
#[derive(Debug, Clone, PartialEq, Default)]
pub struct SemiAxisLength(pub u16);

impl SemiAxisLength {
  pub fn is_doNotUse(&self) -> bool { self.0 as i128 == 0 }
  pub fn is_outOfRange(&self) -> bool { self.0 as i128 == 4094 }
  pub fn is_unavailable(&self) -> bool { self.0 as i128 == 4095 }
}

impl Decode for SemiAxisLength {
    fn decode<'a, D>(decoder: &D, input: &'a [u8]) -> IResult<&'a [u8], Self>
    where
        D: Decoder,
        Self: Sized,
    {
        decoder
            .decode_integer(AsnInteger { constraint: Some(Constraint { min_value: Some(0), max_value: Some(4095), extensible: false }), distinguished_values: Some(vec![DistinguishedValue { name: "doNotUse".into(), value: 0 },DistinguishedValue { name: "outOfRange".into(), value: 4094 },DistinguishedValue { name: "unavailable".into(), value: 4095 }]) })(input)
            .map(|(remaining, res)| (remaining, Self(res)))
    }
}


/* * 
 * This DE indicates the type of sensor.
 * 
 * The value shall be set to:
 * - 0  `undefined`         - in case the sensor type is undefined. 
 * - 1  `radar`             - in case the sensor is a radar,
 * - 2  `lidar`             - in case the sensor is a lidar,
 * - 3  `monovideo`         - in case the sensor is mono video,
 * - 4  `stereovision`      - in case the sensor is stereo vision,
 * - 5  `nightvision`       - in case the sensor is night vision,
 * - 6  `ultrasonic`        - in case the sensor is ultrasonic,
 * - 7  `pmd`               - in case the sensor is photonic mixing device,
 * - 8  `inductionLoop`     - in case the sensor is an induction loop,
 * - 9  `sphericalCamera`   - in case the sensor is a spherical camera,
 * - 10 `uwb`               - in case the sensor is ultra wide band,
 * - 11 `acoustic`          - in case the sensor is acoustic,
 * - 12 `localAggregation`  - in case the information is provided by a system that aggregates information from different local sensors. Aggregation may include fusion,
 * - 13 `itsAggregation`    - in case the information is provided by a system that aggregates information from other received ITS messages.
 * - 14-31                  - are reserved for future usage.
 *
 * @category: Sensing Information
 * @revision: created in V2.1.1
*/
#[derive(Debug, Clone, PartialEq, Default)]
pub struct SensorType(pub u8);

impl SensorType {
  pub fn is_undefined(&self) -> bool { self.0 as i128 == 0 }
  pub fn is_radar(&self) -> bool { self.0 as i128 == 1 }
  pub fn is_lidar(&self) -> bool { self.0 as i128 == 2 }
  pub fn is_monovideo(&self) -> bool { self.0 as i128 == 3 }
  pub fn is_stereovision(&self) -> bool { self.0 as i128 == 4 }
  pub fn is_nightvision(&self) -> bool { self.0 as i128 == 5 }
  pub fn is_ultrasonic(&self) -> bool { self.0 as i128 == 6 }
  pub fn is_pmd(&self) -> bool { self.0 as i128 == 7 }
  pub fn is_inductionLoop(&self) -> bool { self.0 as i128 == 8 }
  pub fn is_sphericalCamera(&self) -> bool { self.0 as i128 == 9 }
  pub fn is_uwb(&self) -> bool { self.0 as i128 == 10 }
  pub fn is_acoustic(&self) -> bool { self.0 as i128 == 11 }
  pub fn is_localAggregation(&self) -> bool { self.0 as i128 == 12 }
  pub fn is_itsAggregation(&self) -> bool { self.0 as i128 == 13 }
}

impl Decode for SensorType {
    fn decode<'a, D>(decoder: &D, input: &'a [u8]) -> IResult<&'a [u8], Self>
    where
        D: Decoder,
        Self: Sized,
    {
        decoder
            .decode_integer(AsnInteger { constraint: Some(Constraint { min_value: Some(0), max_value: Some(31), extensible: false }), distinguished_values: Some(vec![DistinguishedValue { name: "undefined".into(), value: 0 },DistinguishedValue { name: "radar".into(), value: 1 },DistinguishedValue { name: "lidar".into(), value: 2 },DistinguishedValue { name: "monovideo".into(), value: 3 },DistinguishedValue { name: "stereovision".into(), value: 4 },DistinguishedValue { name: "nightvision".into(), value: 5 },DistinguishedValue { name: "ultrasonic".into(), value: 6 },DistinguishedValue { name: "pmd".into(), value: 7 },DistinguishedValue { name: "inductionLoop".into(), value: 8 },DistinguishedValue { name: "sphericalCamera".into(), value: 9 },DistinguishedValue { name: "uwb".into(), value: 10 },DistinguishedValue { name: "acoustic".into(), value: 11 },DistinguishedValue { name: "localAggregation".into(), value: 12 },DistinguishedValue { name: "itsAggregation".into(), value: 13 }]) })(input)
            .map(|(remaining, res)| (remaining, Self(res)))
    }
}


/* *
 * This DE represents a sequence number.
 * 
 * @category: Basic information
 * @revision: V1.3.1
 */
#[derive(Debug, Clone, PartialEq, Default)]
pub struct SequenceNumber(pub u16);

impl Decode for SequenceNumber {
    fn decode<'a, D>(decoder: &D, input: &'a [u8]) -> IResult<&'a [u8], Self>
    where
        D: Decoder,
        Self: Sized,
    {
        decoder
            .decode_integer(AsnInteger { constraint: Some(Constraint { min_value: Some(0), max_value: Some(65535), extensible: false }), distinguished_values: None })(input)
            .map(|(remaining, res)| (remaining, Self(res)))
    }
}


/* *
 * This DE represents the value of the sub cause codes of the @ref CauseCode `signalViolation`.
 * 
 * The value shall be set to:
 * - 0 `unavailable`               - in case further detailed information on signal violation event is unavailable,
 * - 1 `stopSignViolation`         - in case a stop sign violation is detected,
 * - 2 `trafficLightViolation`     - in case a traffic light violation is detected,
 * - 3 `turningRegulationViolation`- in case a turning regulation violation is detected.
 * - 4-255                         - are reserved for future usage.
 *
 * @category: Traffic information
 * @revision: V1.3.1
 */
#[derive(Debug, Clone, PartialEq, Default)]
pub struct SignalViolationSubCauseCode(pub u8);

impl SignalViolationSubCauseCode {
  pub fn is_unavailable(&self) -> bool { self.0 as i128 == 0 }
  pub fn is_stopSignViolation(&self) -> bool { self.0 as i128 == 1 }
  pub fn is_trafficLightViolation(&self) -> bool { self.0 as i128 == 2 }
  pub fn is_turningRegulationViolation(&self) -> bool { self.0 as i128 == 3 }
}

impl Decode for SignalViolationSubCauseCode {
    fn decode<'a, D>(decoder: &D, input: &'a [u8]) -> IResult<&'a [u8], Self>
    where
        D: Decoder,
        Self: Sized,
    {
        decoder
            .decode_integer(AsnInteger { constraint: Some(Constraint { min_value: Some(0), max_value: Some(255), extensible: false }), distinguished_values: Some(vec![DistinguishedValue { name: "unavailable".into(), value: 0 },DistinguishedValue { name: "stopSignViolation".into(), value: 1 },DistinguishedValue { name: "trafficLightViolation".into(), value: 2 },DistinguishedValue { name: "turningRegulationViolation".into(), value: 3 }]) })(input)
            .map(|(remaining, res)| (remaining, Self(res)))
    }
}


/* *
 * This DE represents the sub cause codes of the @ref CauseCode "slowVehicle".
 * 
 * The value shall be set to:
 * - 0 `unavailable`                    - in case further detailed information on slow vehicle driving event is
 *                                        unavailable,
 * - 1 `maintenanceVehicle`             - in case of a slow driving maintenance vehicle on the road,
 * - 2 `vehiclesSlowingToLookAtAccident`- in case vehicle is temporally slowing down to look at accident, spot, etc.,
 * - 3 `abnormalLoad`                   - in case an abnormal loaded vehicle is driving slowly on the road,
 * - 4 `abnormalWideLoad`               - in case an abnormal wide load vehicle is driving slowly on the road,
 * - 5 `convoy`                         - in case of slow driving convoy on the road,
 * - 6 `snowplough`                     - in case of slow driving snow plough on the road,
 * - 7 `deicing`                        - in case of slow driving de-icing vehicle on the road,
 * - 8 `saltingVehicles`                - in case of slow driving salting vehicle on the road.
 * - 9-255                              - are reserved for future usage.
 * 
 * @category: Traffic information
 * @revision: V1.3.1
 */
#[derive(Debug, Clone, PartialEq, Default)]
pub struct SlowVehicleSubCauseCode(pub u8);

impl SlowVehicleSubCauseCode {
  pub fn is_unavailable(&self) -> bool { self.0 as i128 == 0 }
  pub fn is_maintenanceVehicle(&self) -> bool { self.0 as i128 == 1 }
  pub fn is_vehiclesSlowingToLookAtAccident(&self) -> bool { self.0 as i128 == 2 }
  pub fn is_abnormalLoad(&self) -> bool { self.0 as i128 == 3 }
  pub fn is_abnormalWideLoad(&self) -> bool { self.0 as i128 == 4 }
  pub fn is_convoy(&self) -> bool { self.0 as i128 == 5 }
  pub fn is_snowplough(&self) -> bool { self.0 as i128 == 6 }
  pub fn is_deicing(&self) -> bool { self.0 as i128 == 7 }
  pub fn is_saltingVehicles(&self) -> bool { self.0 as i128 == 8 }
}

impl Decode for SlowVehicleSubCauseCode {
    fn decode<'a, D>(decoder: &D, input: &'a [u8]) -> IResult<&'a [u8], Self>
    where
        D: Decoder,
        Self: Sized,
    {
        decoder
            .decode_integer(AsnInteger { constraint: Some(Constraint { min_value: Some(0), max_value: Some(255), extensible: false }), distinguished_values: Some(vec![DistinguishedValue { name: "unavailable".into(), value: 0 },DistinguishedValue { name: "maintenanceVehicle".into(), value: 1 },DistinguishedValue { name: "vehiclesSlowingToLookAtAccident".into(), value: 2 },DistinguishedValue { name: "abnormalLoad".into(), value: 3 },DistinguishedValue { name: "abnormalWideLoad".into(), value: 4 },DistinguishedValue { name: "convoy".into(), value: 5 },DistinguishedValue { name: "snowplough".into(), value: 6 },DistinguishedValue { name: "deicing".into(), value: 7 },DistinguishedValue { name: "saltingVehicles".into(), value: 8 }]) })(input)
            .map(|(remaining, res)| (remaining, Self(res)))
    }
}


/* *
 * The DE indicates if a vehicle is carrying goods in the special transport conditions.
 *
 * The corresponding bit shall be set to 1 under the following conditions:
 * - 0 `heavyLoad`        - the vehicle is carrying goods with heavy load,
 * - 1 `excessWidth`      - the vehicle is carrying goods in excess of width,
 * - 2 `excessLength`     - the vehicle is carrying goods in excess of length,
 * - 3 `excessHeight`     - the vehicle is carrying goods in excess of height.
 *
 * Otherwise, the corresponding bit shall be set to 0.
 * @category Vehicle information
 * @revision: Description revised in V2.1.1
 */
#[derive(Debug, Clone, PartialEq, Default)]
pub struct SpecialTransportType(pub Vec<bool>);

impl SpecialTransportType {
  pub fn is_heavyLoad(&self) -> bool { *self.0.get(0).unwrap_or(&false) }
  pub fn is_excessWidth(&self) -> bool { *self.0.get(1).unwrap_or(&false) }
  pub fn is_excessLength(&self) -> bool { *self.0.get(2).unwrap_or(&false) }
  pub fn is_excessHeight(&self) -> bool { *self.0.get(3).unwrap_or(&false) }
}

impl Decode for SpecialTransportType {
  fn decode<'a, D>(decoder: &D, input: &'a [u8]) -> IResult<&'a [u8], Self>
  where
      D: Decoder,
      Self: Sized,
  {
      decoder
          .decode_bit_string(AsnBitString { constraint: Some(Constraint { min_value: Some(4), max_value: Some(4), extensible: false }), distinguished_values: Some(vec![DistinguishedValue { name: "heavyLoad".into(), value: 0 },DistinguishedValue { name: "excessWidth".into(), value: 1 },DistinguishedValue { name: "excessLength".into(), value: 2 },DistinguishedValue { name: "excessHeight".into(), value: 3 }]) })(input)
          .map(|(remaining, res)| (remaining, Self(res)))
  }
}


/* *
 * This DE indicates the speed confidence value which represents the estimated absolute accuracy of a speed value with a default confidence level of 95 %.
 * If required, the confidence level can be defined by the corresponding standards applying this DE.
 * 
 * The value shall be set to:
 * - `n` (`n > 0` and `n < 126`) if the confidence value is equal to or less than n * 0,01 m/s.
 * - `126` if the confidence value is out of range, i.e. greater than 1,25 m/s,
 * - `127` if the confidence value information is not available.
 *  
 * @note: The fact that a speed value is received with confidence value set to `unavailable(127)` can be caused by several reasons, such as:
 * - the sensor cannot deliver the accuracy at the defined confidence level because it is a low-end sensor,
 * - the sensor cannot calculate the accuracy due to lack of variables, or
 * - there has been a vehicle bus (e.g. CAN bus) error.
 * In all 3 cases above, the speed value may be valid and used by the application.
 * 
 * @note: If a speed value is received and its confidence value is set to `outOfRange(126)`, it means that the speed value is not valid 
 * and therefore cannot be trusted. Such is not useful for the application.
 *
 * @unit: 0,01 m/s
 * @category: Vehicle information
 * @revision: Description revised in V2.1.1 
 */
#[derive(Debug, Clone, PartialEq, Default)]
pub struct SpeedConfidence(pub u8);

impl SpeedConfidence {
  pub fn is_outOfRange(&self) -> bool { self.0 as i128 == 126 }
  pub fn is_unavailable(&self) -> bool { self.0 as i128 == 127 }
}

impl Decode for SpeedConfidence {
    fn decode<'a, D>(decoder: &D, input: &'a [u8]) -> IResult<&'a [u8], Self>
    where
        D: Decoder,
        Self: Sized,
    {
        decoder
            .decode_integer(AsnInteger { constraint: Some(Constraint { min_value: Some(1), max_value: Some(127), extensible: false }), distinguished_values: Some(vec![DistinguishedValue { name: "outOfRange".into(), value: 126 },DistinguishedValue { name: "unavailable".into(), value: 127 }]) })(input)
            .map(|(remaining, res)| (remaining, Self(res)))
    }
}


/* *
 * This DE represents a speed limitation applied to a geographical position, a road section or a geographical region.
 * 
 * @unit: km/h
 * @category: Infrastructure information, Traffic information
 * @revision: V1.3.1
 */
#[derive(Debug, Clone, PartialEq, Default)]
pub struct SpeedLimit(pub u8);

impl Decode for SpeedLimit {
    fn decode<'a, D>(decoder: &D, input: &'a [u8]) -> IResult<&'a [u8], Self>
    where
        D: Decoder,
        Self: Sized,
    {
        decoder
            .decode_integer(AsnInteger { constraint: Some(Constraint { min_value: Some(1), max_value: Some(255), extensible: false }), distinguished_values: None })(input)
            .map(|(remaining, res)| (remaining, Self(res)))
    }
}


/* *
 * This DE represents a speed value, i.e. the magnitude of the velocity-vector. 
 *
 * The value shall be set to:
 * - `0` in a standstill situation.
 * - `n` (`n > 0` and `n < 16 382`) if the applicable value is equal to or less than n x 0,01 m/s, and greater than (n-1) x 0,01 m/s,
 * - `16 382` for speed values greater than 163,81 m/s,
 * - `16 383` if the speed accuracy information is not available.
 * 
 * @note: the definition of standstill is out of scope of the present document.
 *
 * @unit: 0,01 m/s
 * @category: Kinematic information
 * @revision: Description revised in V2.1.1 (the meaning of 16382 has changed slightly) 
*/
#[derive(Debug, Clone, PartialEq, Default)]
pub struct SpeedValue(pub u16);

impl SpeedValue {
  pub fn is_standstill(&self) -> bool { self.0 as i128 == 0 }
  pub fn is_outOfRange(&self) -> bool { self.0 as i128 == 16382 }
  pub fn is_unavailable(&self) -> bool { self.0 as i128 == 16383 }
}

impl Decode for SpeedValue {
    fn decode<'a, D>(decoder: &D, input: &'a [u8]) -> IResult<&'a [u8], Self>
    where
        D: Decoder,
        Self: Sized,
    {
        decoder
            .decode_integer(AsnInteger { constraint: Some(Constraint { min_value: Some(0), max_value: Some(16383), extensible: false }), distinguished_values: Some(vec![DistinguishedValue { name: "standstill".into(), value: 0 },DistinguishedValue { name: "outOfRange".into(), value: 16382 },DistinguishedValue { name: "unavailable".into(), value: 16383 }]) })(input)
            .map(|(remaining, res)| (remaining, Self(res)))
    }
}


/* * 
 * This DE represents the value of a velocity component in a defined coordinate system.
 *
 * The value shall be set to:
 * - `-16 383` if the velocity is equal to or smaller than -163,83 m/s,
 * - `n` (`n > -16 383` and `n < 16 382`) if the applicable value is equal to or less than n x 0,01 m/s, and greater than (n-1) x 0,01 m/s,
 * - `16 382` for velocity values equal to or greater than 163,81 m/s,
 * - `16 383` if the velocity information is not available.
 * 
 * @unit: 0,01 m/s
 * @category: Kinematic information
 * @revision: Created in V2.1.1
*/
#[derive(Debug, Clone, PartialEq, Default)]
pub struct VelocityComponentValue(pub i16);

impl VelocityComponentValue {
  pub fn is_negativeOutOfRange(&self) -> bool { self.0 as i128 == -16383 }
  pub fn is_positiveOutOfRange(&self) -> bool { self.0 as i128 == 16382 }
  pub fn is_unavailable(&self) -> bool { self.0 as i128 == 16383 }
}

impl Decode for VelocityComponentValue {
    fn decode<'a, D>(decoder: &D, input: &'a [u8]) -> IResult<&'a [u8], Self>
    where
        D: Decoder,
        Self: Sized,
    {
        decoder
            .decode_integer(AsnInteger { constraint: Some(Constraint { min_value: Some(-16383), max_value: Some(16383), extensible: false }), distinguished_values: Some(vec![DistinguishedValue { name: "negativeOutOfRange".into(), value: -16383 },DistinguishedValue { name: "positiveOutOfRange".into(), value: 16382 },DistinguishedValue { name: "unavailable".into(), value: 16383 }]) })(input)
            .map(|(remaining, res)| (remaining, Self(res)))
    }
}


/* *
 * This DE indicates the estimated probability of a stability level and conversely also the probability of a stability loss.
 *
 * The value shall be set to:
 * - `0` to indicate an estimated probability of a loss of stability of 0 %, i.e. "stable", 
 * - `n` (`n > 0` and `n < 50`) to indicate the actual stability level,
 * - `50` to indicate a estimated probability of a loss of stability of 100 %, i.e. "total loss of stability",
 * - the values between 51 and 62 are reserved for future use,
 * - `63`: this value indicates that the information is unavailable.
 *
 * @unit: 2 %
 * @category: Kinematic information
 * @revision: Created in V2.1.1
 */
#[derive(Debug, Clone, PartialEq, Default)]
pub struct StabilityLossProbability(pub u8);

impl StabilityLossProbability {
  pub fn is_stable(&self) -> bool { self.0 as i128 == 0 }
  pub fn is_totalLossOfStability(&self) -> bool { self.0 as i128 == 50 }
  pub fn is_unavailable(&self) -> bool { self.0 as i128 == 63 }
}

impl Decode for StabilityLossProbability {
    fn decode<'a, D>(decoder: &D, input: &'a [u8]) -> IResult<&'a [u8], Self>
    where
        D: Decoder,
        Self: Sized,
    {
        decoder
            .decode_integer(AsnInteger { constraint: Some(Constraint { min_value: Some(0), max_value: Some(63), extensible: false }), distinguished_values: Some(vec![DistinguishedValue { name: "stable".into(), value: 0 },DistinguishedValue { name: "totalLossOfStability".into(), value: 50 },DistinguishedValue { name: "unavailable".into(), value: 63 }]) })(input)
            .map(|(remaining, res)| (remaining, Self(res)))
    }
}


/* *
 * The DE represents length as a measure of distance between points or as a dimension of an object or shape. 
 *
 * @unit: 0,1 metre
 * @category: Basic information
 * @revision: Created in V2.1.1
 */
#[derive(Debug, Clone, PartialEq, Default)]
pub struct StandardLength12b(pub u16);

impl Decode for StandardLength12b {
    fn decode<'a, D>(decoder: &D, input: &'a [u8]) -> IResult<&'a [u8], Self>
    where
        D: Decoder,
        Self: Sized,
    {
        decoder
            .decode_integer(AsnInteger { constraint: Some(Constraint { min_value: Some(0), max_value: Some(4095), extensible: false }), distinguished_values: None })(input)
            .map(|(remaining, res)| (remaining, Self(res)))
    }
}


/* *
 * The DE represents length as a measure of distance between points. 
 *
 * The value shall be set to:
 * - 0 `lessThan50m`   - for distances below 50 m, 
 * - 1 `lessThan100m`  - for distances below 100 m,
 * - 2 `lessThan200m`  - for distances below 200 m, 
 * - 3 `lessThan500m`  - for distances below 300 m, 
 * - 4 `lessThan1000m` - for distances below 1 000 m,
 * - 5 `lessThan5km`   - for distances below 5 000 m, 
 * - 6 `lessThan10km`  - for distances below 10 000 m, 
 * - 7 `over10km`      - for distances over 10 000 m.
 *
 * @category: GeoReference information
 * @revision: Created in V2.1.1 from RelevanceDistance
 */
#[derive(Debug, Clone, PartialEq, Default)]
pub enum StandardLength3b {
  #[default]
  lessThan50m = 0,
	lessThan100m = 1,
	lessThan200m = 2,
	lessThan500m = 3,
	lessThan1000m = 4,
	lessThan5km = 5,
	lessThan10km = 6,
	over10km = 7,
}

impl TryFrom<i128> for StandardLength3b {
    type Error = DecodingError;

    fn try_from(v: i128) -> Result<Self, Self::Error> {
        match v {
            x if x == Self::lessThan50m as i128 => Ok(Self::lessThan50m),
		  x if x == Self::lessThan100m as i128 => Ok(Self::lessThan100m),
		  x if x == Self::lessThan200m as i128 => Ok(Self::lessThan200m),
		  x if x == Self::lessThan500m as i128 => Ok(Self::lessThan500m),
		  x if x == Self::lessThan1000m as i128 => Ok(Self::lessThan1000m),
		  x if x == Self::lessThan5km as i128 => Ok(Self::lessThan5km),
		  x if x == Self::lessThan10km as i128 => Ok(Self::lessThan10km),
		  x if x == Self::over10km as i128 => Ok(Self::over10km),
            _ => Err(
              DecodingError::new(
                &format!("Invalid enumerated index decoding StandardLength3b. Received index {}",v), DecodingErrorType::InvalidEnumeratedIndex
              )
            ),
        }
    }
}

impl Decode for StandardLength3b {
    fn decode<'a, D>(decoder: &D, input: &'a [u8]) -> IResult<&'a [u8], Self>
    where
        D: Decoder,
        Self: Sized,
    {
        decoder.decode_enumerated(AsnEnumerated { members: vec![Enumeral { name: "lessThan50m".into(), description: None, index: 0 },Enumeral { name: "lessThan100m".into(), description: None, index: 1 },Enumeral { name: "lessThan200m".into(), description: None, index: 2 },Enumeral { name: "lessThan500m".into(), description: None, index: 3 },Enumeral { name: "lessThan1000m".into(), description: None, index: 4 },Enumeral { name: "lessThan5km".into(), description: None, index: 5 },Enumeral { name: "lessThan10km".into(), description: None, index: 6 },Enumeral { name: "over10km".into(), description: None, index: 7 }], extensible: None })( 
          input
        )
    }
}


/* *
 * The DE represents length as a measure of distance between points or as a dimension of an object. 
 *
 * @unit: 0,1 metre
 * @category: Basic information
 * @revision: Created in V2.1.1
 */
#[derive(Debug, Clone, PartialEq, Default)]
pub struct StandardLength9b(pub u16);

impl Decode for StandardLength9b {
    fn decode<'a, D>(decoder: &D, input: &'a [u8]) -> IResult<&'a [u8], Self>
    where
        D: Decoder,
        Self: Sized,
    {
        decoder
            .decode_integer(AsnInteger { constraint: Some(Constraint { min_value: Some(0), max_value: Some(511), extensible: false }), distinguished_values: None })(input)
            .map(|(remaining, res)| (remaining, Self(res)))
    }
}


/* *
 * The DE represents length as a measure of distance between points or as a dimension of an object. 
 *
 * @unit: 0,1 metre
 * @category: Basic information
 * @revision: Created in V2.1.1
 */
#[derive(Debug, Clone, PartialEq, Default)]
pub struct StandardLength1B(pub u8);

impl Decode for StandardLength1B {
    fn decode<'a, D>(decoder: &D, input: &'a [u8]) -> IResult<&'a [u8], Self>
    where
        D: Decoder,
        Self: Sized,
    {
        decoder
            .decode_integer(AsnInteger { constraint: Some(Constraint { min_value: Some(0), max_value: Some(255), extensible: false }), distinguished_values: None })(input)
            .map(|(remaining, res)| (remaining, Self(res)))
    }
}


/* *
 * The DE represents length as a measure of distance between points or as a dimension of an object.  
 *
 * @unit: 0,1 metre
 * @category: Basic information
 * @revision: Created in V2.1.1
 */
#[derive(Debug, Clone, PartialEq, Default)]
pub struct StandardLength2B(pub u16);

impl Decode for StandardLength2B {
    fn decode<'a, D>(decoder: &D, input: &'a [u8]) -> IResult<&'a [u8], Self>
    where
        D: Decoder,
        Self: Sized,
    {
        decoder
            .decode_integer(AsnInteger { constraint: Some(Constraint { min_value: Some(0), max_value: Some(65535), extensible: false }), distinguished_values: None })(input)
            .map(|(remaining, res)| (remaining, Self(res)))
    }
}


/* *
 * This DE indicates the duration in minutes since which something is stationary.
 * 
 * The value shall be set to:
 * - 0 `lessThan1Minute`         - for being stationary since less than 1 minute, 
 * - 1 `lessThan2Minutes`        - for being stationary since less than 2 minute and for equal to or more than 1 minute,
 * - 2 `lessThan15Minutes`       - for being stationary since less than 15 minutes and for equal to or more than 1 minute,
 * - 3 `equalOrGreater15Minutes` - for being stationary since equal to or more than 15 minutes.
 *
 * @category: Kinematic information
 * @revision: Created in V2.1.1
 */
#[derive(Debug, Clone, PartialEq, Default)]
pub enum StationarySince {
  #[default]
  lessThan1Minute = 0,
	lessThan2Minutes = 1,
	lessThan15Minutes = 2,
	equalOrGreater15Minutes = 3,
}

impl TryFrom<i128> for StationarySince {
    type Error = DecodingError;

    fn try_from(v: i128) -> Result<Self, Self::Error> {
        match v {
            x if x == Self::lessThan1Minute as i128 => Ok(Self::lessThan1Minute),
		  x if x == Self::lessThan2Minutes as i128 => Ok(Self::lessThan2Minutes),
		  x if x == Self::lessThan15Minutes as i128 => Ok(Self::lessThan15Minutes),
		  x if x == Self::equalOrGreater15Minutes as i128 => Ok(Self::equalOrGreater15Minutes),
            _ => Err(
              DecodingError::new(
                &format!("Invalid enumerated index decoding StationarySince. Received index {}",v), DecodingErrorType::InvalidEnumeratedIndex
              )
            ),
        }
    }
}

impl Decode for StationarySince {
    fn decode<'a, D>(decoder: &D, input: &'a [u8]) -> IResult<&'a [u8], Self>
    where
        D: Decoder,
        Self: Sized,
    {
        decoder.decode_enumerated(AsnEnumerated { members: vec![Enumeral { name: "lessThan1Minute".into(), description: None, index: 0 },Enumeral { name: "lessThan2Minutes".into(), description: None, index: 1 },Enumeral { name: "lessThan15Minutes".into(), description: None, index: 2 },Enumeral { name: "equalOrGreater15Minutes".into(), description: None, index: 3 }], extensible: None })( 
          input
        )
    }
}


/* *
 * This DE provides the value of the sub cause codes of the @ref CauseCode "stationaryVehicle". 
 * 
 * The value shall be set to:
 * - 0 `unavailable`           - in case further detailed information on stationary vehicle is unavailable,
 * - 1 `humanProblem`          - in case stationary vehicle is due to health problem of driver or passenger,
 * - 2 `vehicleBreakdown`      - in case stationary vehicle is due to vehicle break down,
 * - 3 `postCrash`             - in case stationary vehicle is caused by collision,
 * - 4 `publicTransportStop`   - in case public transport vehicle is stationary at bus stop,
 * - 5 `carryingDangerousGoods`- in case the stationary vehicle is carrying dangerous goods,
 * - 6 `vehicleOnFire`         - in case of vehicle on fire.
 * - 7-255 reserved for future usage.
 *
 * @category: Traffic information
 * @revision: V1.3.1
 */
#[derive(Debug, Clone, PartialEq, Default)]
pub struct StationaryVehicleSubCauseCode(pub u8);

impl StationaryVehicleSubCauseCode {
  pub fn is_unavailable(&self) -> bool { self.0 as i128 == 0 }
  pub fn is_humanProblem(&self) -> bool { self.0 as i128 == 1 }
  pub fn is_vehicleBreakdown(&self) -> bool { self.0 as i128 == 2 }
  pub fn is_postCrash(&self) -> bool { self.0 as i128 == 3 }
  pub fn is_publicTransportStop(&self) -> bool { self.0 as i128 == 4 }
  pub fn is_carryingDangerousGoods(&self) -> bool { self.0 as i128 == 5 }
  pub fn is_vehicleOnFire(&self) -> bool { self.0 as i128 == 6 }
}

impl Decode for StationaryVehicleSubCauseCode {
    fn decode<'a, D>(decoder: &D, input: &'a [u8]) -> IResult<&'a [u8], Self>
    where
        D: Decoder,
        Self: Sized,
    {
        decoder
            .decode_integer(AsnInteger { constraint: Some(Constraint { min_value: Some(0), max_value: Some(255), extensible: false }), distinguished_values: Some(vec![DistinguishedValue { name: "unavailable".into(), value: 0 },DistinguishedValue { name: "humanProblem".into(), value: 1 },DistinguishedValue { name: "vehicleBreakdown".into(), value: 2 },DistinguishedValue { name: "postCrash".into(), value: 3 },DistinguishedValue { name: "publicTransportStop".into(), value: 4 },DistinguishedValue { name: "carryingDangerousGoods".into(), value: 5 },DistinguishedValue { name: "vehicleOnFire".into(), value: 6 }]) })(input)
            .map(|(remaining, res)| (remaining, Self(res)))
    }
}


/* *
 * This DE represents the identifier of an ITS-S.
 * The ITS-S ID may be a pseudonym. It may change over space and/or over time.
 *
 * @category: Basic information
 * @revision: Created in V2.1.1 based on @ref StationID
 */
#[derive(Debug, Clone, PartialEq, Default)]
pub struct StationId(pub u32);

impl Decode for StationId {
    fn decode<'a, D>(decoder: &D, input: &'a [u8]) -> IResult<&'a [u8], Self>
    where
        D: Decoder,
        Self: Sized,
    {
        decoder
            .decode_integer(AsnInteger { constraint: Some(Constraint { min_value: Some(0), max_value: Some(4294967295), extensible: false }), distinguished_values: None })(input)
            .map(|(remaining, res)| (remaining, Self(res)))
    }
}


/* *
 * This DE represents the identifier of an ITS-S.
 * The ITS-S ID may be a pseudonym. It may change over space and/or over time.
 *
 * @note: this DE is kept for backwards compatibility reasons only. It is recommended to use the @ref StationId instead.
 * @category: Basic information
 * @revision: V1.3.1
 */
#[derive(Debug, Clone, PartialEq, Default)]
pub struct StationID(pub u32);

impl Decode for StationID {
    fn decode<'a, D>(decoder: &D, input: &'a [u8]) -> IResult<&'a [u8], Self>
    where
        D: Decoder,
        Self: Sized,
    {
        decoder
            .decode_integer(AsnInteger { constraint: Some(Constraint { min_value: Some(0), max_value: Some(4294967295), extensible: false }), distinguished_values: None })(input)
            .map(|(remaining, res)| (remaining, Self(res)))
    }
}


/* *
 * This DE represents the type of technical context the ITS-S is integrated in.
 * The station type depends on the integration environment of ITS-S into vehicle, mobile devices or at infrastructure.
 * 
 * The value shall be set to:
 * - 0 `unknown`          - information about the ITS-S context is not provided,
 * - 1 `pedestrian`       - ITS-S carried by human being not using a mechanical device for their trip (VRU profile 1),
 * - 2 `cyclist`          - ITS-S mounted on non-motorized unicycles, bicycles , tricycles, quadracycles (VRU profile 2),
 * - 3 `moped`            - ITS-S mounted on light motor vehicles with less than four wheels as defined in UNECE/TRANS/WP.29/78/Rev.4 [16] 
                            class L1, L2 (VRU Profile 3),
 * - 4 `motorcycles`      - ITS-S mounted on motor vehicles with less than four wheels as defined in UNECE/TRANS/WP.29/78/Rev.4 [16] 
                            class L3, L4, L5, L6, L7 (VRU Profile 3),
 * - 5 `passengerCar`     - ITS-S mounted on small passenger vehicles as defined in UNECE/TRANS/WP.29/78/Rev.4 [16] class M1,
 * - 6 `bus`              - ITS-S mounted on large passenger vehicles as defined in UNECE/TRANS/WP.29/78/Rev.4 [16] class M2, M3,
 * - 7 `lightTruck`       - ITS-S mounted on light Goods Vehicles as defined in UNECE/TRANS/WP.29/78/Rev.4 [16] class N1,
 * - 8 `heavyTruck`       - ITS-S mounted on Heavy Goods Vehicles as defined in UNECE/TRANS/WP.29/78/Rev.4 [16] class N2 and N3,
 * - 9 `trailer`          - ITS-S mounted on an unpowered vehicle that is intended to be towed by a powered vehicle as defined in 
                            UNECE/TRANS/WP.29/78/Rev.4 [16] class O,
 * - 10 `specialVehicles` - ITS-S mounted on vehicles which have special purposes other than the above (e.g. moving road works vehicle),
 * - 11 `tram`            - ITS-S mounted on a vehicle which runs on tracks along public streets,
 * - 12 `lightVruVehicle` - ITS-S carried by a human being traveling on light vehicle , incl. possible use of roller skates or skateboards (VRU profile 2),
 * - 13 `animal`          - ITS-S carried by an animal presenting a safety risk to other road users e.g. domesticated dog in a city or horse (VRU Profile 4),
 * - 14                   - reserved for future usage,
 * - 15 `roadSideUnit`    - ITS-S mounted on an infrastructure typically positioned outside of the drivable roadway (e.g. on a gantry, on a pole, 
                            on a stationary road works trailer); the infrastructure is static during the entire operation period of the ITS-S (e.g. no stop and go activity),
 * - 16-255               - are reserved for future usage.
 * 
 * @note: this DE is kept for backwards compatibility reasons only. It is recommended to use the @ref TrafficParticipantType instead.
 * @category: Communication information.
 * @revision: revised in V2.1.1 (named values 12 and 13 added and note to value 9 deleted)
 */
#[derive(Debug, Clone, PartialEq, Default)]
pub struct StationType(pub u8);

impl StationType {
  pub fn is_unknown(&self) -> bool { self.0 as i128 == 0 }
  pub fn is_pedestrian(&self) -> bool { self.0 as i128 == 1 }
  pub fn is_cyclist(&self) -> bool { self.0 as i128 == 2 }
  pub fn is_moped(&self) -> bool { self.0 as i128 == 3 }
  pub fn is_motorcycle(&self) -> bool { self.0 as i128 == 4 }
  pub fn is_passengerCar(&self) -> bool { self.0 as i128 == 5 }
  pub fn is_bus(&self) -> bool { self.0 as i128 == 6 }
  pub fn is_lightTruck(&self) -> bool { self.0 as i128 == 7 }
  pub fn is_heavyTruck(&self) -> bool { self.0 as i128 == 8 }
  pub fn is_trailer(&self) -> bool { self.0 as i128 == 9 }
  pub fn is_specialVehicle(&self) -> bool { self.0 as i128 == 10 }
  pub fn is_tram(&self) -> bool { self.0 as i128 == 11 }
  pub fn is_lightVruVehicle(&self) -> bool { self.0 as i128 == 12 }
  pub fn is_animal(&self) -> bool { self.0 as i128 == 13 }
  pub fn is_roadSideUnit(&self) -> bool { self.0 as i128 == 15 }
}

impl Decode for StationType {
    fn decode<'a, D>(decoder: &D, input: &'a [u8]) -> IResult<&'a [u8], Self>
    where
        D: Decoder,
        Self: Sized,
    {
        decoder
            .decode_integer(AsnInteger { constraint: Some(Constraint { min_value: Some(0), max_value: Some(255), extensible: false }), distinguished_values: Some(vec![DistinguishedValue { name: "unknown".into(), value: 0 },DistinguishedValue { name: "pedestrian".into(), value: 1 },DistinguishedValue { name: "cyclist".into(), value: 2 },DistinguishedValue { name: "moped".into(), value: 3 },DistinguishedValue { name: "motorcycle".into(), value: 4 },DistinguishedValue { name: "passengerCar".into(), value: 5 },DistinguishedValue { name: "bus".into(), value: 6 },DistinguishedValue { name: "lightTruck".into(), value: 7 },DistinguishedValue { name: "heavyTruck".into(), value: 8 },DistinguishedValue { name: "trailer".into(), value: 9 },DistinguishedValue { name: "specialVehicle".into(), value: 10 },DistinguishedValue { name: "tram".into(), value: 11 },DistinguishedValue { name: "lightVruVehicle".into(), value: 12 },DistinguishedValue { name: "animal".into(), value: 13 },DistinguishedValue { name: "roadSideUnit".into(), value: 15 }]) })(input)
            .map(|(remaining, res)| (remaining, Self(res)))
    }
}


/* *
 * This DE indicates the steering wheel angle confidence value which represents the estimated absolute accuracy for a  steering wheel angle value with a confidence level of 95 %.
 * 
 * The value shall be set to:
 * - `n` (`n > 0` and `n < 126`) if the confidence value is equal to or less than n x 1,5 degrees,
 * - `126` if the confidence value is out of range, i.e. greater than 187,5 degrees,
 * - `127` if the confidence value is not available.
 * 
 * @note: The fact that a steering wheel angle value is received with confidence value set to `unavailable(127)`
 * can be caused by several reasons, such as:
 * - the sensor cannot deliver the accuracy at the defined confidence level because it is a low-end sensor,
 * - the sensor cannot calculate the accuracy due to lack of variables, or
 * - there has been a vehicle bus (e.g. CAN bus) error.
 * In all 3 cases above, the steering wheel angle value may be valid and used by the application.
 * 
 * If a steering wheel angle value is received and its confidence value is set to `outOfRange(126)`,
 * it means that the steering wheel angle value is not valid and therefore cannot be trusted.
 * Such value is not useful for the application.
 * 
 * @unit: 1,5 degree
 * @category: Vehicle Information
 * @revision: Description revised in V2.1.1
*/
#[derive(Debug, Clone, PartialEq, Default)]
pub struct SteeringWheelAngleConfidence(pub u8);

impl SteeringWheelAngleConfidence {
  pub fn is_outOfRange(&self) -> bool { self.0 as i128 == 126 }
  pub fn is_unavailable(&self) -> bool { self.0 as i128 == 127 }
}

impl Decode for SteeringWheelAngleConfidence {
    fn decode<'a, D>(decoder: &D, input: &'a [u8]) -> IResult<&'a [u8], Self>
    where
        D: Decoder,
        Self: Sized,
    {
        decoder
            .decode_integer(AsnInteger { constraint: Some(Constraint { min_value: Some(1), max_value: Some(127), extensible: false }), distinguished_values: Some(vec![DistinguishedValue { name: "outOfRange".into(), value: 126 },DistinguishedValue { name: "unavailable".into(), value: 127 }]) })(input)
            .map(|(remaining, res)| (remaining, Self(res)))
    }
}


/* *
 * This DE represents the steering wheel angle of the vehicle at certain point in time.
 * The value shall be provided in the vehicle coordinate system as defined in ISO 8855 [21], clause 2.11.
 * 
 * The value shall be set to:
 * - `-511` if the steering wheel angle is equal to or greater than 511 x 1,5 degrees = 766,5 degrees to the right,
 * - `n` (`n > -511` and `n <= 0`) if  the steering wheel angle is equal to or less than n x 1,5 degrees, and greater than (n-1) x 1,5 degrees, 
      turning clockwise (i.e. to the right),
 * - `n` (`n >= 1` and `n < 511`) if the steering wheel angle is equal to or less than n x 0,1 degrees, and greater than (n-1) x 0,1 degrees, 
      turning counter-clockwise (i.e. to the left),
 * - `511` if the steering wheel angle is greater than 510 x 1,5 degrees = 765 degrees to the left,
 * - `512` if information is not available.
 *
 * @unit: 1,5 degree
 * @revision: Description revised in V2.1.1 (meaning of value 511 has changed slightly).
 */
#[derive(Debug, Clone, PartialEq, Default)]
pub struct SteeringWheelAngleValue(pub i16);

impl SteeringWheelAngleValue {
  pub fn is_negativeOutOfRange(&self) -> bool { self.0 as i128 == -511 }
  pub fn is_positiveOutOfRange(&self) -> bool { self.0 as i128 == 511 }
  pub fn is_unavailable(&self) -> bool { self.0 as i128 == 512 }
}

impl Decode for SteeringWheelAngleValue {
    fn decode<'a, D>(decoder: &D, input: &'a [u8]) -> IResult<&'a [u8], Self>
    where
        D: Decoder,
        Self: Sized,
    {
        decoder
            .decode_integer(AsnInteger { constraint: Some(Constraint { min_value: Some(-511), max_value: Some(512), extensible: false }), distinguished_values: Some(vec![DistinguishedValue { name: "negativeOutOfRange".into(), value: -511 },DistinguishedValue { name: "positiveOutOfRange".into(), value: 511 },DistinguishedValue { name: "unavailable".into(), value: 512 }]) })(input)
            .map(|(remaining, res)| (remaining, Self(res)))
    }
}


/* *
 * This DE indicates the generic sub cause of a detected event.
 * 
 * @note: The sub cause code value assignment varies based on value of @ref CauseCode.
 *
 * @category: Traffic information
 * @revision: Description revised in V2.1.1 (this is  the generic sub cause type)
 */
#[derive(Debug, Clone, PartialEq, Default)]
pub struct SubCauseCodeType(pub u8);

impl Decode for SubCauseCodeType {
    fn decode<'a, D>(decoder: &D, input: &'a [u8]) -> IResult<&'a [u8], Self>
    where
        D: Decoder,
        Self: Sized,
    {
        decoder
            .decode_integer(AsnInteger { constraint: Some(Constraint { min_value: Some(0), max_value: Some(255), extensible: false }), distinguished_values: None })(input)
            .map(|(remaining, res)| (remaining, Self(res)))
    }
}


/* *
 * This DE indicates a temperature value.

 * The value shall be set to:
 * - `-60` for temperature equal to or less than -60 degrees C,
 * - `n` (`n > -60` and `n < 67`) for the actual temperature n in degrees C,
 * - `67` for temperature equal to or greater than 67 degrees C.
 * 
 * @unit: degrees Celsius
 * @category: Basic information
 * @revision: Editorial update in V2.1.1
 */
#[derive(Debug, Clone, PartialEq, Default)]
pub struct Temperature(pub i8);

impl Temperature {
  pub fn is_equalOrSmallerThanMinus60Deg(&self) -> bool { self.0 as i128 == -60 }
  pub fn is_equalOrGreaterThan67Deg(&self) -> bool { self.0 as i128 == 67 }
}

impl Decode for Temperature {
    fn decode<'a, D>(decoder: &D, input: &'a [u8]) -> IResult<&'a [u8], Self>
    where
        D: Decoder,
        Self: Sized,
    {
        decoder
            .decode_integer(AsnInteger { constraint: Some(Constraint { min_value: Some(-60), max_value: Some(67), extensible: false }), distinguished_values: Some(vec![DistinguishedValue { name: "equalOrSmallerThanMinus60Deg".into(), value: -60 },DistinguishedValue { name: "equalOrGreaterThan67Deg".into(), value: 67 }]) })(input)
            .map(|(remaining, res)| (remaining, Self(res)))
    }
}


/* *
 * This DE represents the number of elapsed (TAI) milliseconds since the ITS Epoch. 
 * The ITS epoch is `00:00:00.000 UTC, 1 January 2004`.
 * "Elapsed" means that the true number of milliseconds is continuously counted without interruption,
 *  i.e. it is not altered by leap seconds, which occur in UTC.
 * 
 * @note: International Atomic Time (TAI) is the time reference coordinate on the basis of the readings of atomic clocks, 
 * operated in accordance with the definition of the second, the unit of time of the International System of Units. 
 * TAI is a continuous time scale. UTC has discontinuities, as it is occasionally adjusted by leap seconds. 
 * As of 1 January, 2022, TimestampIts is 5 seconds ahead of UTC, because since the ITS epoch on 1 January 2004 00:00:00.000 UTC, 
 * further 5 leap seconds have been inserted in UTC.
 * 
 * EXAMPLE: The value for TimestampIts for 1 January 2007 00:00:00.000 UTC is `94 694 401 000` milliseconds,
 * which includes one leap second insertion since the ITS epoch.
 * @unit: 0,001 s
 * @category: Basic information
 * @revision: Description revised in in V2.1.1
 */
#[derive(Debug, Clone, PartialEq, Default)]
pub struct TimestampIts(pub u64);

impl Decode for TimestampIts {
    fn decode<'a, D>(decoder: &D, input: &'a [u8]) -> IResult<&'a [u8], Self>
    where
        D: Decoder,
        Self: Sized,
    {
        decoder
            .decode_integer(AsnInteger { constraint: Some(Constraint { min_value: Some(0), max_value: Some(4398046511103), extensible: false }), distinguished_values: None })(input)
            .map(|(remaining, res)| (remaining, Self(res)))
    }
}


/* *
 * This DE represents the value of the sub cause codes of the @ref CauseCode `trafficCondition`. 
 * 
 * The value shall be set to:
 * - 0 `unavailable`                 - in case further detailed information on traffic jam is unavailable,
 * - 1 `increasedVolumeOfTraffic`    - in case detected jam volume is increased,
 * - 2 `trafficJamSlowlyIncreasing`  - in case detected traffic jam volume is increasing slowly,
 * - 3 `trafficJamIncreasing`        - in case traffic jam volume is increasing,
 * - 4 `trafficJamStronglyIncreasing`- in case traffic jam volume is strongly increasing,
 * - 5 `trafficStationary`           - in case traffic is stationary,
 * - 6 `trafficJamSlightlyDecreasing`- in case traffic jam volume is decreasing slowly,
 * - 7 `trafficJamDecreasing`        - in case traffic jam volume is decreasing,
 * - 8 `trafficJamStronglyDecreasing`- in case traffic jam volume is decreasing rapidly,
 * - 9-255: reserved for future usage.
 *
 * @category: Traffic information
 * @revision: V1.3.1
 */
#[derive(Debug, Clone, PartialEq, Default)]
pub struct TrafficConditionSubCauseCode(pub u8);

impl TrafficConditionSubCauseCode {
  pub fn is_unavailable(&self) -> bool { self.0 as i128 == 0 }
  pub fn is_increasedVolumeOfTraffic(&self) -> bool { self.0 as i128 == 1 }
  pub fn is_trafficJamSlowlyIncreasing(&self) -> bool { self.0 as i128 == 2 }
  pub fn is_trafficJamIncreasing(&self) -> bool { self.0 as i128 == 3 }
  pub fn is_trafficJamStronglyIncreasing(&self) -> bool { self.0 as i128 == 4 }
  pub fn is_trafficStationary(&self) -> bool { self.0 as i128 == 5 }
  pub fn is_trafficJamSlightlyDecreasing(&self) -> bool { self.0 as i128 == 6 }
  pub fn is_trafficJamDecreasing(&self) -> bool { self.0 as i128 == 7 }
  pub fn is_trafficJamStronglyDecreasing(&self) -> bool { self.0 as i128 == 8 }
}

impl Decode for TrafficConditionSubCauseCode {
    fn decode<'a, D>(decoder: &D, input: &'a [u8]) -> IResult<&'a [u8], Self>
    where
        D: Decoder,
        Self: Sized,
    {
        decoder
            .decode_integer(AsnInteger { constraint: Some(Constraint { min_value: Some(0), max_value: Some(255), extensible: false }), distinguished_values: Some(vec![DistinguishedValue { name: "unavailable".into(), value: 0 },DistinguishedValue { name: "increasedVolumeOfTraffic".into(), value: 1 },DistinguishedValue { name: "trafficJamSlowlyIncreasing".into(), value: 2 },DistinguishedValue { name: "trafficJamIncreasing".into(), value: 3 },DistinguishedValue { name: "trafficJamStronglyIncreasing".into(), value: 4 },DistinguishedValue { name: "trafficStationary".into(), value: 5 },DistinguishedValue { name: "trafficJamSlightlyDecreasing".into(), value: 6 },DistinguishedValue { name: "trafficJamDecreasing".into(), value: 7 },DistinguishedValue { name: "trafficJamStronglyDecreasing".into(), value: 8 }]) })(input)
            .map(|(remaining, res)| (remaining, Self(res)))
    }
}


/* *
 * This DE indicates a traffic direction that is relevant to information indicated in a message.
 * 
 * The value shall be set to:
 * - 0 `allTrafficDirections` - for all traffic directions, 
 * - 1 `upstreamTraffic`      - for upstream traffic, 
 * - 2 `downstreamTraffic`    - for downstream traffic, 
 * - 3 `oppositeTraffic`      - for traffic in the opposite direction. 
 *
 * The terms `upstream`, `downstream` and `oppositeTraffic` are relative to the event position.
 *
 * @note: Upstream traffic corresponds to the incoming traffic towards the event position,
 * and downstream traffic to the departing traffic away from the event position.
 *
 * @category: GeoReference information
 * @revision: Created in V2.1.1 from RelevanceTrafficDirection
 */
#[derive(Debug, Clone, PartialEq, Default)]
pub enum TrafficDirection {
  #[default]
  allTrafficDirections = 0,
	upstreamTraffic = 1,
	downstreamTraffic = 2,
	oppositeTraffic = 3,
}

impl TryFrom<i128> for TrafficDirection {
    type Error = DecodingError;

    fn try_from(v: i128) -> Result<Self, Self::Error> {
        match v {
            x if x == Self::allTrafficDirections as i128 => Ok(Self::allTrafficDirections),
		  x if x == Self::upstreamTraffic as i128 => Ok(Self::upstreamTraffic),
		  x if x == Self::downstreamTraffic as i128 => Ok(Self::downstreamTraffic),
		  x if x == Self::oppositeTraffic as i128 => Ok(Self::oppositeTraffic),
            _ => Err(
              DecodingError::new(
                &format!("Invalid enumerated index decoding TrafficDirection. Received index {}",v), DecodingErrorType::InvalidEnumeratedIndex
              )
            ),
        }
    }
}

impl Decode for TrafficDirection {
    fn decode<'a, D>(decoder: &D, input: &'a [u8]) -> IResult<&'a [u8], Self>
    where
        D: Decoder,
        Self: Sized,
    {
        decoder.decode_enumerated(AsnEnumerated { members: vec![Enumeral { name: "allTrafficDirections".into(), description: None, index: 0 },Enumeral { name: "upstreamTraffic".into(), description: None, index: 1 },Enumeral { name: "downstreamTraffic".into(), description: None, index: 2 },Enumeral { name: "oppositeTraffic".into(), description: None, index: 3 }], extensible: None })( 
          input
        )
    }
}


/* *
 * This DE represents the type of a traffic participant.
 * 
 * The value shall be set to:
 * - 0 `unknown`          - information about traffic participant is not provided,
 * - 1 `pedestrian`       - human being not using a mechanical device for their trip (VRU profile 1),
 * - 2 `cyclist`          - non-motorized unicycles, bicycles , tricycles, quadracycles (VRU profile 2),
 * - 3 `moped`            - light motor vehicles with less than four wheels as defined in UNECE/TRANS/WP.29/78/Rev.4 [16] class L1, L2 (VRU Profile 3),
 * - 4 `motorcycles`      - motor vehicles with less than four wheels as defined in UNECE/TRANS/WP.29/78/Rev.4 [16] class L3, L4, L5, L6, L7 (VRU Profile 3),
 * - 5 `passengerCar`     - small passenger vehicles as defined in UNECE/TRANS/WP.29/78/Rev.4 [16] class M1,
 * - 6 `bus`              - large passenger vehicles as defined in UNECE/TRANS/WP.29/78/Rev.4 [16] class M2, M3,
 * - 7 `lightTruck`       - light Goods Vehicles as defined in UNECE/TRANS/WP.29/78/Rev.4 [16] class N1,
 * - 8 `heavyTruck`       - Heavy Goods Vehicles as defined in UNECE/TRANS/WP.29/78/Rev.4 [16] class N2 and N3,
 * - 9 `trailer`          - unpowered vehicle that is intended to be towed by a powered vehicle as defined in UNECE/TRANS/WP.29/78/Rev.4 [16] class O,
 * - 10 `specialVehicles` - vehicles which have special purposes other than the above (e.g. moving road works vehicle),
 * - 11 `tram`            - vehicle which runs on tracks along public streets,
 * - 12 `lightVruVehicle` - human being traveling on light vehicle, incl. possible use of roller skates or skateboards (VRU profile 2),
 * - 13 `animal`          - animal presenting a safety risk to other road users e.g. domesticated dog in a city or horse (VRU Profile 4),
 * - 14 `agricultural`    - agricultural and forestry vehicles as defined in UNECE/TRANS/WP.29/78/Rev.4 [16] class T,
 * - 15 `roadSideUnit`    - infrastructure typically positioned outside of the drivable roadway (e.g. on a gantry, on a pole, 
                            on a stationary road works trailer); the infrastructure is static during the entire operation period of the ITS-S (e.g. no stop and go activity),
 * - 16-255               - are reserved for future usage.
 * 
 * @category: Communication information.
 * @revision: Created in V2.1.1 based on StationType
 */
#[derive(Debug, Clone, PartialEq, Default)]
pub struct TrafficParticipantType(pub u8);

impl TrafficParticipantType {
  pub fn is_unknown(&self) -> bool { self.0 as i128 == 0 }
  pub fn is_pedestrian(&self) -> bool { self.0 as i128 == 1 }
  pub fn is_cyclist(&self) -> bool { self.0 as i128 == 2 }
  pub fn is_moped(&self) -> bool { self.0 as i128 == 3 }
  pub fn is_motorcycle(&self) -> bool { self.0 as i128 == 4 }
  pub fn is_passengerCar(&self) -> bool { self.0 as i128 == 5 }
  pub fn is_bus(&self) -> bool { self.0 as i128 == 6 }
  pub fn is_lightTruck(&self) -> bool { self.0 as i128 == 7 }
  pub fn is_heavyTruck(&self) -> bool { self.0 as i128 == 8 }
  pub fn is_trailer(&self) -> bool { self.0 as i128 == 9 }
  pub fn is_specialVehicle(&self) -> bool { self.0 as i128 == 10 }
  pub fn is_tram(&self) -> bool { self.0 as i128 == 11 }
  pub fn is_lightVruVehicle(&self) -> bool { self.0 as i128 == 12 }
  pub fn is_animal(&self) -> bool { self.0 as i128 == 13 }
  pub fn is_agricultural(&self) -> bool { self.0 as i128 == 14 }
  pub fn is_roadSideUnit(&self) -> bool { self.0 as i128 == 15 }
}

impl Decode for TrafficParticipantType {
    fn decode<'a, D>(decoder: &D, input: &'a [u8]) -> IResult<&'a [u8], Self>
    where
        D: Decoder,
        Self: Sized,
    {
        decoder
            .decode_integer(AsnInteger { constraint: Some(Constraint { min_value: Some(0), max_value: Some(255), extensible: false }), distinguished_values: Some(vec![DistinguishedValue { name: "unknown".into(), value: 0 },DistinguishedValue { name: "pedestrian".into(), value: 1 },DistinguishedValue { name: "cyclist".into(), value: 2 },DistinguishedValue { name: "moped".into(), value: 3 },DistinguishedValue { name: "motorcycle".into(), value: 4 },DistinguishedValue { name: "passengerCar".into(), value: 5 },DistinguishedValue { name: "bus".into(), value: 6 },DistinguishedValue { name: "lightTruck".into(), value: 7 },DistinguishedValue { name: "heavyTruck".into(), value: 8 },DistinguishedValue { name: "trailer".into(), value: 9 },DistinguishedValue { name: "specialVehicle".into(), value: 10 },DistinguishedValue { name: "tram".into(), value: 11 },DistinguishedValue { name: "lightVruVehicle".into(), value: 12 },DistinguishedValue { name: "animal".into(), value: 13 },DistinguishedValue { name: "agricultural".into(), value: 14 },DistinguishedValue { name: "roadSideUnit".into(), value: 15 }]) })(input)
            .map(|(remaining, res)| (remaining, Self(res)))
    }
}


/* *
 * This DE indicates traffic rules that apply to vehicles at a certain position.
 *
 * The value shall be set to:
 * - `0` - if overtaking is prohibited for all vehicles,
 * - `1` - if overtaking is prohibited for trucks,
 * - `2` - if vehicles should pass to the right lane,
 * - `3` - if vehicles should pass to the left lane.
 *
 * @category: Infrastructure information, Traffic information
 * @revision: Editorial update in V2.1.1
 */
#[derive(Debug, Clone, PartialEq, Default)]
pub enum TrafficRule {
  #[default]
  noPassing = 0,
	noPassingForTrucks = 1,
	passToRight = 2,
	passToLeft = 3,
}

impl TryFrom<i128> for TrafficRule {
    type Error = DecodingError;

    fn try_from(v: i128) -> Result<Self, Self::Error> {
        match v {
            x if x == Self::noPassing as i128 => Ok(Self::noPassing),
		  x if x == Self::noPassingForTrucks as i128 => Ok(Self::noPassingForTrucks),
		  x if x == Self::passToRight as i128 => Ok(Self::passToRight),
		  x if x == Self::passToLeft as i128 => Ok(Self::passToLeft),
            _ => Err(
              DecodingError::new(
                &format!("Invalid enumerated index decoding TrafficRule. Received index {}",v), DecodingErrorType::InvalidEnumeratedIndex
              )
            ),
        }
    }
}

impl Decode for TrafficRule {
    fn decode<'a, D>(decoder: &D, input: &'a [u8]) -> IResult<&'a [u8], Self>
    where
        D: Decoder,
        Self: Sized,
    {
        decoder.decode_enumerated(AsnEnumerated { members: vec![Enumeral { name: "noPassing".into(), description: None, index: 0 },Enumeral { name: "noPassingForTrucks".into(), description: None, index: 1 },Enumeral { name: "passToRight".into(), description: None, index: 2 },Enumeral { name: "passToLeft".into(), description: None, index: 3 }], extensible: Some(4) })( 
          input
        )
    }
}


/* *
 * This DE provides information about the presence of a trailer. 
 *
 * The value shall be set to:
 * - 0 `noTrailerPresent`                - to indicate that no trailer is present, i.e. either the vehicle is physically not enabled to tow a trailer or it has been detected that no trailer is present.
 * - 1 `trailerPresentWithKnownLength`   - to indicate that a trailer has been detected as present and the length is included in the vehicle length value.
 * - 2 `trailerPresentWithUnknownLength` - to indicate that a trailer has been detected as present and the length is not included in the vehicle length value.
 * - 3 `trailerPresenceIsUnknown`        - to indicate that information about the trailer presence is unknown, i.e. the vehicle is physically enabled to tow a trailer but the detection of trailer presence/absence is not possible.
 * - 4 `unavailable`                     - to indicate that the information about the presence of a trailer is not available, i.e. it is neither known whether the vehicle is able to tow a trailer 
 *                                         nor the detection of trailer presence/absence is possible.
 * 
 * @category: Vehicle information
 * @revision: Created in V2.1.1 based on VehicleLengthConfidenceIndication
*/
#[derive(Debug, Clone, PartialEq, Default)]
pub enum TrailerPresenceInformation {
  #[default]
  noTrailerPresent = 0,
	trailerPresentWithKnownLength = 1,
	trailerPresentWithUnknownLength = 2,
	trailerPresenceIsUnknown = 3,
	unavailable = 4,
}

impl TryFrom<i128> for TrailerPresenceInformation {
    type Error = DecodingError;

    fn try_from(v: i128) -> Result<Self, Self::Error> {
        match v {
            x if x == Self::noTrailerPresent as i128 => Ok(Self::noTrailerPresent),
		  x if x == Self::trailerPresentWithKnownLength as i128 => Ok(Self::trailerPresentWithKnownLength),
		  x if x == Self::trailerPresentWithUnknownLength as i128 => Ok(Self::trailerPresentWithUnknownLength),
		  x if x == Self::trailerPresenceIsUnknown as i128 => Ok(Self::trailerPresenceIsUnknown),
		  x if x == Self::unavailable as i128 => Ok(Self::unavailable),
            _ => Err(
              DecodingError::new(
                &format!("Invalid enumerated index decoding TrailerPresenceInformation. Received index {}",v), DecodingErrorType::InvalidEnumeratedIndex
              )
            ),
        }
    }
}

impl Decode for TrailerPresenceInformation {
    fn decode<'a, D>(decoder: &D, input: &'a [u8]) -> IResult<&'a [u8], Self>
    where
        D: Decoder,
        Self: Sized,
    {
        decoder.decode_enumerated(AsnEnumerated { members: vec![Enumeral { name: "noTrailerPresent".into(), description: None, index: 0 },Enumeral { name: "trailerPresentWithKnownLength".into(), description: None, index: 1 },Enumeral { name: "trailerPresentWithUnknownLength".into(), description: None, index: 2 },Enumeral { name: "trailerPresenceIsUnknown".into(), description: None, index: 3 },Enumeral { name: "unavailable".into(), description: None, index: 4 }], extensible: None })( 
          input
        )
    }
}


/* *
 * This  DE  defines  the  probability  that the ego trajectory  intercepts  with any  other object's  trajectory  on the  road. 
 * 
 * The value shall be set to:
 * - `n` (`n >= 0` and `n <= 50`) to indicate the actual probability,
 * - the values between 51 and 62 are reserved,
 * - `63`: to indicate that the information is unavailable. 
 *
 * @unit: 2 %
 * @category: Kinematic information
 * @revision: Created in V2.1.1
 */
#[derive(Debug, Clone, PartialEq, Default)]
pub struct TrajectoryInterceptionProbability(pub u8);

impl TrajectoryInterceptionProbability {
  pub fn is_unavailable(&self) -> bool { self.0 as i128 == 63 }
}

impl Decode for TrajectoryInterceptionProbability {
    fn decode<'a, D>(decoder: &D, input: &'a [u8]) -> IResult<&'a [u8], Self>
    where
        D: Decoder,
        Self: Sized,
    {
        decoder
            .decode_integer(AsnInteger { constraint: Some(Constraint { min_value: Some(0), max_value: Some(63), extensible: false }), distinguished_values: Some(vec![DistinguishedValue { name: "unavailable".into(), value: 63 }]) })(input)
            .map(|(remaining, res)| (remaining, Self(res)))
    }
}


/* *
 * This DE  defines  the  confidence level of the trajectoryInterceptionProbability.
 *
 * The value shall be set to:
 * - `0` - to indicate confidence level less than 50 %,
 * - `1` - to indicate confidence level greater than or equal to 50 % and less than 70 %,
 * - `2` - to indicate confidence level greater than or equal to 70 % and less than 90 %,
 * - `3` - to indicate confidence level greater than or equal to 90%.
 * 
 * @category: Kinematic information
 * @revision: Created in V2.1.1
 */
#[derive(Debug, Clone, PartialEq, Default)]
pub struct TrajectoryInterceptionConfidence(pub u8);

impl TrajectoryInterceptionConfidence {
  pub fn is_lessthan50percent(&self) -> bool { self.0 as i128 == 0 }
  pub fn is_between50and70Percent(&self) -> bool { self.0 as i128 == 1 }
  pub fn is_between70and90Percent(&self) -> bool { self.0 as i128 == 2 }
  pub fn is_above90Percent(&self) -> bool { self.0 as i128 == 3 }
}

impl Decode for TrajectoryInterceptionConfidence {
    fn decode<'a, D>(decoder: &D, input: &'a [u8]) -> IResult<&'a [u8], Self>
    where
        D: Decoder,
        Self: Sized,
    {
        decoder
            .decode_integer(AsnInteger { constraint: Some(Constraint { min_value: Some(0), max_value: Some(3), extensible: false }), distinguished_values: Some(vec![DistinguishedValue { name: "lessthan50percent".into(), value: 0 },DistinguishedValue { name: "between50and70Percent".into(), value: 1 },DistinguishedValue { name: "between70and90Percent".into(), value: 2 },DistinguishedValue { name: "above90Percent".into(), value: 3 }]) })(input)
            .map(|(remaining, res)| (remaining, Self(res)))
    }
}


/* *
 * This DE represents the time interval between two consecutive message transmissions.
 * 
 * @note: this DE is kept for backwards compatibility reasons only. It is recommended to use the @ref DeltaTimeMilliSecondPos instead.
 * @unit: 0,001 s
 * @category: Basic information
 * @revision: V1.3.1
 */
#[derive(Debug, Clone, PartialEq, Default)]
pub struct TransmissionInterval(pub u16);

impl Decode for TransmissionInterval {
    fn decode<'a, D>(decoder: &D, input: &'a [u8]) -> IResult<&'a [u8], Self>
    where
        D: Decoder,
        Self: Sized,
    {
        decoder
            .decode_integer(AsnInteger { constraint: Some(Constraint { min_value: Some(1), max_value: Some(10000), extensible: false }), distinguished_values: None })(input)
            .map(|(remaining, res)| (remaining, Self(res)))
    }
}


/* *
 * This DE provides the turning direction. 
 * 
 * The value shall be set to:
 * - `left`  for turning to te left.
 * - `right` for turing to the right.
 *
 * @category: Kinematic information
 * @revision: Created in V2.1.1
 */
#[derive(Debug, Clone, PartialEq, Default)]
pub enum TurningDirection {
  #[default]
  left = 0,
	right = 1,
}

impl TryFrom<i128> for TurningDirection {
    type Error = DecodingError;

    fn try_from(v: i128) -> Result<Self, Self::Error> {
        match v {
            x if x == Self::left as i128 => Ok(Self::left),
		  x if x == Self::right as i128 => Ok(Self::right),
            _ => Err(
              DecodingError::new(
                &format!("Invalid enumerated index decoding TurningDirection. Received index {}",v), DecodingErrorType::InvalidEnumeratedIndex
              )
            ),
        }
    }
}

impl Decode for TurningDirection {
    fn decode<'a, D>(decoder: &D, input: &'a [u8]) -> IResult<&'a [u8], Self>
    where
        D: Decoder,
        Self: Sized,
    {
        decoder.decode_enumerated(AsnEnumerated { members: vec![Enumeral { name: "left".into(), description: None, index: 0 },Enumeral { name: "right".into(), description: None, index: 1 }], extensible: None })( 
          input
        )
    }
}


/* *
 * This DE represents the smallest circular turn (i.e. U-turn) that the vehicle is capable of making.
 *
 * The value shall be set to:
 * - `n` (`n > 0` and `n < 254`) to indicate the applicable value is equal to or less than n x 0,4 metre, and greater than (n-1) x 0,4 metre,
 * - `254` to indicate that the turning radius is  greater than 253 x 0,4 metre = 101.2 metres,
 * - `255` to indicate that the information is unavailable.
 * 
 * For vehicle with tracker, the turning radius applies to the vehicle only.
 *
 * @category: Vehicle information
 * @unit 0,4 metre
 * @revision: Description revised V2.1.1 (the meaning of 254 has changed slightly)
 */
#[derive(Debug, Clone, PartialEq, Default)]
pub struct TurningRadius(pub u8);

impl TurningRadius {
  pub fn is_outOfRange(&self) -> bool { self.0 as i128 == 254 }
  pub fn is_unavailable(&self) -> bool { self.0 as i128 == 255 }
}

impl Decode for TurningRadius {
    fn decode<'a, D>(decoder: &D, input: &'a [u8]) -> IResult<&'a [u8], Self>
    where
        D: Decoder,
        Self: Sized,
    {
        decoder
            .decode_integer(AsnInteger { constraint: Some(Constraint { min_value: Some(1), max_value: Some(255), extensible: false }), distinguished_values: Some(vec![DistinguishedValue { name: "outOfRange".into(), value: 254 },DistinguishedValue { name: "unavailable".into(), value: 255 }]) })(input)
            .map(|(remaining, res)| (remaining, Self(res)))
    }
}


/* * 
 * This DE represents the duration of a traffic event validity. 
 *
 * @note: this DE is kept for backwards compatibility reasons only. It is recommended to use the @ref DeltaTimeSecond instead.
 * @unit: 1 s
 * @category: Basic information
 * @revision: V1.3.1
*/
#[derive(Debug, Clone, PartialEq, Default)]
pub struct ValidityDuration(pub u32);

impl ValidityDuration {
  pub fn is_timeOfDetection(&self) -> bool { self.0 as i128 == 0 }
  pub fn is_oneSecondAfterDetection(&self) -> bool { self.0 as i128 == 1 }
}

impl Decode for ValidityDuration {
    fn decode<'a, D>(decoder: &D, input: &'a [u8]) -> IResult<&'a [u8], Self>
    where
        D: Decoder,
        Self: Sized,
    {
        decoder
            .decode_integer(AsnInteger { constraint: Some(Constraint { min_value: Some(0), max_value: Some(86400), extensible: false }), distinguished_values: Some(vec![DistinguishedValue { name: "timeOfDetection".into(), value: 0 },DistinguishedValue { name: "oneSecondAfterDetection".into(), value: 1 }]) })(input)
            .map(|(remaining, res)| (remaining, Self(res)))
    }
}


/* *
 * This DE represents the value of the sub cause codes of the @ref CauseCode `vehicleBreakdown`. 
 * 
 * The value shall be set to:
 * - 0 `unavailable`         - in case further detailed information on cause of vehicle break down is unavailable,
 * - 1 `lackOfFuel`          - in case vehicle break down is due to lack of fuel,
 * - 2 `lackOfBatteryPower`  - in case vehicle break down is caused by lack of battery power,
 * - 3 `engineProblem`       - in case vehicle break down is caused by an engine problem,
 * - 4 `transmissionProblem` - in case vehicle break down is caused by transmission problem,
 * - 5 `engineCoolingProblem`- in case vehicle break down is caused by an engine cooling problem,
 * - 6 `brakingSystemProblem`- in case vehicle break down is caused by a braking system problem,
 * - 7 `steeringProblem`     - in case vehicle break down is caused by a steering problem,
 * - 8 `tyrePuncture`        - in case vehicle break down is caused by tyre puncture,
 * - 9 `tyrePressureProblem` - in case low tyre pressure in detected,
 * - 10 `vehicleOnFire`      - in case the vehicle is on fire.
 * - 11-255                  - are reserved for future usage.
 *
 * @category: Traffic information

 */
#[derive(Debug, Clone, PartialEq, Default)]
pub struct VehicleBreakdownSubCauseCode(pub u8);

impl VehicleBreakdownSubCauseCode {
  pub fn is_unavailable(&self) -> bool { self.0 as i128 == 0 }
  pub fn is_lackOfFuel(&self) -> bool { self.0 as i128 == 1 }
  pub fn is_lackOfBatteryPower(&self) -> bool { self.0 as i128 == 2 }
  pub fn is_engineProblem(&self) -> bool { self.0 as i128 == 3 }
  pub fn is_transmissionProblem(&self) -> bool { self.0 as i128 == 4 }
  pub fn is_engineCoolingProblem(&self) -> bool { self.0 as i128 == 5 }
  pub fn is_brakingSystemProblem(&self) -> bool { self.0 as i128 == 6 }
  pub fn is_steeringProblem(&self) -> bool { self.0 as i128 == 7 }
  pub fn is_tyrePuncture(&self) -> bool { self.0 as i128 == 8 }
  pub fn is_tyrePressureProblem(&self) -> bool { self.0 as i128 == 9 }
  pub fn is_vehicleOnFire(&self) -> bool { self.0 as i128 == 10 }
}

impl Decode for VehicleBreakdownSubCauseCode {
    fn decode<'a, D>(decoder: &D, input: &'a [u8]) -> IResult<&'a [u8], Self>
    where
        D: Decoder,
        Self: Sized,
    {
        decoder
            .decode_integer(AsnInteger { constraint: Some(Constraint { min_value: Some(0), max_value: Some(255), extensible: false }), distinguished_values: Some(vec![DistinguishedValue { name: "unavailable".into(), value: 0 },DistinguishedValue { name: "lackOfFuel".into(), value: 1 },DistinguishedValue { name: "lackOfBatteryPower".into(), value: 2 },DistinguishedValue { name: "engineProblem".into(), value: 3 },DistinguishedValue { name: "transmissionProblem".into(), value: 4 },DistinguishedValue { name: "engineCoolingProblem".into(), value: 5 },DistinguishedValue { name: "brakingSystemProblem".into(), value: 6 },DistinguishedValue { name: "steeringProblem".into(), value: 7 },DistinguishedValue { name: "tyrePuncture".into(), value: 8 },DistinguishedValue { name: "tyrePressureProblem".into(), value: 9 },DistinguishedValue { name: "vehicleOnFire".into(), value: 10 }]) })(input)
            .map(|(remaining, res)| (remaining, Self(res)))
    }
}


/* * 
 * This DE represents the height of the vehicle, measured from the ground to the highest point, excluding any antennas.
 * In case vehicles are equipped with adjustable ride heights, camper shells, and any other
 * equipment which may result in varying height, the largest possible height shall be used.
 *
 * The value shall be set to:
 * - `n` (`n >0` and `n < 127`) indicates the applicable value is equal to or less than n x 0,05 metre, and greater than (n-1) x 0,05 metre,
 * - `127` indicates that the vehicle width is greater than 6,3 metres,
 * - `128` indicates that the information in unavailable.
 *
 * @unit: 0,05 metre 
 * @category: Vehicle information
 * @revision: created in V2.1.1
*/
#[derive(Debug, Clone, PartialEq, Default)]
pub struct VehicleHeight(pub u8);

impl VehicleHeight {
  pub fn is_outOfRange(&self) -> bool { self.0 as i128 == 126 }
  pub fn is_unavailable(&self) -> bool { self.0 as i128 == 127 }
}

impl Decode for VehicleHeight {
    fn decode<'a, D>(decoder: &D, input: &'a [u8]) -> IResult<&'a [u8], Self>
    where
        D: Decoder,
        Self: Sized,
    {
        decoder
            .decode_integer(AsnInteger { constraint: Some(Constraint { min_value: Some(1), max_value: Some(128), extensible: false }), distinguished_values: Some(vec![DistinguishedValue { name: "outOfRange".into(), value: 126 },DistinguishedValue { name: "unavailable".into(), value: 127 }]) })(input)
            .map(|(remaining, res)| (remaining, Self(res)))
    }
}


/* *
 * This DE provides information about the presence of a trailer. 
 *
 * The value shall be set to:
 * - 0 `noTrailerPresent`                - to indicate that no trailer is present, i.e. either the vehicle is physically not enabled to tow a trailer or it has been detected that no trailer is present,
 * - 1 `trailerPresentWithKnownLength`   - to indicate that a trailer has been detected as present and the length is  included in the vehicle length value,
 * - 2 `trailerPresentWithUnknownLength` - to indicate that a trailer has been detected as present and the length is not included in the vehicle length value,
 * - 3 `trailerPresenceIsUnknown`        - to indicate that information about the trailer presence is unknown, i.e. the vehicle is physically enabled to tow a trailer but the detection of trailer presence/absence is not possible,
 * - 4 `unavailable`                     - to indicate that the information about the presence of a trailer is not available, i.e. it is neither known whether the vehicle is able to tow a trailer, 
 *                                        nor the detection of trailer presence/absence is possible.
 * 
 * @note: this DE is kept for backwards compatibility reasons only. It is recommended to use the @ref TrailerPresenceInformation instead. 
 * @category: Vehicle information
 * @revision: Description revised in V2.1.1
*/
#[derive(Debug, Clone, PartialEq, Default)]
pub enum VehicleLengthConfidenceIndication {
  #[default]
  noTrailerPresent = 0,
	trailerPresentWithKnownLength = 1,
	trailerPresentWithUnknownLength = 2,
	trailerPresenceIsUnknown = 3,
	unavailable = 4,
}

impl TryFrom<i128> for VehicleLengthConfidenceIndication {
    type Error = DecodingError;

    fn try_from(v: i128) -> Result<Self, Self::Error> {
        match v {
            x if x == Self::noTrailerPresent as i128 => Ok(Self::noTrailerPresent),
		  x if x == Self::trailerPresentWithKnownLength as i128 => Ok(Self::trailerPresentWithKnownLength),
		  x if x == Self::trailerPresentWithUnknownLength as i128 => Ok(Self::trailerPresentWithUnknownLength),
		  x if x == Self::trailerPresenceIsUnknown as i128 => Ok(Self::trailerPresenceIsUnknown),
		  x if x == Self::unavailable as i128 => Ok(Self::unavailable),
            _ => Err(
              DecodingError::new(
                &format!("Invalid enumerated index decoding VehicleLengthConfidenceIndication. Received index {}",v), DecodingErrorType::InvalidEnumeratedIndex
              )
            ),
        }
    }
}

impl Decode for VehicleLengthConfidenceIndication {
    fn decode<'a, D>(decoder: &D, input: &'a [u8]) -> IResult<&'a [u8], Self>
    where
        D: Decoder,
        Self: Sized,
    {
        decoder.decode_enumerated(AsnEnumerated { members: vec![Enumeral { name: "noTrailerPresent".into(), description: None, index: 0 },Enumeral { name: "trailerPresentWithKnownLength".into(), description: None, index: 1 },Enumeral { name: "trailerPresentWithUnknownLength".into(), description: None, index: 2 },Enumeral { name: "trailerPresenceIsUnknown".into(), description: None, index: 3 },Enumeral { name: "unavailable".into(), description: None, index: 4 }], extensible: None })( 
          input
        )
    }
}


/* *
 * This DE represents the length of a vehicle.
 *
 * The value shall be set to:
 * - `n` (`n > 0` and `n < 1022`) to indicate the applicable value n is equal to or less than n x 0,1 metre, and greater than (n-1) x 0,1 metre,
 * - `1 022` to indicate that the vehicle length is greater than 102.1 metres,
 * - `1 023` to indicate that the information in unavailable.
 * 
 * 
 * @unit: 0,1 metre
 * @category: Vehicle information
 * @revision: Description updated in V2.1.1 (the meaning of 1 022 has changed slightly).
 */
#[derive(Debug, Clone, PartialEq, Default)]
pub struct VehicleLengthValue(pub u16);

impl VehicleLengthValue {
  pub fn is_outOfRange(&self) -> bool { self.0 as i128 == 1022 }
  pub fn is_unavailable(&self) -> bool { self.0 as i128 == 1023 }
}

impl Decode for VehicleLengthValue {
    fn decode<'a, D>(decoder: &D, input: &'a [u8]) -> IResult<&'a [u8], Self>
    where
        D: Decoder,
        Self: Sized,
    {
        decoder
            .decode_integer(AsnInteger { constraint: Some(Constraint { min_value: Some(1), max_value: Some(1023), extensible: false }), distinguished_values: Some(vec![DistinguishedValue { name: "outOfRange".into(), value: 1022 },DistinguishedValue { name: "unavailable".into(), value: 1023 }]) })(input)
            .map(|(remaining, res)| (remaining, Self(res)))
    }
}


/* *
 * This DE represents the mass of an empty loaded vehicle.
 *
 * The value shall be set to: 
 * - `n` (`n > 0` and `n < 1023`) to indicate that the applicable value is equal to or less than n x 10^5 gramm, and greater than (n-1) x 10^5 gramm,
 * - `1 023` indicates that the vehicle mass is greater than 102 200 000 g,
 * - `1 024` indicates  the vehicle mass information is unavailable.
 * 
 * @note:	The empty load vehicle is defined in ISO 1176 [8], clause 4.6.
 * 
 * @unit: 10^5 gramm
 * @category: Vehicle information
 * @revision: Description updated in V2.1.1 (the meaning of 1 023 has changed slightly).
*/
#[derive(Debug, Clone, PartialEq, Default)]
pub struct VehicleMass(pub u16);

impl VehicleMass {
  pub fn is_outOfRange(&self) -> bool { self.0 as i128 == 1023 }
  pub fn is_unavailable(&self) -> bool { self.0 as i128 == 1024 }
}

impl Decode for VehicleMass {
    fn decode<'a, D>(decoder: &D, input: &'a [u8]) -> IResult<&'a [u8], Self>
    where
        D: Decoder,
        Self: Sized,
    {
        decoder
            .decode_integer(AsnInteger { constraint: Some(Constraint { min_value: Some(1), max_value: Some(1024), extensible: false }), distinguished_values: Some(vec![DistinguishedValue { name: "outOfRange".into(), value: 1023 },DistinguishedValue { name: "unavailable".into(), value: 1024 }]) })(input)
            .map(|(remaining, res)| (remaining, Self(res)))
    }
}


/* *
 * This DE indicates the role played by a vehicle at a point in time.
 *
 * The value shall be set to:
 * - 0 `default`          - to indicate the default vehicle role as indicated by the vehicle type,
 * - 1 `publicTransport`  - to indicate that the vehicle is used to operate public transport service,
 * - 2 `specialTransport` - to indicate that the vehicle is used for special transport purpose, e.g. oversized trucks,
 * - 3 `dangerousGoods`   - to indicate that the vehicle is used for dangerous goods transportation,
 * - 4 `roadWork`         - to indicate that the vehicle is used to realize roadwork or road maintenance mission,
 * - 5 `rescue`           - to indicate that the vehicle is used for rescue purpose in case of an accident, e.g. as a towing service,
 * - 6 `emergency`        - to indicate that the vehicle is used for emergency mission, e.g. ambulance, fire brigade,
 * - 7 `safetyCar`        - to indicate that the vehicle is used for public safety, e.g. patrol,
 * - 8 `agriculture`      - to indicate that the vehicle is used for agriculture, e.g. farm tractor, 
 * - 9 `commercial`       - to indicate that the vehicle is used for transportation of commercial goods,
 * - 10 `military`        - to indicate that the vehicle is used for military purpose, 
 * - 11 `roadOperator`    - to indicate that the vehicle is used in road operator missions,
 * - 12 `taxi`            - to indicate that the vehicle is used to provide an authorized taxi service.
 * - 13 `reserved`        - is reserved for future usage.
 * - 14 `reserved`        - is reserved for future usage.
 * - 15 `reserved`        - is reserved for future usage.
 * 
 * @category: Vehicle Information
 * @revision: Description updated in V2.1.1 (removed reference to CEN/TS 16157-3)
 */
#[derive(Debug, Clone, PartialEq, Default)]
pub enum VehicleRole {
  #[default]
  default = 0,
	publicTransport = 1,
	specialTransport = 2,
	dangerousGoods = 3,
	roadWork = 4,
	rescue = 5,
	emergency = 6,
	safetyCar = 7,
	agriculture = 8,
	commercial = 9,
	military = 10,
	roadOperator = 11,
	taxi = 12,
	reserved1 = 13,
	reserved2 = 14,
	reserved3 = 15,
}

impl TryFrom<i128> for VehicleRole {
    type Error = DecodingError;

    fn try_from(v: i128) -> Result<Self, Self::Error> {
        match v {
            x if x == Self::default as i128 => Ok(Self::default),
		  x if x == Self::publicTransport as i128 => Ok(Self::publicTransport),
		  x if x == Self::specialTransport as i128 => Ok(Self::specialTransport),
		  x if x == Self::dangerousGoods as i128 => Ok(Self::dangerousGoods),
		  x if x == Self::roadWork as i128 => Ok(Self::roadWork),
		  x if x == Self::rescue as i128 => Ok(Self::rescue),
		  x if x == Self::emergency as i128 => Ok(Self::emergency),
		  x if x == Self::safetyCar as i128 => Ok(Self::safetyCar),
		  x if x == Self::agriculture as i128 => Ok(Self::agriculture),
		  x if x == Self::commercial as i128 => Ok(Self::commercial),
		  x if x == Self::military as i128 => Ok(Self::military),
		  x if x == Self::roadOperator as i128 => Ok(Self::roadOperator),
		  x if x == Self::taxi as i128 => Ok(Self::taxi),
		  x if x == Self::reserved1 as i128 => Ok(Self::reserved1),
		  x if x == Self::reserved2 as i128 => Ok(Self::reserved2),
		  x if x == Self::reserved3 as i128 => Ok(Self::reserved3),
            _ => Err(
              DecodingError::new(
                &format!("Invalid enumerated index decoding VehicleRole. Received index {}",v), DecodingErrorType::InvalidEnumeratedIndex
              )
            ),
        }
    }
}

impl Decode for VehicleRole {
    fn decode<'a, D>(decoder: &D, input: &'a [u8]) -> IResult<&'a [u8], Self>
    where
        D: Decoder,
        Self: Sized,
    {
        decoder.decode_enumerated(AsnEnumerated { members: vec![Enumeral { name: "default".into(), description: None, index: 0 },Enumeral { name: "publicTransport".into(), description: None, index: 1 },Enumeral { name: "specialTransport".into(), description: None, index: 2 },Enumeral { name: "dangerousGoods".into(), description: None, index: 3 },Enumeral { name: "roadWork".into(), description: None, index: 4 },Enumeral { name: "rescue".into(), description: None, index: 5 },Enumeral { name: "emergency".into(), description: None, index: 6 },Enumeral { name: "safetyCar".into(), description: None, index: 7 },Enumeral { name: "agriculture".into(), description: None, index: 8 },Enumeral { name: "commercial".into(), description: None, index: 9 },Enumeral { name: "military".into(), description: None, index: 10 },Enumeral { name: "roadOperator".into(), description: None, index: 11 },Enumeral { name: "taxi".into(), description: None, index: 12 },Enumeral { name: "reserved1".into(), description: None, index: 13 },Enumeral { name: "reserved2".into(), description: None, index: 14 },Enumeral { name: "reserved3".into(), description: None, index: 15 }], extensible: None })( 
          input
        )
    }
}


/* *
 * This DE represents the width of a vehicle, excluding side mirrors and possible similar extensions.

 * The value shall be set to:
 * - `n` (`n > 0` and `n < 61`) indicates the applicable value is equal to or less than n x 0,1 metre, and greater than (n-1) x 0,1 metre,
 * - `61` indicates that the vehicle width is greater than 6,0 metres,
 * - `62` indicates that the information in unavailable.
 * 
 * @unit: 0,1 metre
 * @category: Vehicle information 
 * @revision: Description updated in V2.1.1 (the meaning of 61 has changed slightly).
 */
#[derive(Debug, Clone, PartialEq, Default)]
pub struct VehicleWidth(pub u8);

impl VehicleWidth {
  pub fn is_outOfRange(&self) -> bool { self.0 as i128 == 61 }
  pub fn is_unavailable(&self) -> bool { self.0 as i128 == 62 }
}

impl Decode for VehicleWidth {
    fn decode<'a, D>(decoder: &D, input: &'a [u8]) -> IResult<&'a [u8], Self>
    where
        D: Decoder,
        Self: Sized,
    {
        decoder
            .decode_integer(AsnInteger { constraint: Some(Constraint { min_value: Some(1), max_value: Some(62), extensible: false }), distinguished_values: Some(vec![DistinguishedValue { name: "outOfRange".into(), value: 61 },DistinguishedValue { name: "unavailable".into(), value: 62 }]) })(input)
            .map(|(remaining, res)| (remaining, Self(res)))
    }
}


/* *
 * This DE represents the vehicle acceleration at vertical direction in the centre of the mass of the empty vehicle.
 * The value shall be provided in the vehicle coordinate system as defined in ISO 8855 [21], clause 2.11.
 *
 * The value shall be set to:
 * - `-160` for acceleration values equal to or less than -16 m/s^2,
 * - `n` (`n > -160` and `n <= 0`) to indicate downwards acceleration equal to or less than n x 0,1 m/s^2, and greater than (n-1) x 0,1 m/s^2,
 * - `n` (`n > 0` and `n < 160`) to indicate upwards acceleration equal to or less than n x 0,1 m/s^2, and greater than (n-1) x 0,1 m/s^2,
 * - `160` for acceleration values greater than 15,9 m/s^2,
 * - `161` when the data is unavailable.
 * 
 * @note: The empty load vehicle is defined in ISO 1176 [8], clause 4.6.
 *
 * @category: Vehicle information
 * @unit: 0,1 m/s^2
 * @revision: Desciption updated in V2.1.1 (the meaning of 160 has changed slightly).
 *  
*/
#[derive(Debug, Clone, PartialEq, Default)]
pub struct VerticalAccelerationValue(pub i16);

impl VerticalAccelerationValue {
  pub fn is_negativeOutOfRange(&self) -> bool { self.0 as i128 == -160 }
  pub fn is_positiveOutOfRange(&self) -> bool { self.0 as i128 == 160 }
  pub fn is_unavailable(&self) -> bool { self.0 as i128 == 161 }
}

impl Decode for VerticalAccelerationValue {
    fn decode<'a, D>(decoder: &D, input: &'a [u8]) -> IResult<&'a [u8], Self>
    where
        D: Decoder,
        Self: Sized,
    {
        decoder
            .decode_integer(AsnInteger { constraint: Some(Constraint { min_value: Some(-160), max_value: Some(161), extensible: false }), distinguished_values: Some(vec![DistinguishedValue { name: "negativeOutOfRange".into(), value: -160 },DistinguishedValue { name: "positiveOutOfRange".into(), value: 160 },DistinguishedValue { name: "unavailable".into(), value: 161 }]) })(input)
            .map(|(remaining, res)| (remaining, Self(res)))
    }
}


/* * 
 * This DE Identifies all the VRU profile types within a cluster.
 * It consist of a Bitmap encoding VRU profiles, to allow multiple profiles to be indicated in a single cluster (heterogeneous cluster if more than one profile).
 * 
 * The corresponding bit shall be set to 1 under the following conditions:
 * - 0 `pedestrian`  - indicates that the VRU cluster contains at least one pedestrian VRU,
 * - 1 `bicycle`     - indicates that the VRU cluster contains at least one bicycle VRU member,
 * - 2 `motorcyclist`- indicates that the VRU cluster contains at least one motorcycle VRU member,
 * - 3 `animal`      - indicates that the VRU cluster contains at least one animal VRU member.
 * 
 * Otherwise, the corresponding bit shall be set to 0.
 *
 * @category: VRU information
 * @revision: Created in V2.1.1
*/
#[derive(Debug, Clone, PartialEq, Default)]
pub struct VruClusterProfiles(pub Vec<bool>);

impl VruClusterProfiles {
  pub fn is_pedestrian(&self) -> bool { *self.0.get(0).unwrap_or(&false) }
  pub fn is_bicyclist(&self) -> bool { *self.0.get(1).unwrap_or(&false) }
  pub fn is_motorcyclist(&self) -> bool { *self.0.get(2).unwrap_or(&false) }
  pub fn is_animal(&self) -> bool { *self.0.get(3).unwrap_or(&false) }
}

impl Decode for VruClusterProfiles {
  fn decode<'a, D>(decoder: &D, input: &'a [u8]) -> IResult<&'a [u8], Self>
  where
      D: Decoder,
      Self: Sized,
  {
      decoder
          .decode_bit_string(AsnBitString { constraint: Some(Constraint { min_value: Some(4), max_value: Some(4), extensible: false }), distinguished_values: Some(vec![DistinguishedValue { name: "pedestrian".into(), value: 0 },DistinguishedValue { name: "bicyclist".into(), value: 1 },DistinguishedValue { name: "motorcyclist".into(), value: 2 },DistinguishedValue { name: "animal".into(), value: 3 }]) })(input)
          .map(|(remaining, res)| (remaining, Self(res)))
  }
}


/* *
 * This DE represents the possible usage conditions of the VRU device.

 * - The value shall be set to:
 * - 0 `unavailable`      - to indicate that the usage conditions are unavailable,
 * - 1 `other`            - to indicate that the VRU device is in a state not defined below,
 * - 2 `idle`             - to indicate that the human is currently not interacting with the device,
 * - 3 `listeningToAudio` - to indicate that any audio source other than calling is in use,
 * - 4 `typing`           - to indicate that the human is texting or performaing any other manual input activity,
 * - 5 `calling`          - to indicate that the VRU device is currently receiving a call,
 * - 6 `playingGames`     - to indicate that the human is playing games,
 * - 7 `reading`          - to indicate that the human is reading on the VRU device,
 * - 8 `viewing`          - to indicate that the human is watching dynamic content, including following navigation prompts, viewing videos or other visual contents that are not static.
 * - value 9 to 255       - are reserved for future usage. Value 255 set to "max" in order to bound the size of the encoded field.
 *
 * @category: VRU information
 * @revision: Created in V2.1.1
 */
#[derive(Debug, Clone, PartialEq, Default)]
pub enum VruDeviceUsage {
  #[default]
  unavailable = 0,
	other = 1,
	idle = 2,
	listeningToAudio = 3,
	typing = 4,
	calling = 5,
	playingGames = 6,
	reading = 7,
	viewing = 8,
	max = 255,
}

impl TryFrom<i128> for VruDeviceUsage {
    type Error = DecodingError;

    fn try_from(v: i128) -> Result<Self, Self::Error> {
        match v {
            x if x == Self::unavailable as i128 => Ok(Self::unavailable),
		  x if x == Self::other as i128 => Ok(Self::other),
		  x if x == Self::idle as i128 => Ok(Self::idle),
		  x if x == Self::listeningToAudio as i128 => Ok(Self::listeningToAudio),
		  x if x == Self::typing as i128 => Ok(Self::typing),
		  x if x == Self::calling as i128 => Ok(Self::calling),
		  x if x == Self::playingGames as i128 => Ok(Self::playingGames),
		  x if x == Self::reading as i128 => Ok(Self::reading),
		  x if x == Self::viewing as i128 => Ok(Self::viewing),
		  x if x == Self::max as i128 => Ok(Self::max),
            _ => Err(
              DecodingError::new(
                &format!("Invalid enumerated index decoding VruDeviceUsage. Received index {}",v), DecodingErrorType::InvalidEnumeratedIndex
              )
            ),
        }
    }
}

impl Decode for VruDeviceUsage {
    fn decode<'a, D>(decoder: &D, input: &'a [u8]) -> IResult<&'a [u8], Self>
    where
        D: Decoder,
        Self: Sized,
    {
        decoder.decode_enumerated(AsnEnumerated { members: vec![Enumeral { name: "unavailable".into(), description: None, index: 0 },Enumeral { name: "other".into(), description: None, index: 1 },Enumeral { name: "idle".into(), description: None, index: 2 },Enumeral { name: "listeningToAudio".into(), description: None, index: 3 },Enumeral { name: "typing".into(), description: None, index: 4 },Enumeral { name: "calling".into(), description: None, index: 5 },Enumeral { name: "playingGames".into(), description: None, index: 6 },Enumeral { name: "reading".into(), description: None, index: 7 },Enumeral { name: "viewing".into(), description: None, index: 8 },Enumeral { name: "max".into(), description: None, index: 255 }], extensible: None })( 
          input
        )
    }
}


/* *
 * This DE represents the possible VRU environment conditions.
 *
 * - The value shall be set to:
 * - 0 `unavailable`            - to indicate that the information on the type of environment is unavailable,
 * - 1 `intersectionCrossing`   - to indicate that the VRU is on an intersection or crossing,
 * - 2 `zebraCrossing`          - to indicate that the VRU is on a  zebra crossing (crosswalk),
 * - 3 `sidewalk`               - to indicate that the VRU is on a sidewalk,
 * - 4 `onVehicleRoad`          - to indicate that the VRU is on a traffic lane,
 * - 5 `protectedGeographicArea`- to indicate that the VRU is in a protected area.
 * - value 5 to 255             - are reserved for future usage. Value 255 is set to "max" in order to bound the size of the encoded field.
 *
 * @category: VRU information
 * @revision: Created in V2.1.1
 */
#[derive(Debug, Clone, PartialEq, Default)]
pub enum VruEnvironment {
  #[default]
  unavailable = 0,
	intersectionCrossing = 1,
	zebraCrossing = 2,
	sidewalk = 3,
	onVehicleRoad = 4,
	protectedGeographicArea = 5,
	max = 255,
}

impl TryFrom<i128> for VruEnvironment {
    type Error = DecodingError;

    fn try_from(v: i128) -> Result<Self, Self::Error> {
        match v {
            x if x == Self::unavailable as i128 => Ok(Self::unavailable),
		  x if x == Self::intersectionCrossing as i128 => Ok(Self::intersectionCrossing),
		  x if x == Self::zebraCrossing as i128 => Ok(Self::zebraCrossing),
		  x if x == Self::sidewalk as i128 => Ok(Self::sidewalk),
		  x if x == Self::onVehicleRoad as i128 => Ok(Self::onVehicleRoad),
		  x if x == Self::protectedGeographicArea as i128 => Ok(Self::protectedGeographicArea),
		  x if x == Self::max as i128 => Ok(Self::max),
            _ => Err(
              DecodingError::new(
                &format!("Invalid enumerated index decoding VruEnvironment. Received index {}",v), DecodingErrorType::InvalidEnumeratedIndex
              )
            ),
        }
    }
}

impl Decode for VruEnvironment {
    fn decode<'a, D>(decoder: &D, input: &'a [u8]) -> IResult<&'a [u8], Self>
    where
        D: Decoder,
        Self: Sized,
    {
        decoder.decode_enumerated(AsnEnumerated { members: vec![Enumeral { name: "unavailable".into(), description: None, index: 0 },Enumeral { name: "intersectionCrossing".into(), description: None, index: 1 },Enumeral { name: "zebraCrossing".into(), description: None, index: 2 },Enumeral { name: "sidewalk".into(), description: None, index: 3 },Enumeral { name: "onVehicleRoad".into(), description: None, index: 4 },Enumeral { name: "protectedGeographicArea".into(), description: None, index: 5 },Enumeral { name: "max".into(), description: None, index: 255 }], extensible: None })( 
          input
        )
    }
}


/* *
 *  This DE indicates the status of the possible human control over a VRU vehicle.
 *
 * The value shall be set to:
 * - 0 `unavailable`                 - to indicate that the information is unavailable,
 * - 1 `braking`                     - to indicate that the VRU is braking,
 * - 2 `hardBraking`                 - to indicate that the VRU is braking hard,
 * - 3 `stopPedaling`                - to indicate that the VRU stopped pedaling,
 * - 4 `brakingAndStopPedaling`      - to indicate that the VRU stopped pedaling an is braking,
 * - 5 `hardBrakingAndStopPedaling`  - to indicate that the VRU stopped pedaling an is braking hard,
 * - 6 `noReaction`                  - to indicate that the VRU is not changing its behavior.
 * - 7 to 255                        - are reserved for future usage. Value 255 is set to "max" in order to bound the size of the encoded field.
 *
 * @category: VRU information
 * @revision: Created in V2.1.1
 */
#[derive(Debug, Clone, PartialEq, Default)]
pub enum VruMovementControl {
  #[default]
  unavailable = 0,
	braking = 1,
	hardBraking = 2,
	stopPedaling = 3,
	brakingAndStopPedaling = 4,
	hardBrakingAndStopPedaling = 5,
	noReaction = 6,
	max = 255,
}

impl TryFrom<i128> for VruMovementControl {
    type Error = DecodingError;

    fn try_from(v: i128) -> Result<Self, Self::Error> {
        match v {
            x if x == Self::unavailable as i128 => Ok(Self::unavailable),
		  x if x == Self::braking as i128 => Ok(Self::braking),
		  x if x == Self::hardBraking as i128 => Ok(Self::hardBraking),
		  x if x == Self::stopPedaling as i128 => Ok(Self::stopPedaling),
		  x if x == Self::brakingAndStopPedaling as i128 => Ok(Self::brakingAndStopPedaling),
		  x if x == Self::hardBrakingAndStopPedaling as i128 => Ok(Self::hardBrakingAndStopPedaling),
		  x if x == Self::noReaction as i128 => Ok(Self::noReaction),
		  x if x == Self::max as i128 => Ok(Self::max),
            _ => Err(
              DecodingError::new(
                &format!("Invalid enumerated index decoding VruMovementControl. Received index {}",v), DecodingErrorType::InvalidEnumeratedIndex
              )
            ),
        }
    }
}

impl Decode for VruMovementControl {
    fn decode<'a, D>(decoder: &D, input: &'a [u8]) -> IResult<&'a [u8], Self>
    where
        D: Decoder,
        Self: Sized,
    {
        decoder.decode_enumerated(AsnEnumerated { members: vec![Enumeral { name: "unavailable".into(), description: None, index: 0 },Enumeral { name: "braking".into(), description: None, index: 1 },Enumeral { name: "hardBraking".into(), description: None, index: 2 },Enumeral { name: "stopPedaling".into(), description: None, index: 3 },Enumeral { name: "brakingAndStopPedaling".into(), description: None, index: 4 },Enumeral { name: "hardBrakingAndStopPedaling".into(), description: None, index: 5 },Enumeral { name: "noReaction".into(), description: None, index: 6 },Enumeral { name: "max".into(), description: None, index: 255 }], extensible: None })( 
          input
        )
    }
}


/* *
 * This DE indicates the profile of a pedestrian.
 * 
 * The value shall be set to:
 * - 0 `unavailable`             - to indicate that the information on is unavailable,
 * - 1 `ordinary-pedestrian`     - to indicate a pedestrian to which no more-specific profile applies,
 * - 2 `road-worker`             - to indicate a pedestrian with the role of a road worker,
 * - 3 `first-responder`         - to indicate a pedestrian with the role of a first responder.
 * - value 4 to 15               - are reserved for future usage. Value 15 is set to "max" in order to bound the size of the encoded field.
 *
 * @category: VRU information
 * @revision: Created in V2.1.1
 */
#[derive(Debug, Clone, PartialEq, Default)]
pub enum VruSubProfilePedestrian {
  #[default]
  unavailable = 0,
	ordinary_pedestrian = 1,
	road_worker = 2,
	first_responder = 3,
	max = 15,
}

impl TryFrom<i128> for VruSubProfilePedestrian {
    type Error = DecodingError;

    fn try_from(v: i128) -> Result<Self, Self::Error> {
        match v {
            x if x == Self::unavailable as i128 => Ok(Self::unavailable),
		  x if x == Self::ordinary_pedestrian as i128 => Ok(Self::ordinary_pedestrian),
		  x if x == Self::road_worker as i128 => Ok(Self::road_worker),
		  x if x == Self::first_responder as i128 => Ok(Self::first_responder),
		  x if x == Self::max as i128 => Ok(Self::max),
            _ => Err(
              DecodingError::new(
                &format!("Invalid enumerated index decoding VruSubProfilePedestrian. Received index {}",v), DecodingErrorType::InvalidEnumeratedIndex
              )
            ),
        }
    }
}

impl Decode for VruSubProfilePedestrian {
    fn decode<'a, D>(decoder: &D, input: &'a [u8]) -> IResult<&'a [u8], Self>
    where
        D: Decoder,
        Self: Sized,
    {
        decoder.decode_enumerated(AsnEnumerated { members: vec![Enumeral { name: "unavailable".into(), description: None, index: 0 },Enumeral { name: "ordinary-pedestrian".into(), description: None, index: 1 },Enumeral { name: "road-worker".into(), description: None, index: 2 },Enumeral { name: "first-responder".into(), description: None, index: 3 },Enumeral { name: "max".into(), description: None, index: 15 }], extensible: None })( 
          input
        )
    }
}


/* *
 * This DE indicates the profile of a VRU and its light VRU vehicle / mounted animal. 
 *
 * The value shall be set to:
 * - 0 `unavailable`           - to indicate that the information  is unavailable,
 * - 1 `bicyclist `            - to indicate a cycle and bicyclist,
 * - 2 `wheelchair-user`       - to indicate a wheelchair and its user,
 * - 3 `horse-and-rider`       - to indicate a horse and rider,
 * - 4 `rollerskater`          - to indicate a rolleskater and skater,
 * - 5 `e-scooter`             - to indicate an e-scooter and rider,
 * - 6 `personal-transporter`  - to indicate a personal-transporter and rider,
 * - 7 `pedelec`               - to indicate a pedelec and rider,
 * - 8 `speed-pedelec`         - to indicate a speed-pedelec and rider.
 * - 9 to 15                   - are reserved for future usage. Value 15 is set to "max" in order to bound the size of the encoded field.
 *
 * @category: VRU information
 * @revision: Created in V2.1.1
 */
#[derive(Debug, Clone, PartialEq, Default)]
pub enum VruSubProfileBicyclist {
  #[default]
  unavailable = 0,
	bicyclist = 1,
	wheelchair_user = 2,
	horse_and_rider = 3,
	rollerskater = 4,
	e_scooter = 5,
	personal_transporter = 6,
	pedelec = 7,
	speed_pedelec = 8,
	max = 15,
}

impl TryFrom<i128> for VruSubProfileBicyclist {
    type Error = DecodingError;

    fn try_from(v: i128) -> Result<Self, Self::Error> {
        match v {
            x if x == Self::unavailable as i128 => Ok(Self::unavailable),
		  x if x == Self::bicyclist as i128 => Ok(Self::bicyclist),
		  x if x == Self::wheelchair_user as i128 => Ok(Self::wheelchair_user),
		  x if x == Self::horse_and_rider as i128 => Ok(Self::horse_and_rider),
		  x if x == Self::rollerskater as i128 => Ok(Self::rollerskater),
		  x if x == Self::e_scooter as i128 => Ok(Self::e_scooter),
		  x if x == Self::personal_transporter as i128 => Ok(Self::personal_transporter),
		  x if x == Self::pedelec as i128 => Ok(Self::pedelec),
		  x if x == Self::speed_pedelec as i128 => Ok(Self::speed_pedelec),
		  x if x == Self::max as i128 => Ok(Self::max),
            _ => Err(
              DecodingError::new(
                &format!("Invalid enumerated index decoding VruSubProfileBicyclist. Received index {}",v), DecodingErrorType::InvalidEnumeratedIndex
              )
            ),
        }
    }
}

impl Decode for VruSubProfileBicyclist {
    fn decode<'a, D>(decoder: &D, input: &'a [u8]) -> IResult<&'a [u8], Self>
    where
        D: Decoder,
        Self: Sized,
    {
        decoder.decode_enumerated(AsnEnumerated { members: vec![Enumeral { name: "unavailable".into(), description: None, index: 0 },Enumeral { name: "bicyclist".into(), description: None, index: 1 },Enumeral { name: "wheelchair-user".into(), description: None, index: 2 },Enumeral { name: "horse-and-rider".into(), description: None, index: 3 },Enumeral { name: "rollerskater".into(), description: None, index: 4 },Enumeral { name: "e-scooter".into(), description: None, index: 5 },Enumeral { name: "personal-transporter".into(), description: None, index: 6 },Enumeral { name: "pedelec".into(), description: None, index: 7 },Enumeral { name: "speed-pedelec".into(), description: None, index: 8 },Enumeral { name: "max".into(), description: None, index: 15 }], extensible: None })( 
          input
        )
    }
}


/* *
 * This DE indicates the profile of a motorcyclist and corresponding vehicle.
 * 
 * The value shall be set to:
 * - 0 `unavailable `                  - to indicate that the information  is unavailable,
 * - 1 `moped`                         - to indicate a moped and rider,
 * - 2 `motorcycle`                    - to indicate a motorcycle and rider,
 * - 3 `motorcycle-and-sidecar-right`  - to indicate a motorcycle with sidecar on the right and rider,
 * - 4 `motorcycle-and-sidecar-left`   - to indicate  a motorcycle with sidecar on the left and rider.
 * - 5 to 15                           - are reserved for future usage. Value 15 is set to "max" in order to bound the size of the encoded field.
 *
 * @category: VRU information
 * @revision: Created in V2.1.1
 */
#[derive(Debug, Clone, PartialEq, Default)]
pub enum VruSubProfileMotorcyclist {
  #[default]
  unavailable = 0,
	moped = 1,
	motorcycle = 2,
	motorcycle_and_sidecar_right = 3,
	motorcycle_and_sidecar_left = 4,
	max = 15,
}

impl TryFrom<i128> for VruSubProfileMotorcyclist {
    type Error = DecodingError;

    fn try_from(v: i128) -> Result<Self, Self::Error> {
        match v {
            x if x == Self::unavailable as i128 => Ok(Self::unavailable),
		  x if x == Self::moped as i128 => Ok(Self::moped),
		  x if x == Self::motorcycle as i128 => Ok(Self::motorcycle),
		  x if x == Self::motorcycle_and_sidecar_right as i128 => Ok(Self::motorcycle_and_sidecar_right),
		  x if x == Self::motorcycle_and_sidecar_left as i128 => Ok(Self::motorcycle_and_sidecar_left),
		  x if x == Self::max as i128 => Ok(Self::max),
            _ => Err(
              DecodingError::new(
                &format!("Invalid enumerated index decoding VruSubProfileMotorcyclist. Received index {}",v), DecodingErrorType::InvalidEnumeratedIndex
              )
            ),
        }
    }
}

impl Decode for VruSubProfileMotorcyclist {
    fn decode<'a, D>(decoder: &D, input: &'a [u8]) -> IResult<&'a [u8], Self>
    where
        D: Decoder,
        Self: Sized,
    {
        decoder.decode_enumerated(AsnEnumerated { members: vec![Enumeral { name: "unavailable".into(), description: None, index: 0 },Enumeral { name: "moped".into(), description: None, index: 1 },Enumeral { name: "motorcycle".into(), description: None, index: 2 },Enumeral { name: "motorcycle-and-sidecar-right".into(), description: None, index: 3 },Enumeral { name: "motorcycle-and-sidecar-left".into(), description: None, index: 4 },Enumeral { name: "max".into(), description: None, index: 15 }], extensible: None })( 
          input
        )
    }
}


/* *
 * This DE indicates the profile of an animal
 * 
 * The value shall be set to:
 * - 0 `unavailable`     - to indicate that the information  is unavailable,
 * - 1 `wild-animal`     - to indicate a animal living in the wildness, 
 * - 2 `farm-animal`     - to indicate an animal beloning to a farm,
 * - 3 `service-animal`  - to indicate an animal that supports a human being.
 * - 4 to 15             - are reserved for future usage. Value 15 is set to "max" in order to bound the size of the encoded field.
 *
 * @category: VRU information
 * @revision: Created in V2.1.1
 */
#[derive(Debug, Clone, PartialEq, Default)]
pub enum VruSubProfileAnimal {
  #[default]
  unavailable = 0,
	wild_animal = 1,
	farm_animal = 2,
	service_animal = 3,
	max = 15,
}

impl TryFrom<i128> for VruSubProfileAnimal {
    type Error = DecodingError;

    fn try_from(v: i128) -> Result<Self, Self::Error> {
        match v {
            x if x == Self::unavailable as i128 => Ok(Self::unavailable),
		  x if x == Self::wild_animal as i128 => Ok(Self::wild_animal),
		  x if x == Self::farm_animal as i128 => Ok(Self::farm_animal),
		  x if x == Self::service_animal as i128 => Ok(Self::service_animal),
		  x if x == Self::max as i128 => Ok(Self::max),
            _ => Err(
              DecodingError::new(
                &format!("Invalid enumerated index decoding VruSubProfileAnimal. Received index {}",v), DecodingErrorType::InvalidEnumeratedIndex
              )
            ),
        }
    }
}

impl Decode for VruSubProfileAnimal {
    fn decode<'a, D>(decoder: &D, input: &'a [u8]) -> IResult<&'a [u8], Self>
    where
        D: Decoder,
        Self: Sized,
    {
        decoder.decode_enumerated(AsnEnumerated { members: vec![Enumeral { name: "unavailable".into(), description: None, index: 0 },Enumeral { name: "wild-animal".into(), description: None, index: 1 },Enumeral { name: "farm-animal".into(), description: None, index: 2 },Enumeral { name: "service-animal".into(), description: None, index: 3 },Enumeral { name: "max".into(), description: None, index: 15 }], extensible: None })( 
          input
        )
    }
}


/* *
 * This DE indicates the approximate size of a VRU including the VRU vehicle used.
 * 
 * The value shall be set to:
 * - 0 `unavailable`    - to indicate that there is no matched size class or due to privacy reasons in profile 1, 
 * - 1 `low`            - to indicate that the VRU size class is low depending on the VRU profile,
 * - 2 `medium`         - to indicate that the VRU size class is medium depending on the VRU profile,
 * - 3 `high`           - to indicate that the VRU size class is high depending on the VRU profile.
 * - 4 to 15            - are reserved for future usage. Value 15 is set to "max" in order to bound the size of the encoded field.
 *
 * @category: VRU information
 * @revision: Created in V2.1.1
 */
#[derive(Debug, Clone, PartialEq, Default)]
pub enum VruSizeClass {
  #[default]
  unavailable = 0,
	low = 1,
	medium = 2,
	high = 3,
	max = 15,
}

impl TryFrom<i128> for VruSizeClass {
    type Error = DecodingError;

    fn try_from(v: i128) -> Result<Self, Self::Error> {
        match v {
            x if x == Self::unavailable as i128 => Ok(Self::unavailable),
		  x if x == Self::low as i128 => Ok(Self::low),
		  x if x == Self::medium as i128 => Ok(Self::medium),
		  x if x == Self::high as i128 => Ok(Self::high),
		  x if x == Self::max as i128 => Ok(Self::max),
            _ => Err(
              DecodingError::new(
                &format!("Invalid enumerated index decoding VruSizeClass. Received index {}",v), DecodingErrorType::InvalidEnumeratedIndex
              )
            ),
        }
    }
}

impl Decode for VruSizeClass {
    fn decode<'a, D>(decoder: &D, input: &'a [u8]) -> IResult<&'a [u8], Self>
    where
        D: Decoder,
        Self: Sized,
    {
        decoder.decode_enumerated(AsnEnumerated { members: vec![Enumeral { name: "unavailable".into(), description: None, index: 0 },Enumeral { name: "low".into(), description: None, index: 1 },Enumeral { name: "medium".into(), description: None, index: 2 },Enumeral { name: "high".into(), description: None, index: 3 },Enumeral { name: "max".into(), description: None, index: 15 }], extensible: None })( 
          input
        )
    }
}


/* *
 * This DE describes the status of the exterior light switches of a VRU.
 *
 * The value of each bit indicates the state of the switch, which commands the corresponding light. 
 * The bit corresponding to a specific light shall be set to 1, when the corresponding switch is turned on, either manually by the driver or VRU 
 * or automatically by a vehicle or VRU system: 
 * - 0 `unavailable`     - indicates no information available, 
 * - 1 `backFlashLight ` - indicates the status of the back flash light,
 * - 2 `helmetLight`     - indicates the status of the helmet light,
 * - 3 `armLight`        - indicates the status of the arm light,
 * - 4 `legLight`        - indicates the status of the leg light,
 * - 5 `wheelLight`      - indicates the status of the wheel light. 
 * - Bits 6 to 8         - are reserved for future use. 
 * The bit values do not indicate if the corresponding lamps are alight or not.
 * If  VRU is not equipped with a certain light or if the light switch status information is not available, the corresponding bit shall be set to 0.
 *
 * @category: VRU information
 * @revision: Created in V2.1.1
 */
#[derive(Debug, Clone, PartialEq, Default)]
pub struct VruSpecificExteriorLights(pub Vec<bool>);

impl VruSpecificExteriorLights {
  pub fn is_unavailable(&self) -> bool { *self.0.get(0).unwrap_or(&false) }
  pub fn is_backFlashLight(&self) -> bool { *self.0.get(1).unwrap_or(&false) }
  pub fn is_helmetLight(&self) -> bool { *self.0.get(2).unwrap_or(&false) }
  pub fn is_armLight(&self) -> bool { *self.0.get(3).unwrap_or(&false) }
  pub fn is_legLight(&self) -> bool { *self.0.get(4).unwrap_or(&false) }
  pub fn is_wheelLight(&self) -> bool { *self.0.get(5).unwrap_or(&false) }
}

impl Decode for VruSpecificExteriorLights {
  fn decode<'a, D>(decoder: &D, input: &'a [u8]) -> IResult<&'a [u8], Self>
  where
      D: Decoder,
      Self: Sized,
  {
      decoder
          .decode_bit_string(AsnBitString { constraint: Some(Constraint { min_value: Some(8), max_value: Some(8), extensible: false }), distinguished_values: Some(vec![DistinguishedValue { name: "unavailable".into(), value: 0 },DistinguishedValue { name: "backFlashLight".into(), value: 1 },DistinguishedValue { name: "helmetLight".into(), value: 2 },DistinguishedValue { name: "armLight".into(), value: 3 },DistinguishedValue { name: "legLight".into(), value: 4 },DistinguishedValue { name: "wheelLight".into(), value: 5 }]) })(input)
          .map(|(remaining, res)| (remaining, Self(res)))
  }
}


/* *
 * This DE indicates the perpendicular distance between front and rear axle of the wheel base of vehicle.
 *
 * The value shall be set to:
 * - `n` (`n >= 1` and `n < 126`) if the value is equal to or less than n x 0,1 metre  and more than (n-1) x 0,1 metre,
 * - `126` indicates that the wheel base distance is equal to or greater than 12,5 metres,
 * - `127` indicates that the information is unavailable.
 *
 * @unit 0,1 metre
 * @category: Vehicle information
 * @revision: Created in V2.1.1
 */
#[derive(Debug, Clone, PartialEq, Default)]
pub struct WheelBaseVehicle(pub u8);

impl WheelBaseVehicle {
  pub fn is_outOfRange(&self) -> bool { self.0 as i128 == 126 }
  pub fn is_unavailable(&self) -> bool { self.0 as i128 == 127 }
}

impl Decode for WheelBaseVehicle {
    fn decode<'a, D>(decoder: &D, input: &'a [u8]) -> IResult<&'a [u8], Self>
    where
        D: Decoder,
        Self: Sized,
    {
        decoder
            .decode_integer(AsnInteger { constraint: Some(Constraint { min_value: Some(1), max_value: Some(127), extensible: false }), distinguished_values: Some(vec![DistinguishedValue { name: "outOfRange".into(), value: 126 },DistinguishedValue { name: "unavailable".into(), value: 127 }]) })(input)
            .map(|(remaining, res)| (remaining, Self(res)))
    }
}


/* * 
 * This DE indicates the angle confidence value which represents the estimated accuracy of an angle value with a default confidence level of 95 %.
 * If required, the confidence level can be defined by the corresponding standards applying this DE.
 * 
 * The value shall be set to:
 * - `n` (`n >= 1` and `n < 126`) if the confidence value is equal to or less than n x 0,1 degrees and more than (n-1) x 0,1 degrees,
 * - `126` if the confidence value is out of range, i.e. greater than 12,5 degrees,
 * - `127` if the confidence value is not available.
 *
 *
 * @unit 0,1 degrees
 * @category: GeoReference Information
 * @revision: Created in V2.1.1
*/
#[derive(Debug, Clone, PartialEq, Default)]
pub struct Wgs84AngleConfidence(pub u8);

impl Wgs84AngleConfidence {
  pub fn is_outOfRange(&self) -> bool { self.0 as i128 == 126 }
  pub fn is_unavailable(&self) -> bool { self.0 as i128 == 127 }
}

impl Decode for Wgs84AngleConfidence {
    fn decode<'a, D>(decoder: &D, input: &'a [u8]) -> IResult<&'a [u8], Self>
    where
        D: Decoder,
        Self: Sized,
    {
        decoder
            .decode_integer(AsnInteger { constraint: Some(Constraint { min_value: Some(1), max_value: Some(127), extensible: false }), distinguished_values: Some(vec![DistinguishedValue { name: "outOfRange".into(), value: 126 },DistinguishedValue { name: "unavailable".into(), value: 127 }]) })(input)
            .map(|(remaining, res)| (remaining, Self(res)))
    }
}


/* * 
 * This DE represents an angle value in degrees described in the WGS84 reference system with respect to the WGS84 north.
 * The specific WGS84 coordinate system is specified by the corresponding standards applying this DE.
 * When the information is not available, the DE shall be set to 3 601. The value 3600 shall not be used.
 *
 * @unit 0,1 degrees
 * @category: GeoReference Information
 * @revision: Created in V2.1.1
*/
#[derive(Debug, Clone, PartialEq, Default)]
pub struct Wgs84AngleValue(pub u16);

impl Wgs84AngleValue {
  pub fn is_wgs84North(&self) -> bool { self.0 as i128 == 0 }
  pub fn is_wgs84East(&self) -> bool { self.0 as i128 == 900 }
  pub fn is_wgs84South(&self) -> bool { self.0 as i128 == 1800 }
  pub fn is_wgs84West(&self) -> bool { self.0 as i128 == 2700 }
  pub fn is_doNotUse(&self) -> bool { self.0 as i128 == 3600 }
  pub fn is_unavailable(&self) -> bool { self.0 as i128 == 3601 }
}

impl Decode for Wgs84AngleValue {
    fn decode<'a, D>(decoder: &D, input: &'a [u8]) -> IResult<&'a [u8], Self>
    where
        D: Decoder,
        Self: Sized,
    {
        decoder
            .decode_integer(AsnInteger { constraint: Some(Constraint { min_value: Some(0), max_value: Some(3601), extensible: false }), distinguished_values: Some(vec![DistinguishedValue { name: "wgs84North".into(), value: 0 },DistinguishedValue { name: "wgs84East".into(), value: 900 },DistinguishedValue { name: "wgs84South".into(), value: 1800 },DistinguishedValue { name: "wgs84West".into(), value: 2700 },DistinguishedValue { name: "doNotUse".into(), value: 3600 },DistinguishedValue { name: "unavailable".into(), value: 3601 }]) })(input)
            .map(|(remaining, res)| (remaining, Self(res)))
    }
}


/* *
 * This DE represents the sub cause codes of the @ref CauseCode `wrongWayDriving` .
 * 
 * The value shall be set to:
 * - 0 `unavailable`    - in case further detailed information on wrong way driving event is unavailable,
 * - 1 `wrongLane`      - in case vehicle is driving on a lane for which it has no authorization to use,
 * - 2 `wrongDirection` - in case vehicle is driving in a direction that it is not allowed,
 * - 3-255              - reserved for future usage.
 * 
 * @category: Traffic information
 * @revision: V1.3.1
 */
#[derive(Debug, Clone, PartialEq, Default)]
pub struct WrongWayDrivingSubCauseCode(pub u8);

impl WrongWayDrivingSubCauseCode {
  pub fn is_unavailable(&self) -> bool { self.0 as i128 == 0 }
  pub fn is_wrongLane(&self) -> bool { self.0 as i128 == 1 }
  pub fn is_wrongDirection(&self) -> bool { self.0 as i128 == 2 }
}

impl Decode for WrongWayDrivingSubCauseCode {
    fn decode<'a, D>(decoder: &D, input: &'a [u8]) -> IResult<&'a [u8], Self>
    where
        D: Decoder,
        Self: Sized,
    {
        decoder
            .decode_integer(AsnInteger { constraint: Some(Constraint { min_value: Some(0), max_value: Some(255), extensible: false }), distinguished_values: Some(vec![DistinguishedValue { name: "unavailable".into(), value: 0 },DistinguishedValue { name: "wrongLane".into(), value: 1 },DistinguishedValue { name: "wrongDirection".into(), value: 2 }]) })(input)
            .map(|(remaining, res)| (remaining, Self(res)))
    }
}


/* *
 * This DE indicates the yaw rate confidence value which represents the estimated accuracy for a yaw rate value with a default confidence level of 95 %.
 * If required, the confidence level can be defined by the corresponding standards applying this DE.
 * 
 * The value shall be set to:
 * - `0` if the confidence value is equal to or less than 0,01 degree/second,
 * - `1` if the confidence value is equal to or less than 0,05 degrees/second or greater than 0,01 degree/second,
 * - `2` if the confidence value is equal to or less than 0,1 degree/second or greater than 0,05 degree/second,
 * - `3` if the confidence value is equal to or less than 1 degree/second or greater than 0,1 degree/second,
 * - `4` if the confidence value is equal to or less than 5 degrees/second or greater than 1 degrees/second,
 * - `5` if the confidence value is equal to or less than 10 degrees/second or greater than 5 degrees/second,
 * - `6` if the confidence value is equal to or less than 100 degrees/second or greater than 10 degrees/second,
 * - `7` if the confidence value is out of range, i.e. greater than 100 degrees/second,
 * - `8` if the confidence value is unavailable.
 * 
 * NOTE: The fact that a yaw rate value is received with confidence value set to `unavailable(8)` can be caused by
 * several reasons, such as:
 * - the sensor cannot deliver the accuracy at the defined confidence level because it is a low-end sensor,
 * - the sensor cannot calculate the accuracy due to lack of variables, or
 * - there has been a vehicle bus (e.g. CAN bus) error.
 * In all 3 cases above, the yaw rate value may be valid and used by the application.
 * 
 * If a yaw rate value is received and its confidence value is set to `outOfRange(7)`, it means that the 
 * yaw rate value is not valid and therefore cannot be trusted. Such value is not useful the application.
 * 
 * @category: Vehicle information
 * @revision: Description revised in V2.1.1
 */
#[derive(Debug, Clone, PartialEq, Default)]
pub enum YawRateConfidence {
  #[default]
  degSec_000_01 = 0,
	degSec_000_05 = 1,
	degSec_000_10 = 2,
	degSec_001_00 = 3,
	degSec_005_00 = 4,
	degSec_010_00 = 5,
	degSec_100_00 = 6,
	outOfRange = 7,
	unavailable = 8,
}

impl TryFrom<i128> for YawRateConfidence {
    type Error = DecodingError;

    fn try_from(v: i128) -> Result<Self, Self::Error> {
        match v {
            x if x == Self::degSec_000_01 as i128 => Ok(Self::degSec_000_01),
		  x if x == Self::degSec_000_05 as i128 => Ok(Self::degSec_000_05),
		  x if x == Self::degSec_000_10 as i128 => Ok(Self::degSec_000_10),
		  x if x == Self::degSec_001_00 as i128 => Ok(Self::degSec_001_00),
		  x if x == Self::degSec_005_00 as i128 => Ok(Self::degSec_005_00),
		  x if x == Self::degSec_010_00 as i128 => Ok(Self::degSec_010_00),
		  x if x == Self::degSec_100_00 as i128 => Ok(Self::degSec_100_00),
		  x if x == Self::outOfRange as i128 => Ok(Self::outOfRange),
		  x if x == Self::unavailable as i128 => Ok(Self::unavailable),
            _ => Err(
              DecodingError::new(
                &format!("Invalid enumerated index decoding YawRateConfidence. Received index {}",v), DecodingErrorType::InvalidEnumeratedIndex
              )
            ),
        }
    }
}

impl Decode for YawRateConfidence {
    fn decode<'a, D>(decoder: &D, input: &'a [u8]) -> IResult<&'a [u8], Self>
    where
        D: Decoder,
        Self: Sized,
    {
        decoder.decode_enumerated(AsnEnumerated { members: vec![Enumeral { name: "degSec-000-01".into(), description: None, index: 0 },Enumeral { name: "degSec-000-05".into(), description: None, index: 1 },Enumeral { name: "degSec-000-10".into(), description: None, index: 2 },Enumeral { name: "degSec-001-00".into(), description: None, index: 3 },Enumeral { name: "degSec-005-00".into(), description: None, index: 4 },Enumeral { name: "degSec-010-00".into(), description: None, index: 5 },Enumeral { name: "degSec-100-00".into(), description: None, index: 6 },Enumeral { name: "outOfRange".into(), description: None, index: 7 },Enumeral { name: "unavailable".into(), description: None, index: 8 }], extensible: None })( 
          input
        )
    }
}


/* *
 * This DE represents the vehicle rotation around z-axis of the coordinate system centred on the centre of mass of the empty-loaded
 * vehicle. The leading sign denotes the direction of rotation.
 * 
 * The value shall be provided in the vehicle coordinate system as defined in ISO 8855 [21], clause 2.11.
 *
 * The value shall be set to:
 * - `-32 766` to indicate that the yaw rate is equal to or greater than 327,66 degrees/second to the right,
 * - `n` (`n > -32 766` and `n <= 0`) to indicate that the rotation is clockwise (i.e. to the right) and is equal to or less than n x 0,01 degrees/s, 
      and greater than (n-1) x 0,01 degrees/s,
 * - `n` (`n > 0` and `n < 32 766`) to indicate that the rotation is anti-clockwise (i.e. to the left) and is equal to or less than n x 0,01 degrees/s, 
      and greater than (n-1) x 0,01 degrees/s,
 * - `32 766` to indicate that the yaw rate is greater than 327.65 degrees/second to the left,
 * - `32 767` to indicate that the information is not available.
 * 
 * The yaw rate value shall be a raw data value, i.e. not filtered, smoothed or otherwise modified.
 * The reading instant should be the same as for the vehicle acceleration.
 * 
 * @note: The empty load vehicle is defined in ISO 1176 [8], clause 4.6.
 * 
 * @unit: 0,01 degree per second. 
 * @category: Vehicle Information
 * @revision: Desription revised in V2.1.1 (the meaning of 32766 has changed slightly). 
*/
#[derive(Debug, Clone, PartialEq, Default)]
pub struct YawRateValue(pub i16);

impl YawRateValue {
  pub fn is_negativeOutOfRange(&self) -> bool { self.0 as i128 == -32766 }
  pub fn is_positiveOutOfRange(&self) -> bool { self.0 as i128 == 32766 }
  pub fn is_unavailable(&self) -> bool { self.0 as i128 == 32767 }
}

impl Decode for YawRateValue {
    fn decode<'a, D>(decoder: &D, input: &'a [u8]) -> IResult<&'a [u8], Self>
    where
        D: Decoder,
        Self: Sized,
    {
        decoder
            .decode_integer(AsnInteger { constraint: Some(Constraint { min_value: Some(-32766), max_value: Some(32767), extensible: false }), distinguished_values: Some(vec![DistinguishedValue { name: "negativeOutOfRange".into(), value: -32766 },DistinguishedValue { name: "positiveOutOfRange".into(), value: 32766 },DistinguishedValue { name: "unavailable".into(), value: 32767 }]) })(input)
            .map(|(remaining, res)| (remaining, Self(res)))
    }
}




/* 









 Specification of CDD Data Frames:










*
 * This DF represents an acceleration vector in a polar or cylindrical coordinate system.
 
 * It shall include the following components: 
 * 
 * @field accelerationMagnitude: magnitude of the acceleration vector projected onto the reference plane, with the associated confidence value.
 * 
 * @field accelerationDirection: polar angle of the acceleration vector projected onto the reference plane, with the associated confidence value.
 *
 * @field zAcceleration: the optional z component of the acceleration vector along the reference axis of the cylindrical coordinate system, with the associated confidence value.
 * 
 * @category: Kinematic information
 * @revision: Created in V2.1.1
 */
#[derive(Debug, Clone, PartialEq, Default)]
pub struct AccelerationPolarWithZ {
  pub accelerationMagnitude: AccelerationMagnitude,
  pub accelerationDirection: CartesianAngle,
  pub zAcceleration: AccelerationComponent,
}

impl Decode for AccelerationPolarWithZ {
  fn decode<'a, D>(decoder: &D, input: &'a [u8]) -> IResult<&'a [u8], Self>
  where
    D: Decoder,
    Self: Sized,
  {
      let mut remaining = input;
      let mut instance = Self::default();
      AccelerationMagnitude::decode(decoder, remaining).map(|(r, v)| { remaining = r; instance.accelerationMagnitude = v; })?;
      CartesianAngle::decode(decoder, remaining).map(|(r, v)| { remaining = r; instance.accelerationDirection = v; })?;
      AccelerationComponent::decode(decoder, remaining).map(|(r, v)| { remaining = r; instance.zAcceleration = v; })?;
      Ok((remaining, instance))
  }
}




/* *
 * This DF represents a acceleration vector in a cartesian coordinate system.
 
 * It shall include the following components: 
 * 
 * @field xAcceleration: the x component of the acceleration vector with the associated confidence value.
 * 
 * @field yAcceleration: the y component of the acceleration vector with the associated confidence value.
 *
 * @field zAcceleration: the optional z component of the acceleration vector with the associated confidence value.
 * 
 * @category: Kinematic information
 * @revision: Created in V2.1.1
 */
#[derive(Debug, Clone, PartialEq, Default)]
pub struct AccelerationCartesian {
  pub xAcceleration: AccelerationComponent,
  pub yAcceleration: AccelerationComponent,
  pub zAcceleration: AccelerationComponent,
}

impl Decode for AccelerationCartesian {
  fn decode<'a, D>(decoder: &D, input: &'a [u8]) -> IResult<&'a [u8], Self>
  where
    D: Decoder,
    Self: Sized,
  {
      let mut remaining = input;
      let mut instance = Self::default();
      AccelerationComponent::decode(decoder, remaining).map(|(r, v)| { remaining = r; instance.xAcceleration = v; })?;
      AccelerationComponent::decode(decoder, remaining).map(|(r, v)| { remaining = r; instance.yAcceleration = v; })?;
      AccelerationComponent::decode(decoder, remaining).map(|(r, v)| { remaining = r; instance.zAcceleration = v; })?;
      Ok((remaining, instance))
  }
}




/* * 
 * This DF represents an acceleration component along with a confidence value.
 *
 * It shall include the following components: 
 *
 * @field value: the value of the acceleration component which can be estimated as the mean of the current distribution.
 *
 * @field confidence: the confidence value associated to the provided value.
 *
 * @category: Kinematic Information
 * @revision: Created in V2.1.1
 */
#[derive(Debug, Clone, PartialEq, Default)]
pub struct AccelerationComponent {
  pub value: AccelerationValue,
  pub confidence: AccelerationConfidence,
}

impl Decode for AccelerationComponent {
  fn decode<'a, D>(decoder: &D, input: &'a [u8]) -> IResult<&'a [u8], Self>
  where
    D: Decoder,
    Self: Sized,
  {
      let mut remaining = input;
      let mut instance = Self::default();
      AccelerationValue::decode(decoder, remaining).map(|(r, v)| { remaining = r; instance.value = v; })?;
      AccelerationConfidence::decode(decoder, remaining).map(|(r, v)| { remaining = r; instance.confidence = v; })?;
      Ok((remaining, instance))
  }
}




/* * 
 * This DF represents information associated to changes in acceleration. 
 *
 * It shall include the following components: 
 *
 * @field accelOrDecel: the indication of an acceleration change.
 *
 * @field actionDeltaTime: the period over which the acceleration change action is performed.
 *
 * @category: Kinematic Information
 * @revision: Created in V2.1.1
 */
#[derive(Debug, Clone, PartialEq, Default)]
pub struct AccelerationChangeIndication {
  pub accelOrDecel: AccelerationChange,
  pub actionDeltaTime: DeltaTimeTenthOfSecond,
  pub unknown_extension: Vec<u8>,
}

impl Decode for AccelerationChangeIndication {
  fn decode<'a, D>(decoder: &D, input: &'a [u8]) -> IResult<&'a [u8], Self>
  where
    D: Decoder,
    Self: Sized,
  {
      let mut remaining = input;
      let mut instance = Self::default();
      let mut is_extended = false;
      decoder.decode_extension_marker(input).map(|(r, v)| {{ remaining = r; is_extended = v; }})?;
      AccelerationChange::decode(decoder, remaining).map(|(r, v)| { remaining = r; instance.accelOrDecel = v; })?;
      DeltaTimeTenthOfSecond::decode(decoder, remaining).map(|(r, v)| { remaining = r; instance.actionDeltaTime = v; })?;
      decoder.decode_unknown_extension(input).map(|(r, v)| {{ remaining = r; instance.unknown_extension = v; }})?;
      Ok((remaining, instance))
  }
}




/* *
 * This DF represents the magnitude of the acceleration vector and associated confidence value.
 *
 * It shall include the following components: 
 * 
 * @field accelerationMagnitudeValue: the magnitude of the acceleration vector.
 * 
 * @field accelerationConfidence: the confidence value of the magnitude value.
 *
 * @category: Kinematic information
 * @revision: Created in V2.1.1
 */
#[derive(Debug, Clone, PartialEq, Default)]
pub struct AccelerationMagnitude {
  pub accelerationMagnitudeValue: AccelerationMagnitudeValue,
  pub accelerationConfidence: AccelerationConfidence,
}

impl Decode for AccelerationMagnitude {
  fn decode<'a, D>(decoder: &D, input: &'a [u8]) -> IResult<&'a [u8], Self>
  where
    D: Decoder,
    Self: Sized,
  {
      let mut remaining = input;
      let mut instance = Self::default();
      AccelerationMagnitudeValue::decode(decoder, remaining).map(|(r, v)| { remaining = r; instance.accelerationMagnitudeValue = v; })?;
      AccelerationConfidence::decode(decoder, remaining).map(|(r, v)| { remaining = r; instance.accelerationConfidence = v; })?;
      Ok((remaining, instance))
  }
}




/* *
 * This DF represents an identifier used to describe a protocol action taken by an ITS-S.
 * 
 * It shall include the following components: 
 *
 * @field originatingStationId: Id of the ITS-S that takes the action. 
 * 
 * @field sequenceNumber: a sequence number. 
 * 
 * @category: Communication information
 * @revision: Created in V2.1.1 based on @ref ActionID.
 */
#[derive(Debug, Clone, PartialEq, Default)]
pub struct ActionId {
  pub originatingStationId: StationId,
  pub sequenceNumber: SequenceNumber,
}

impl Decode for ActionId {
  fn decode<'a, D>(decoder: &D, input: &'a [u8]) -> IResult<&'a [u8], Self>
  where
    D: Decoder,
    Self: Sized,
  {
      let mut remaining = input;
      let mut instance = Self::default();
      StationId::decode(decoder, remaining).map(|(r, v)| { remaining = r; instance.originatingStationId = v; })?;
      SequenceNumber::decode(decoder, remaining).map(|(r, v)| { remaining = r; instance.sequenceNumber = v; })?;
      Ok((remaining, instance))
  }
}




/* *
 * This DF represents an identifier used to describe a protocol action taken by an ITS-S.
 * 
 * It shall include the following components: 
 *
 * @field originatingStationId: Id of the ITS-S that takes the action. 
 * 
 * @field sequenceNumber: a sequence number. 
 * 
 * @note: this DF is kept for backwards compatibility reasons only. It is recommended to use the @ref ActionId instead. 
 * @category: Communication information
 * @revision: V1.3.1
 */
#[derive(Debug, Clone, PartialEq, Default)]
pub struct ActionID {
  pub originatingStationId: StationID,
  pub sequenceNumber: SequenceNumber,
}

impl Decode for ActionID {
  fn decode<'a, D>(decoder: &D, input: &'a [u8]) -> IResult<&'a [u8], Self>
  where
    D: Decoder,
    Self: Sized,
  {
      let mut remaining = input;
      let mut instance = Self::default();
      StationID::decode(decoder, remaining).map(|(r, v)| { remaining = r; instance.originatingStationId = v; })?;
      SequenceNumber::decode(decoder, remaining).map(|(r, v)| { remaining = r; instance.sequenceNumber = v; })?;
      Ok((remaining, instance))
  }
}


    
/* *
 * This DF shall contain a list of @ref ActionId. 

 * @category: Communication Information
 * @revision: Created in V2.1.1 based on ReferenceDenms from DENM Release 1
*/
#[derive(Debug, Clone, PartialEq, Default)]
pub struct ActionIdList(pub Vec<ActionId>);

impl Decode for ActionIdList {
    fn decode<'a, D>(decoder: &D, input: &'a [u8]) -> IResult<&'a [u8], Self>
    where
        D: Decoder,
        Self: Sized,
    {
        let mut remaining = input;
        let mut instance = Self::default();
        let mut sequence_of_size: usize = 0;
        decoder.decode_sequence_of_size(remaining).map(|(r, v)| { 
          remaining = r; sequence_of_size = v; 
        })?;
        for _ in 0..sequence_of_size {
          ActionId::decode(decoder, remaining).map(|(r, v)| { 
            remaining = r; instance.0.push(v); 
          })?;
        }
        Ok((remaining, instance))
    }
}




/* *
 * This DF provides the altitude and confidence level of an altitude information in a WGS84 coordinate system.
 * The specific WGS84 coordinate system is specified by the corresponding standards applying this DE.
 *
 * It shall include the following components: 
 *
 * @field altitudeValue: altitude of a geographical point.
 *
 * @field altitudeConfidence: confidence level of the altitudeValue.
 *
 * @note: this DF is kept for backwards compatibility reasons only. It is recommended to use the @ref AltitudeWithConfidence instead. 
 * @category: GeoReference information
 * @revision: Description revised in V2.1.1
 */
#[derive(Debug, Clone, PartialEq, Default)]
pub struct Altitude {
  pub altitudeValue: AltitudeValue,
  pub altitudeConfidence: AltitudeConfidence,
}

impl Decode for Altitude {
  fn decode<'a, D>(decoder: &D, input: &'a [u8]) -> IResult<&'a [u8], Self>
  where
    D: Decoder,
    Self: Sized,
  {
      let mut remaining = input;
      let mut instance = Self::default();
      AltitudeValue::decode(decoder, remaining).map(|(r, v)| { remaining = r; instance.altitudeValue = v; })?;
      AltitudeConfidence::decode(decoder, remaining).map(|(r, v)| { remaining = r; instance.altitudeConfidence = v; })?;
      Ok((remaining, instance))
  }
}




/* * 
 * This DE represents a general container for usage in various types of messages.
 *
 * It shall include the following components: 
 *
 * @field stationType: the type of technical context in which the ITS-S that has generated the message is integrated in.
 *
 * @field referencePosition: the reference position of the station that has generated the message that contains the basic container.
 *
 * @category: Basic information
 * @revision: Created in V2.1.1
*/
#[derive(Debug, Clone, PartialEq, Default)]
pub struct BasicContainer {
  pub stationType: TrafficParticipantType,
  pub referencePosition: ReferencePositionWithConfidence,
  pub unknown_extension: Vec<u8>,
}

impl Decode for BasicContainer {
  fn decode<'a, D>(decoder: &D, input: &'a [u8]) -> IResult<&'a [u8], Self>
  where
    D: Decoder,
    Self: Sized,
  {
      let mut remaining = input;
      let mut instance = Self::default();
      let mut is_extended = false;
      decoder.decode_extension_marker(input).map(|(r, v)| {{ remaining = r; is_extended = v; }})?;
      TrafficParticipantType::decode(decoder, remaining).map(|(r, v)| { remaining = r; instance.stationType = v; })?;
      ReferencePositionWithConfidence::decode(decoder, remaining).map(|(r, v)| { remaining = r; instance.referencePosition = v; })?;
      decoder.decode_unknown_extension(input).map(|(r, v)| {{ remaining = r; instance.unknown_extension = v; }})?;
      Ok((remaining, instance))
  }
}




/* * 
 * This DF represents a general Data Frame to describe an angle component along with a confidence value in a cartesian coordinate system.
 *
 * It shall include the following components: 
 *
 * @field value: The angle value which can be estimated as the mean of the current distribution.
 *
 * @field confidence: The confidence value associated to the provided value.
 *
 * @category: Basic information
 * @revision: Created in V2.1.1
 */
#[derive(Debug, Clone, PartialEq, Default)]
pub struct CartesianAngle {
  pub value: CartesianAngleValue,
  pub confidence: AngleConfidence,
}

impl Decode for CartesianAngle {
  fn decode<'a, D>(decoder: &D, input: &'a [u8]) -> IResult<&'a [u8], Self>
  where
    D: Decoder,
    Self: Sized,
  {
      let mut remaining = input;
      let mut instance = Self::default();
      CartesianAngleValue::decode(decoder, remaining).map(|(r, v)| { remaining = r; instance.value = v; })?;
      AngleConfidence::decode(decoder, remaining).map(|(r, v)| { remaining = r; instance.confidence = v; })?;
      Ok((remaining, instance))
  }
}




/* * 
 * This DF represents an angular velocity component along with a confidence value in a cartesian coordinate system.
 *
 * It shall include the following components: 
 *
 * @field value: The angular velocity component.
 *
 * @field confidence: The confidence value associated to the provided value.
 *
 * @category: Kinematic information
 * @revision: Created in V2.1.1
 */
#[derive(Debug, Clone, PartialEq, Default)]
pub struct CartesianAngularVelocityComponent {
  pub value: CartesianAngularVelocityComponentValue,
  pub confidence: AngularSpeedConfidence,
}

impl Decode for CartesianAngularVelocityComponent {
  fn decode<'a, D>(decoder: &D, input: &'a [u8]) -> IResult<&'a [u8], Self>
  where
    D: Decoder,
    Self: Sized,
  {
      let mut remaining = input;
      let mut instance = Self::default();
      CartesianAngularVelocityComponentValue::decode(decoder, remaining).map(|(r, v)| { remaining = r; instance.value = v; })?;
      AngularSpeedConfidence::decode(decoder, remaining).map(|(r, v)| { remaining = r; instance.confidence = v; })?;
      Ok((remaining, instance))
  }
}




/* * 
 * This DF represents a general Data Frame to describe an angular acceleration component along with a confidence value in a cartesian coordinate system.
 *
 * It shall include the following components: 
 *
 * @field value: The angular acceleration component value.
 *
 * @field confidence: The confidence value associated to the provided value.
 * 
 * @category: Kinematic information
 * @revision: Created in V2.1.1 
 */
#[derive(Debug, Clone, PartialEq, Default)]
pub struct CartesianAngularAccelerationComponent {
  pub value: CartesianAngularAccelerationComponentValue,
  pub confidence: AngularAccelerationConfidence,
}

impl Decode for CartesianAngularAccelerationComponent {
  fn decode<'a, D>(decoder: &D, input: &'a [u8]) -> IResult<&'a [u8], Self>
  where
    D: Decoder,
    Self: Sized,
  {
      let mut remaining = input;
      let mut instance = Self::default();
      CartesianAngularAccelerationComponentValue::decode(decoder, remaining).map(|(r, v)| { remaining = r; instance.value = v; })?;
      AngularAccelerationConfidence::decode(decoder, remaining).map(|(r, v)| { remaining = r; instance.confidence = v; })?;
      Ok((remaining, instance))
  }
}




/* *
 * This DF represents a coordinate along with a confidence value in a cartesian reference system.
 *
 * It shall include the following components: 
 * 
 * @field value: the coordinate value, which can be estimated as the mean of the current distribution.
 * 
 * @field confidence: the coordinate confidence value associated to the provided value.
 *
 * @category: GeoReference information
 * @revision: Created in V2.1.1
*/
#[derive(Debug, Clone, PartialEq, Default)]
pub struct CartesianCoordinateWithConfidence {
  pub value: CartesianCoordinateLarge,
  pub confidence: CoordinateConfidence,
}

impl Decode for CartesianCoordinateWithConfidence {
  fn decode<'a, D>(decoder: &D, input: &'a [u8]) -> IResult<&'a [u8], Self>
  where
    D: Decoder,
    Self: Sized,
  {
      let mut remaining = input;
      let mut instance = Self::default();
      CartesianCoordinateLarge::decode(decoder, remaining).map(|(r, v)| { remaining = r; instance.value = v; })?;
      CoordinateConfidence::decode(decoder, remaining).map(|(r, v)| { remaining = r; instance.confidence = v; })?;
      Ok((remaining, instance))
  }
}




/* * 
 * This DF represents a  position in a two- or three-dimensional cartesian coordinate system.
 *
 * It shall include the following components: 
 *
 * @field xCoordinate: the X coordinate value.
 *
 * @field yCoordinate: the Y coordinate value.
 *
 * @field zCoordinate: the optional Z coordinate value.
 * 
 * @category: GeoReference information
 * @revision: Created in V2.1.1
*/
#[derive(Debug, Clone, PartialEq, Default)]
pub struct CartesianPosition3d {
  pub xCoordinate: CartesianCoordinate,
  pub yCoordinate: CartesianCoordinate,
  pub zCoordinate: CartesianCoordinate,
}

impl Decode for CartesianPosition3d {
  fn decode<'a, D>(decoder: &D, input: &'a [u8]) -> IResult<&'a [u8], Self>
  where
    D: Decoder,
    Self: Sized,
  {
      let mut remaining = input;
      let mut instance = Self::default();
      CartesianCoordinate::decode(decoder, remaining).map(|(r, v)| { remaining = r; instance.xCoordinate = v; })?;
      CartesianCoordinate::decode(decoder, remaining).map(|(r, v)| { remaining = r; instance.yCoordinate = v; })?;
      CartesianCoordinate::decode(decoder, remaining).map(|(r, v)| { remaining = r; instance.zCoordinate = v; })?;
      Ok((remaining, instance))
  }
}




/* * 
 * This DF represents a  position in a two- or three-dimensional cartesian coordinate system with an associated confidence level for each coordinate.
 *
 * It shall include the following components: 
 *
 * @field xCoordinate: the X coordinate value with the associated confidence level.
 *
 * @field yCoordinate: the Y coordinate value with the associated confidence level.
 *
 * @field zCoordinate: the optional Z coordinate value with the associated confidence level.
 * 
 * @category: GeoReference information
 * @revision: Created in V2.1.1
*/
#[derive(Debug, Clone, PartialEq, Default)]
pub struct CartesianPosition3dWithConfidence {
  pub xCoordinate: CartesianCoordinateWithConfidence,
  pub yCoordinate: CartesianCoordinateWithConfidence,
  pub zCoordinate: CartesianCoordinateWithConfidence,
}

impl Decode for CartesianPosition3dWithConfidence {
  fn decode<'a, D>(decoder: &D, input: &'a [u8]) -> IResult<&'a [u8], Self>
  where
    D: Decoder,
    Self: Sized,
  {
      let mut remaining = input;
      let mut instance = Self::default();
      CartesianCoordinateWithConfidence::decode(decoder, remaining).map(|(r, v)| { remaining = r; instance.xCoordinate = v; })?;
      CartesianCoordinateWithConfidence::decode(decoder, remaining).map(|(r, v)| { remaining = r; instance.yCoordinate = v; })?;
      CartesianCoordinateWithConfidence::decode(decoder, remaining).map(|(r, v)| { remaining = r; instance.zCoordinate = v; })?;
      Ok((remaining, instance))
  }
}




/* *
 * This DF is a representation of the cause code value of a traffic event. 
 *
 * It shall include the following components: 
 *
 * @field causeCode: the main cause of a detected event. 
 *
 * @field subCauseCode: the subordinate cause of a detected event. 
 *
 * The semantics of the entire DF are completely defined by the component causeCode. The interpretation of the subCauseCode may 
 * provide additional information that is not strictly necessary to understand the causeCode itself, and is therefore optional.
 *
 * @note: this DF is kept for backwards compatibility reasons only. It is recommended to use the @ref CauseCodeV2 instead. 
 *
 * @category: Traffic information
 * @revision: Editorial update in V2.1.1
 */
#[derive(Debug, Clone, PartialEq, Default)]
pub struct CauseCode {
  pub causeCode: CauseCodeType,
  pub subCauseCode: SubCauseCodeType,
  pub unknown_extension: Vec<u8>,
}

impl Decode for CauseCode {
  fn decode<'a, D>(decoder: &D, input: &'a [u8]) -> IResult<&'a [u8], Self>
  where
    D: Decoder,
    Self: Sized,
  {
      let mut remaining = input;
      let mut instance = Self::default();
      let mut is_extended = false;
      decoder.decode_extension_marker(input).map(|(r, v)| {{ remaining = r; is_extended = v; }})?;
      CauseCodeType::decode(decoder, remaining).map(|(r, v)| { remaining = r; instance.causeCode = v; })?;
      SubCauseCodeType::decode(decoder, remaining).map(|(r, v)| { remaining = r; instance.subCauseCode = v; })?;
      decoder.decode_unknown_extension(input).map(|(r, v)| {{ remaining = r; instance.unknown_extension = v; }})?;
      Ok((remaining, instance))
  }
}


/* *
 * This DE represents the World Manufacturer Identifier (WMI). The values are assigned according to ISO 3779 [6].
 * 
 *
 * @category: Vehicle information
 * @revision: V1.3.1
 */
#[derive(Debug, Clone, PartialEq, Default)]
pub struct WMInumber(pub String);

impl Decode for WMInumber {
fn decode<'a, D>(decoder: &D, input: &'a [u8]) -> IResult<&'a [u8], Self>
where
    D: Decoder,
    Self: Sized,
{
    decoder
        .decode_character_string(AsnCharacterString { constraint: Some(Constraint { min_value: Some(1), max_value: Some(3), extensible: false }), r#type: CharacterStringType::IA5String })(input)
        .map(|(remaining, res)| (remaining, Self(res)))
}
}


/* *
 * This DE represents the Vehicle Descriptor Section (VDS). The values are assigned according to ISO 3779 [6].
 * 
 * @category: Vehicle information
 * @revision: V1.3.1
 */
#[derive(Debug, Clone, PartialEq, Default)]
pub struct VDS(pub String);

impl Decode for VDS {
fn decode<'a, D>(decoder: &D, input: &'a [u8]) -> IResult<&'a [u8], Self>
where
    D: Decoder,
    Self: Sized,
{
    decoder
        .decode_character_string(AsnCharacterString { constraint: Some(Constraint { min_value: Some(6), max_value: Some(6), extensible: false }), r#type: CharacterStringType::IA5String })(input)
        .map(|(remaining, res)| (remaining, Self(res)))
}
}


