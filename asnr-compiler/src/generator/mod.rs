//! The `generator` module is responsible
//! for generating rust code that handles
//! decoding and encoding of the parsed and
//! validated ASN1 data elements.

use asnr_grammar::ToplevelDeclaration;

use self::{error::GeneratorError, template::{boolean_template, integer_template, enumerated_template, bit_string_template, character_string_template, sequence_template, sequence_of_template}};
pub(crate) mod error;
mod template;
mod util;

pub const GENERATED_RUST_IMPORTS: &str = r#"// This file has been auto-generated by ASNR
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(dead_code)]
#![allow(unused_mut)]
#![allow(unused_variables)]

use asnr_grammar::*;
use nom::IResult;
use asnr_transcoder::{error::{DecodingError, DecodingErrorType}, Decode, Decoder};

"#;

pub fn generate<'a>(
    tld: ToplevelDeclaration,
    custom_derive: Option<&str>,
) -> Result<std::string::String, GeneratorError> {
    match tld.r#type {
        asnr_grammar::ASN1Type::Boolean => boolean_template(tld, custom_derive),
        asnr_grammar::ASN1Type::Integer(_) => integer_template(tld, custom_derive),
        asnr_grammar::ASN1Type::Enumerated(_) => enumerated_template(tld, custom_derive),
        asnr_grammar::ASN1Type::BitString(_) => bit_string_template(tld, custom_derive),
        asnr_grammar::ASN1Type::CharacterString(_) => character_string_template(tld, custom_derive),
        asnr_grammar::ASN1Type::Sequence(_) => sequence_template(tld, custom_derive),
        asnr_grammar::ASN1Type::SequenceOf(_) => sequence_of_template(tld, custom_derive),
        _ => Ok("".into())
    }
}
