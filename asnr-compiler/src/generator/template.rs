use super::builder::StringifiedNameType;

pub const RUST_IMPORTS_TEMPLATE: &str = r#"// This file has been auto-generated by ASNR
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(dead_code)]
#![allow(unused_mut)]
#![allow(unused_variables)]

use alloc::{format, vec, vec::Vec, string::String, boxed::Box};
use asnr_grammar::{*, types::*, subtyping::*};
use asnr_transcoder::{error::{DecodingError, DecodingErrorType}, Decode, Decoder, DecodeMember, DecoderForIndex};
use nom::IResult;

"#;

pub const DERIVE_DEFAULT: &str = "#[derive(Debug, Clone, PartialEq, Default)]";

pub const DECODE_SIGNATURE: &str = r#"fn decode<'a, D>(decoder: &D, input: &'a [u8]) -> IResult<&'a [u8], Self>
where
    D: Decoder,
    Self: Sized,"#;

pub fn integer_template(
    comments: String,
    derive: &str,
    name: String,
    integer_type: &str,
    distinguished_values: String,
    int_descriptor: String,
) -> String {
    format!(
        r#"
{comments}{derive}
pub struct {name}(pub {integer_type});{distinguished_values}

impl Decode for {name} {{
  {DECODE_SIGNATURE}
  {{
    decoder
      .decode_integer({int_descriptor})(input)
      .map(|(remaining, res)| (remaining, Self(res)))
  }}
}}
"#
    )
}

pub fn bit_string_template(
    comments: String,
    derive: &str,
    name: String,
    distinguished_values: String,
    bitstr_descriptor: String,
) -> String {
    format!(
        r#"
{comments}{derive}
pub struct {name}(pub Vec<bool>);{distinguished_values}

impl Decode for {name} {{
{DECODE_SIGNATURE}
  {{
    decoder
      .decode_bit_string({bitstr_descriptor})(input)
      .map(|(remaining, res)| (remaining, Self(res)))
  }}
}}
"#,
    )
}

pub fn char_string_template(
    comments: String,
    derive: &str,
    name: String,
    charstr_descriptor: String,
) -> String {
    format!(
        r#"
{comments}{derive}
pub struct {name}(pub String);

impl Decode for {name} {{
  {DECODE_SIGNATURE}
  {{
    decoder
      .decode_character_string({charstr_descriptor})(input)
      .map(|(remaining, res)| (remaining, Self(res)))
  }}
}}
"#,
    )
}


pub fn boolean_template(
  comments: String,
  derive: &str,
  name: String,
) -> String {
  format!(
    r#"
{comments}{derive}
pub struct {name}(pub bool);

impl Decode for {name} {{
  {DECODE_SIGNATURE}
  {{
    decoder
      .decode_boolean(input)
      .map(|(remaining, res)| (remaining, Self(res)))
  }}
}}
"#
)
}

pub fn enumerated_template(
    comments: String,
    derive: &str,
    name: String,
    enumerals: String,
    enumerals_from_int: String,
    enum_descriptor: String,
) -> String {
    format!(
        r#"
  {comments}{derive}
  pub enum {name} {{
    #[default]
    {enumerals}
  }}
  
  impl TryFrom<i128> for {name} {{
    type Error = DecodingError;
  
    fn try_from(v: i128) -> Result<Self, Self::Error> {{
      match v {{
          {enumerals_from_int}
          _ => Err(
            DecodingError::new(
              &format!("Invalid enumerated index decoding {name}. Received index {{}}",v), DecodingErrorType::InvalidEnumeratedIndex
            )
          ),
      }}
    }}
  }}
  
  impl Decode for {name} {{
    {DECODE_SIGNATURE}
    {{
      decoder.decode_enumerated({enum_descriptor})( 
        input
      )
    }}
  }}
  "#,
    )
}

pub fn sequence_template(
    comments: String,
    derive: &str,
    name: String,
    inner_members: String,
    member_declaration: String,
    extension_decl: String,
    decode_member_body: String,
    extension_decoder: String,
    seq_descriptor: String,
) -> String {
    format!(
        r#"
  {inner_members}
  
  {comments}{derive}
  pub struct {name} {{
    {member_declaration}{extension_decl}
  }}
  
  impl DecodeMember for {name} {{
    fn decode_member_at_index<'a, D>(&mut self, index: usize, decoder: &D, input: &'a [u8]) -> Result<(&'a [u8], ()), DecodingError>
      where
          D: Decoder,
          Self: Sized,
    {{
      let mut input = input;
      match index {{
        {decode_member_body}
        _ => {extension_decoder}
      }}
      Ok((input, ()))
    }}
  }}
  
  impl Decode for {name} {{
    {DECODE_SIGNATURE}
    {{
        decoder.decode_sequence({seq_descriptor})( 
          input
        )
    }}
  }}
  "#
    )
}

pub fn sequence_of_template(
  comments: String,
    derive: &str,
    name: String,
    anonymous_item: String,
    member_type: String,
    seq_of_descriptor: String,
) -> String {
  format!(
    r#"{anonymous_item}

{comments}{derive}
pub struct {name}(pub Vec<{member_type}>);

impl Decode for {name} {{
  {DECODE_SIGNATURE}
  {{
    decoder
      .decode_sequence_of({seq_of_descriptor}, |d, i| {{ {member_type}::decode(d, i) }})(input)
      .map(|(remaining, res)| (remaining, Self(res)))
  }}
}}
"#
)
}

pub fn default_choice(
  option: &StringifiedNameType
)  -> String {
  format!("Self::{name}({rtype}::default())", name = option.name, rtype = option.r#type)
}

pub fn choice_template(
  comments: String,
  derive: &str,
  name: String,
  anonymous_option: String,
  default_option: String,
  options: String,
  options_from_int: String,
  choice_descriptor: String,
) -> String {
  format!(
      r#"{anonymous_option}

{comments}{derive}
pub enum {name} {{
  {options}
}}

impl DecoderForIndex for {name} {{
  fn decoder_for_index<'a, D>(v: i128) -> Result<fn(&D, &'a [u8]) -> IResult<&'a [u8], Self>, DecodingError> where D: Decoder, Self: Sized {{
    match v {{
        {options_from_int}
        _ => Err(
          DecodingError::new(
            &format!("Invalid choice index decoding {name}. Received index {{}}",v), DecodingErrorType::InvalidChoiceIndex
          )
        ),
    }}
  }}
}}

impl Default for {name} {{
  fn default() -> Self {{
    {default_option}
  }}
}}

impl Decode for {name} {{
  {DECODE_SIGNATURE}
  {{
    decoder.decode_choice({choice_descriptor})( 
      input
    )
  }}
}}
"#,
  )
}
